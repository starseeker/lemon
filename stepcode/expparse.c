/* This file is automatically generated by Lemon from input grammar
** source file "expparse.y".
*/
/*
** 2000-05-29
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** Driver template for the LEMON parser generator.
**
** The "lemon" program processes an LALR(1) input grammar file, then uses
** this template to construct a parser.  The "lemon" program inserts text
** at each "%%" line.  Also, any "P-a-r-s-e" identifier prefix (without the
** interstitial "-" characters) contained in this template is changed into
** the value of the %name directive from the grammar.  Otherwise, the content
** of this template is copied straight through into the generate parser
** source file.
**
** The following is the concatenation of all %include directives from the
** input grammar file:
*/
/************ Begin %include sections from the grammar ************************/
#line 2 "expparse.y"

#include <assert.h>
#include "token_type.h"
#include "parse_data.h"

int yyerrstatus = 0;
#define yyerrok (yyerrstatus = 0)

YYSTYPE yylval;

    /*
     * YACC grammar for Express parser.
     *
     * This software was developed by U.S. Government employees as part of
     * their official duties and is not subject to copyright.
     *
     * $Log: expparse.y,v $
     * Revision 1.23  1997/11/14 17:09:04  libes
     * allow multiple group references
     *
     * ** 22 older revision log records removed 3 January 2014 **
     */

#include "express/symbol.h"
#include "express/linklist.h"
#include "stack.h"
#include "express/express.h"
#include "express/schema.h"
#include "express/entity.h"
#include "express/resolve.h"
#include "expscan.h"
#include <float.h>

    extern int print_objects_while_running;

    int tag_count;    /**< use this to count tagged GENERIC types in the formal
                         * argument lists.  Gross, but much easier to do it this
                         * way then with the 'help' of yacc. Set it to -1 to
                         * indicate that tags cannot be defined, only used
                         * (outside of formal parameter list, i.e. for return
                         * types). Hey, as long as there's a gross hack sitting
                         * around, we might as well milk it for all it's worth!
                         *   - snc
                         */

    int local_var_count; /**< used to keep LOCAL variables in order
                            * used in combination with Variable.offset
                            */

    Express yyexpresult;    /* hook to everything built by parser */

    Symbol *interface_schema;    /* schema of interest in use/ref clauses */
    void (*interface_func)(struct Scope_ *, Symbol *, Symbol *, Symbol *);    /* func to attach rename clauses */

    /* record schemas found in a single parse here, allowing them to be */
    /* differentiated from other schemas parsed earlier */
    Linked_List PARSEnew_schemas;

    void SCANskip_to_end_schema(perplex_t scanner);

    int yylineno;

    bool yyeof = false;

#define MAX_SCOPE_DEPTH    20    /* max number of scopes that can be nested */

    static struct scope {
        struct Scope_ *this_;
        char type;    /* one of OBJ_XXX */
        struct scope *pscope;    /* pointer back to most recent scope */
        /* that has a printable name - for better */
        /* error messages */
    } scopes[MAX_SCOPE_DEPTH], *scope;
#define CURRENT_SCOPE (scope->this_)
#define PREVIOUS_SCOPE ((scope-1)->this_)
#define CURRENT_SCHEMA (scope->this_->u.schema)
#define CURRENT_SCOPE_NAME        (OBJget_symbol(scope->pscope->this_,scope->pscope->type)->name)
#define CURRENT_SCOPE_TYPE_PRINTABLE    (OBJget_type(scope->pscope->type))

    /* ths = new scope to enter */
    /* sym = name of scope to enter into parent.  Some scopes (i.e., increment) */
    /*       are not named, in which case sym should be 0 */
    /*     This is useful for when a diagnostic is printed, an earlier named */
    /*      scoped can be used */
    /* typ = type of scope */
#define PUSH_SCOPE(ths,sym,typ) \
    if (sym) DICTdefine(scope->this_->symbol_table,(sym)->name,(Generic)ths,sym,typ);\
    ths->superscope = scope->this_; \
    scope++;        \
    scope->type = typ;    \
    scope->pscope = (sym?scope:(scope-1)->pscope); \
    scope->this_ = ths; \
    if (sym) { \
        ths->symbol = *(sym); \
    }
#define POP_SCOPE() scope--

    /* PUSH_SCOPE_DUMMY just pushes the scope stack with nothing actually on it */
    /* Necessary for situations when a POP_SCOPE is unnecessary but inevitable */
#define PUSH_SCOPE_DUMMY() scope++

    /* normally the superscope is added by PUSH_SCOPE, but some things (types) */
    /* bother to get pushed so fix them this way */
#define SCOPEadd_super(ths) ths->superscope = scope->this_;

#define ERROR(code)    ERRORreport(code, yylineno)

void parserInitState( void )
{
    scope = scopes;
    /* no need to define scope->this */
    scope->this_ = yyexpresult;
    scope->pscope = scope;
    scope->type = OBJ_EXPRESS;
    yyexpresult->symbol.name = yyexpresult->u.express->filename;
    yyexpresult->symbol.filename = yyexpresult->u.express->filename;
    yyexpresult->symbol.line = 1;
}
#line 149 "expparse.c"
/**************** End of %include directives **********************************/
/* These constants specify the various numeric values for terminal symbols.
***************** Begin token definitions *************************************/
#ifndef TOK_EQUAL
#define TOK_EQUAL                       1
#define TOK_GREATER_EQUAL               2
#define TOK_GREATER_THAN                3
#define TOK_IN                          4
#define TOK_INST_EQUAL                  5
#define TOK_INST_NOT_EQUAL              6
#define TOK_LESS_EQUAL                  7
#define TOK_LESS_THAN                   8
#define TOK_LIKE                        9
#define TOK_NOT_EQUAL                  10
#define TOK_MINUS                      11
#define TOK_PLUS                       12
#define TOK_OR                         13
#define TOK_XOR                        14
#define TOK_DIV                        15
#define TOK_MOD                        16
#define TOK_REAL_DIV                   17
#define TOK_TIMES                      18
#define TOK_AND                        19
#define TOK_ANDOR                      20
#define TOK_CONCAT_OP                  21
#define TOK_EXP                        22
#define TOK_NOT                        23
#define TOK_DOT                        24
#define TOK_BACKSLASH                  25
#define TOK_LEFT_BRACKET               26
#define TOK_LEFT_PAREN                 27
#define TOK_RIGHT_PAREN                28
#define TOK_RIGHT_BRACKET              29
#define TOK_COLON                      30
#define TOK_COMMA                      31
#define TOK_AGGREGATE                  32
#define TOK_OF                         33
#define TOK_IDENTIFIER                 34
#define TOK_ALIAS                      35
#define TOK_FOR                        36
#define TOK_END_ALIAS                  37
#define TOK_ARRAY                      38
#define TOK_ASSIGNMENT                 39
#define TOK_BAG                        40
#define TOK_BOOLEAN                    41
#define TOK_INTEGER                    42
#define TOK_REAL                       43
#define TOK_NUMBER                     44
#define TOK_LOGICAL                    45
#define TOK_BINARY                     46
#define TOK_STRING                     47
#define TOK_BY                         48
#define TOK_LEFT_CURL                  49
#define TOK_RIGHT_CURL                 50
#define TOK_OTHERWISE                  51
#define TOK_CASE                       52
#define TOK_END_CASE                   53
#define TOK_BEGIN                      54
#define TOK_END                        55
#define TOK_PI                         56
#define TOK_E                          57
#define TOK_CONSTANT                   58
#define TOK_END_CONSTANT               59
#define TOK_DERIVE                     60
#define TOK_END_ENTITY                 61
#define TOK_ENTITY                     62
#define TOK_ENUMERATION                63
#define TOK_ESCAPE                     64
#define TOK_SELF                       65
#define TOK_OPTIONAL                   66
#define TOK_VAR                        67
#define TOK_END_FUNCTION               68
#define TOK_FUNCTION                   69
#define TOK_BUILTIN_FUNCTION           70
#define TOK_LIST                       71
#define TOK_SET                        72
#define TOK_GENERIC                    73
#define TOK_QUESTION_MARK              74
#define TOK_IF                         75
#define TOK_THEN                       76
#define TOK_END_IF                     77
#define TOK_ELSE                       78
#define TOK_INCLUDE                    79
#define TOK_STRING_LITERAL             80
#define TOK_TO                         81
#define TOK_AS                         82
#define TOK_REFERENCE                  83
#define TOK_FROM                       84
#define TOK_USE                        85
#define TOK_INVERSE                    86
#define TOK_INTEGER_LITERAL            87
#define TOK_REAL_LITERAL               88
#define TOK_STRING_LITERAL_ENCODED     89
#define TOK_LOGICAL_LITERAL            90
#define TOK_BINARY_LITERAL             91
#define TOK_LOCAL                      92
#define TOK_END_LOCAL                  93
#define TOK_ONEOF                      94
#define TOK_UNIQUE                     95
#define TOK_FIXED                      96
#define TOK_END_PROCEDURE              97
#define TOK_PROCEDURE                  98
#define TOK_BUILTIN_PROCEDURE          99
#define TOK_QUERY                      100
#define TOK_ALL_IN                     101
#define TOK_SUCH_THAT                  102
#define TOK_REPEAT                     103
#define TOK_END_REPEAT                 104
#define TOK_RETURN                     105
#define TOK_END_RULE                   106
#define TOK_RULE                       107
#define TOK_END_SCHEMA                 108
#define TOK_SCHEMA                     109
#define TOK_SELECT                     110
#define TOK_SEMICOLON                  111
#define TOK_SKIP                       112
#define TOK_SUBTYPE                    113
#define TOK_ABSTRACT                   114
#define TOK_SUPERTYPE                  115
#define TOK_END_TYPE                   116
#define TOK_TYPE                       117
#define TOK_UNTIL                      118
#define TOK_WHERE                      119
#define TOK_WHILE                      120
#endif
/**************** End token definitions ***************************************/

/* The next sections is a series of control #defines.
** various aspects of the generated parser.
**    YYCODETYPE         is the data type used to store the integer codes
**                       that represent terminal and non-terminal symbols.
**                       "unsigned char" is used if there are fewer than
**                       256 symbols.  Larger types otherwise.
**    YYNOCODE           is a number of type YYCODETYPE that is not used for
**                       any terminal or nonterminal symbol.
**    YYFALLBACK         If defined, this indicates that one or more tokens
**                       (also known as: "terminal symbols") have fall-back
**                       values which should be used if the original symbol
**                       would not parse.  This permits keywords to sometimes
**                       be used as identifiers, for example.
**    YYACTIONTYPE       is the data type used for "action codes" - numbers
**                       that indicate what to do in response to the next
**                       token.
**    ParseTOKENTYPE     is the data type used for minor type for terminal
**                       symbols.  Background: A "minor type" is a semantic
**                       value associated with a terminal or non-terminal
**                       symbols.  For example, for an "ID" terminal symbol,
**                       the minor type might be the name of the identifier.
**                       Each non-terminal can have a different minor type.
**                       Terminal symbols all have the same minor type, though.
**                       This macros defines the minor type for terminal 
**                       symbols.
**    YYMINORTYPE        is the data type used for all minor types.
**                       This is typically a union of many types, one of
**                       which is ParseTOKENTYPE.  The entry in the union
**                       for terminal symbols is called "yy0".
**    YYSTACKDEPTH       is the maximum depth of the parser's stack.  If
**                       zero the stack is dynamically sized using realloc()
**    ParseARG_SDECL     A static variable declaration for the %extra_argument
**    ParseARG_PDECL     A parameter declaration for the %extra_argument
**    ParseARG_PARAM     Code to pass %extra_argument as a subroutine parameter
**    ParseARG_STORE     Code to store %extra_argument into yypParser
**    ParseARG_FETCH     Code to extract %extra_argument from yypParser
**    ParseCTX_*         As ParseARG_ except for %extra_context
**    YYREALLOC          Name of the realloc() function to use
**    YYFREE             Name of the free() function to use
**    YYDYNSTACK         True if stack space should be extended on heap
**    YYERRORSYMBOL      is the code number of the error symbol.  If not
**                       defined, then do no error processing.
**    YYNSTATE           the combined number of states.
**    YYNRULE            the number of rules in the grammar
**    YYNTOKEN           Number of terminal symbols
**    YY_MAX_SHIFT       Maximum value for shift actions
**    YY_MIN_SHIFTREDUCE Minimum value for shift-reduce actions
**    YY_MAX_SHIFTREDUCE Maximum value for shift-reduce actions
**    YY_ERROR_ACTION    The yy_action[] code for syntax error
**    YY_ACCEPT_ACTION   The yy_action[] code for accept
**    YY_NO_ACTION       The yy_action[] code for no-op
**    YY_MIN_REDUCE      Minimum value for reduce actions
**    YY_MAX_REDUCE      Maximum value for reduce actions
**    YY_MIN_DSTRCTR     Minimum symbol value that has a destructor
**    YY_MAX_DSTRCTR     Maximum symbol value that has a destructor
*/
#ifndef INTERFACE
# define INTERFACE 1
#endif
/************* Begin control #defines *****************************************/
#define YYCODETYPE unsigned short int
#define YYNOCODE 278
#define YYACTIONTYPE unsigned short int
#define ParseTOKENTYPE  YYSTYPE 
typedef union {
  int yyinit;
  ParseTOKENTYPE yy0;
  struct upper_lower yy58;
  TypeBody yy61;
  Case_Item yy75;
  struct qualifier yy84;
  Type yy211;
  Where yy228;
  Linked_List yy235;
  struct type_either yy236;
  Statement yy242;
  Integer yy263;
  Op_Code yy282;
  Symbol* yy301;
  struct subsuper_decl yy302;
  Variable yy319;
  struct subtypes yy325;
  struct type_flags yy328;
  struct entity_body yy388;
  Expression yy509;
} YYMINORTYPE;
#ifndef YYSTACKDEPTH
#define YYSTACKDEPTH 0
#endif
#define ParseARG_SDECL  parse_data_t parseData ;
#define ParseARG_PDECL , parse_data_t parseData 
#define ParseARG_PARAM ,parseData 
#define ParseARG_FETCH  parse_data_t parseData =yypParser->parseData ;
#define ParseARG_STORE yypParser->parseData =parseData ;
#undef YYREALLOC
#define YYREALLOC realloc
#undef YYFREE
#define YYFREE free
#undef YYDYNSTACK
#define YYDYNSTACK 0
#undef YYSIZELIMIT
#define ParseCTX(P) 0
#define ParseCTX_SDECL
#define ParseCTX_PDECL
#define ParseCTX_PARAM
#define ParseCTX_FETCH
#define ParseCTX_STORE
#undef YYERRORSYMBOL
#undef YYERRSYMDT
#undef YYFALLBACK
#define YYNSTATE             403
#define YYNRULE              332
#define YYNRULE_WITH_ACTION  323
#define YYNTOKEN             121
#define YY_MAX_SHIFT         402
#define YY_MIN_SHIFTREDUCE   645
#define YY_MAX_SHIFTREDUCE   976
#define YY_ERROR_ACTION      977
#define YY_ACCEPT_ACTION     978
#define YY_NO_ACTION         979
#define YY_MIN_REDUCE        980
#define YY_MAX_REDUCE        1311
#define YY_MIN_DSTRCTR       121
#define YY_MAX_DSTRCTR       121
/************* End control #defines *******************************************/
#define YY_NLOOKAHEAD ((int)(sizeof(yy_lookahead)/sizeof(yy_lookahead[0])))

/* Define the yytestcase() macro to be a no-op if is not already defined
** otherwise.
**
** Applications can choose to define yytestcase() in the %include section
** to a macro that can assist in verifying code coverage.  For production
** code the yytestcase() macro should be turned off.  But it is useful
** for testing.
*/
#ifndef yytestcase
# define yytestcase(X)
#endif

/* Macro to determine if stack space has the ability to grow using
** heap memory.
*/
#if YYSTACKDEPTH<=0 || YYDYNSTACK
# define YYGROWABLESTACK 1
#else
# define YYGROWABLESTACK 0
#endif

/* Guarantee a minimum number of initial stack slots.
*/
#if YYSTACKDEPTH<=0
# undef YYSTACKDEPTH
# define YYSTACKDEPTH 2  /* Need a minimum stack size */
#endif


/* Next are the tables used to determine what action to take based on the
** current state and lookahead token.  These tables are used to implement
** functions that take a state number and lookahead value and return an
** action integer.  
**
** Suppose the action integer is N.  Then the action is determined as
** follows
**
**   0 <= N <= YY_MAX_SHIFT             Shift N.  That is, push the lookahead
**                                      token onto the stack and goto state N.
**
**   N between YY_MIN_SHIFTREDUCE       Shift to an arbitrary state then
**     and YY_MAX_SHIFTREDUCE           reduce by rule N-YY_MIN_SHIFTREDUCE.
**
**   N == YY_ERROR_ACTION               A syntax error has occurred.
**
**   N == YY_ACCEPT_ACTION              The parser accepts its input.
**
**   N == YY_NO_ACTION                  No such action.  Denotes unused
**                                      slots in the yy_action[] table.
**
**   N between YY_MIN_REDUCE            Reduce by rule N-YY_MIN_REDUCE
**     and YY_MAX_REDUCE
**
** The action table is constructed as a single large table named yy_action[].
** Given state S and lookahead X, the action is computed as either:
**
**    (A)   N = yy_action[ yy_shift_ofst[S] + X ]
**    (B)   N = yy_default[S]
**
** The (A) formula is preferred.  The B formula is used instead if
** yy_lookahead[yy_shift_ofst[S]+X] is not equal to X.
**
** The formulas above are for computing the action when the lookahead is
** a terminal symbol.  If the lookahead is a non-terminal (as occurs after
** a reduce action) then the yy_reduce_ofst[] array is used in place of
** the yy_shift_ofst[] array.
**
** The following are the tables generated in this section:
**
**  yy_action[]        A single table containing all actions.
**  yy_lookahead[]     A table containing the lookahead for each entry in
**                     yy_action.  Used to detect hash collisions.
**  yy_shift_ofst[]    For each state, the offset into yy_action for
**                     shifting terminals.
**  yy_reduce_ofst[]   For each state, the offset into yy_action for
**                     shifting non-terminals after a reduce.
**  yy_default[]       Default action for each state.
**
*********** Begin parsing tables **********************************************/
#define YY_ACTTAB_COUNT (2627)
static const YYACTIONTYPE yy_action[] = {
 /*     0 */  1029, 1030, 1145,  216, 1270, 1133,  297,   64, 1164,  268,
 /*    10 */  1273,   77,   78, 1274,  370, 1276, 1272, 1300, 1267, 1277,
 /*    20 */    44,  153,  158,   79,   65, 1256,   16,   42, 1100,  127,
 /*    30 */  1101, 1098, 1270, 1110,  388,  309, 1164, 1099, 1273,  306,
 /*    40 */  1096, 1274,  159, 1276, 1272, 1268,  786, 1277,   44,   66,
 /*    50 */   155,  350,   71,   69,   70,   72,  702,  703,   74,   73,
 /*    60 */    90,   77,   78, 1256,  203,  788,  308,  249,  316, 1223,
 /*    70 */   774,   15, 1306,   79,  789,  108,   16,   42,  115,  652,
 /*    80 */   825, 1064,  790, 1186,  388,  199,  244,  823,  824,  826,
 /*    90 */   827,  828, 1142,  183, 1141,  179, 1143, 1251, 1223,   66,
 /*   100 */   387,  346,  144,  322, 1003,  318,  702,  703,  978,  118,
 /*   110 */  1063,   77,   78,  788,  244,  788, 1100,  200, 1101, 1098,
 /*   120 */   774, 1110,  789,   79,  789, 1099,   16,   42,  651, 1283,
 /*   130 */   825,  144,  721, 1256,  388, 1253,  757,  823,  824,  826,
 /*   140 */   827,  828,  840, 1100,  995, 1101, 1098,  359, 1110,   66,
 /*   150 */   387,  402, 1099,  320,  770,  402,  702,  703,  121,  373,
 /*   160 */   362,   77,   78,  378,  402,  788, 1100, 1112, 1101, 1098,
 /*   170 */   774, 1110, 1283,   79,  789, 1099,   16,   42,  111, 1288,
 /*   180 */   825,  315, 1166,  251,  312,  315,  170,  823,  824,  826,
 /*   190 */   827,  828,  250, 1284, 1256,  396,  395,   75,  362,   66,
 /*   200 */   387,  374,  137,  346,  284, 1252,  702,  703,  114, 1040,
 /*   210 */    35,   77,   78,  790,   24,  788, 1100, 1114, 1101, 1098,
 /*   220 */   774, 1110, 1289,   79,  789, 1099,   16,   42,   17,  170,
 /*   230 */   825,  401,  378,  721,  388,  299, 1284,  823,  824,  826,
 /*   240 */   827,  828, 1256,  115,  788, 1256, 1058,  359, 1097,   66,
 /*   250 */   387,  154,  307,  789,  770,  285,  702,  703, 1151, 1004,
 /*   260 */   367,  365,  361,  125,  378,  788, 1251,  154,  362,  222,
 /*   270 */   774, 1004,  203,   21,  789, 1004, 1172,  253,  836,  879,
 /*   280 */   825,  234, 1010,  251,  168,  132,  891,  823,  824,  826,
 /*   290 */   827,  828,  396,  348,   75,  353,  351,  345, 1008,  311,
 /*   300 */   387, 1007,  137,  380, 1006,  996,  997,  836,  998,  999,
 /*   310 */   114,  344, 1242,  298, 1251, 1283,  169, 1251, 1230, 1231,
 /*   320 */  1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239,    2,  362,
 /*   330 */  1245, 1049,  379,  129, 1230, 1231, 1232, 1233, 1234, 1235,
 /*   340 */  1236, 1237, 1238, 1239,    2,  373,  135,   76,  154,  129,
 /*   350 */  1100, 1116, 1101, 1098, 1256, 1110, 1004,  891, 1215, 1099,
 /*   360 */     3, 1107,  247,  224,  286,  154, 1100, 1118, 1101, 1098,
 /*   370 */   328, 1110,  171, 1004,  124, 1099,    3,  362, 1039, 1284,
 /*   380 */   362,   27,  383, 1270,  396,  395,   75, 1164,  278, 1273,
 /*   390 */   310, 1283, 1274, 1241, 1276, 1272,  130,  401, 1277,   44,
 /*   400 */   153,  158, 1100, 1117, 1101, 1098, 1129, 1110, 1300, 1051,
 /*   410 */   352, 1099,   10,  349,  314, 1230, 1231, 1232, 1233, 1234,
 /*   420 */  1235, 1236, 1237, 1238, 1239,    2, 1251,  301, 1005,  301,
 /*   430 */   129, 1172, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237,
 /*   440 */  1238, 1239,    2,  653, 1150,   23,  154,  129,  334,  113,
 /*   450 */   112, 1295,  226, 1008, 1004, 1285, 1007,    3,  914, 1006,
 /*   460 */   996,  997,  154,  998,  999,  244, 1100, 1115, 1101, 1098,
 /*   470 */  1004, 1110,  836, 1144,    3, 1099,  246,  368,  174,  678,
 /*   480 */   245,  243,  681,  682,  242,  240,   57,   56, 1294,  362,
 /*   490 */   209,  354,   60,   14,  204,   12,  134, 1050,   13,  760,
 /*   500 */    62,  330, 1003, 1100, 1113, 1101, 1098,  304, 1110,  173,
 /*   510 */   172,  110, 1099, 1230, 1231, 1232, 1233, 1234, 1235, 1236,
 /*   520 */  1237, 1238, 1239,    2,  122, 1168,  122,  333,  129, 1230,
 /*   530 */  1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239,    2,
 /*   540 */    29, 1270,   39,  154,  129, 1164,  151, 1273,  329,   98,
 /*   550 */  1274, 1004, 1276, 1272, 1271,    3, 1277,   44,  153,  158,
 /*   560 */   154, 1100, 1111, 1101, 1098,   39, 1110,  138, 1004,   39,
 /*   570 */  1099,    3,  202,   39,   14,  204,  100,   22, 1021,   13,
 /*   580 */   164,  188,  891,   94, 1020, 1022, 1023,   39,  355, 1042,
 /*   590 */  1043, 1044, 1045,  117,  229,  131,   67,   68,  215,  341,
 /*   600 */    71,   69,   70,   72,  340,  356,   74,   73,   91,  335,
 /*   610 */  1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239,
 /*   620 */     2,  339,  331,  244,  891,  129,  101, 1230, 1231, 1232,
 /*   630 */  1233, 1234, 1235, 1236, 1237, 1238, 1239,    2,  113,  112,
 /*   640 */  1210,  154,  129,   39,   39, 1296,  338,  923, 1059, 1004,
 /*   650 */   232,   84,    3,  113,  112,  371,   39,    9,   20,  981,
 /*   660 */   982,  983,  915,  237,  972,  185,  372,  182,  186,    3,
 /*   670 */  1042, 1043, 1044, 1045,  117,  891,   39,   14,  204,  218,
 /*   680 */     5, 1191,   13,   82,  332, 1286,  980, 1012, 1008,  890,
 /*   690 */   839, 1007,  223,  335, 1006,  996,  997, 1287,  998,  999,
 /*   700 */    14,  204,  381,  331,  382,   13,  399,  327, 1230, 1231,
 /*   710 */  1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239,    2,   88,
 /*   720 */   867,  869,  866,  129,  871,  872,  868,  865, 1224,  870,
 /*   730 */    67,   68,  103,  335,   71,   69,   70,   72,  891,  337,
 /*   740 */    74,   73,  102,  154,   19,   26,  113,  112,   67,   68,
 /*   750 */     3, 1004,   71,   69,   70,   72,  227,  167,   74,   73,
 /*   760 */     9,   20,  981,  982,  983, 1191,  861,   63,  922,  912,
 /*   770 */   154,  107,  223, 1042, 1043, 1044, 1045,  117, 1004, 1108,
 /*   780 */  1222, 1139,   36,    9,   20,  981,  982,  983,  178,  650,
 /*   790 */    14,  204,   45,  133, 1138,   13, 1042, 1043, 1044, 1045,
 /*   800 */   117, 1136, 1134, 1135, 1217, 1216,  331,  181, 1213,  326,
 /*   810 */  1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239,
 /*   820 */  1034,  300, 1103, 1157, 1008,  129, 1311, 1007,  191,  331,
 /*   830 */  1006,  996,  997, 1266,  998,  999, 1054, 1230, 1231, 1232,
 /*   840 */  1233, 1234, 1235, 1236, 1237, 1238, 1239, 1027, 1188,  194,
 /*   850 */   854,  195,  129,  302,  947,  836, 1187,  252, 1167,  165,
 /*   860 */  1104,  163,  678,  245,  243,  681,  682,  242,  240,   96,
 /*   870 */    99,  771,  303,  984,   20,  981,  982,  983,  139,  208,
 /*   880 */  1041, 1035, 1209,    1, 1229,   28, 1042, 1043, 1044, 1045,
 /*   890 */   117, 1211,  162,  161,  343,   53,   51,   54,   47,   49,
 /*   900 */    48,   52,   55,   46,   50, 1208,    4,   57,   56,  213,
 /*   910 */    27,  214, 1185,   60,  726, 1173, 1127, 1126,  367,  331,
 /*   920 */  1055,   53,   51,   54,   47,   49,   48,   52,   55,   46,
 /*   930 */    50, 1036, 1000,   57,   56,  254, 1052, 1062, 1246,   60,
 /*   940 */    81,   53,   51,   54,   47,   49,   48,   52,   55,   46,
 /*   950 */    50, 1152,  105,   57,   56, 1149,   67,   68, 1148,   60,
 /*   960 */    71,   69,   70,   72, 1147, 1146,   74,   73,   30,  141,
 /*   970 */    53,   51,   54,   47,   49,   48,   52,   55,   46,   50,
 /*   980 */   233,  119,   57,   56, 1048,   37,  235,   83,   60, 1100,
 /*   990 */   994, 1101, 1098,   86, 1110,  877,  847,  211, 1099, 1019,
 /*  1000 */    61,  239, 1018,  241, 1015,  891,   21,   53,   51,   54,
 /*  1010 */    47,   49,   48,   52,   55,   46,   50, 1014, 1102,   57,
 /*  1020 */    56,   31,   39,  400,  143,   60,  325,   53,   51,   54,
 /*  1030 */    47,   49,   48,   52,   55,   46,   50,   11,  196,   57,
 /*  1040 */    56, 1310, 1128,  836,  123,   60,    8,  246,  176,  174,
 /*  1050 */   678,  245,  243,  681,  682,  242,  240,  177,  180,  142,
 /*  1060 */   317,   53,   51,   54,   47,   49,   48,   52,   55,   46,
 /*  1070 */    50,  797,  319,   57,   56,  184,  321,  883,  323,   60,
 /*  1080 */   173,  172,    6,  324,  187,  189,  930,  192,  136,  820,
 /*  1090 */   193,   53,   51,   54,   47,   49,   48,   52,   55,   46,
 /*  1100 */    50,  197,   92,   57,   56,  198,  342,  787, 1261,   60,
 /*  1110 */    93, 1260, 1262,  336, 1259,  996,  997,  160,  998,  999,
 /*  1120 */    38, 1264,   53,   51,   54,   47,   49,   48,   52,   55,
 /*  1130 */    46,   50,   95,  201,   57,   56,   97,   67,   68,  785,
 /*  1140 */    60,   71,   69,   70,   72,  205, 1263,   74,   73,  849,
 /*  1150 */    25,   53,   51,   54,   47,   49,   48,   52,   55,   46,
 /*  1160 */    50, 1270,   80,   57,   56, 1164, 1193, 1273,  347,   60,
 /*  1170 */  1274,  190, 1276, 1272,   18,   59, 1277,   44,  940,  156,
 /*  1180 */    53,   51,   54,   47,   49,   48,   52,   55,   46,   50,
 /*  1190 */   206,  207,   57,   56,   32,  212,  217,  220,   60,  221,
 /*  1200 */    53,   51,   54,   47,   49,   48,   52,   55,   46,   50,
 /*  1210 */   116,  357,   57,   56,  718,  106,  104,  364,   60, 1100,
 /*  1220 */  1093, 1101, 1098,  360, 1110,  109,  363,  863, 1099,   53,
 /*  1230 */    51,   54,   47,   49,   48,   52,   55,   46,   50,  305,
 /*  1240 */   358,   57,   56,  244,  140,  366,  225,   60,  228, 1270,
 /*  1250 */   126,  369,  230, 1164,  151, 1273,  231,   34, 1274,    7,
 /*  1260 */  1276, 1272,  120,  722, 1277,   44,  153,  158,  375,  219,
 /*  1270 */   788,  376,  377,  845,   85,  238,  844,   43,  691,  789,
 /*  1280 */    33,  864,   40,   53,   51,   54,   47,   49,   48,   52,
 /*  1290 */    55,   46,   50,   41,  385,   57,   56,  386, 1108,   73,
 /*  1300 */   860,   60,  859,   60,  857,   87,  175,  248,  128, 1270,
 /*  1310 */   166,   89,   58, 1164,  276, 1273,  891,  210, 1274,  979,
 /*  1320 */  1276, 1272,  979,  979, 1277,   44,  153,  158,  384, 1270,
 /*  1330 */   979,  244,  979, 1164,  278, 1273,  979,  979, 1274,  979,
 /*  1340 */  1276, 1272,  979,  979, 1277,   44,  153,  158,  313,  979,
 /*  1350 */   979,  979,  979, 1297,  979,   53,   51,   54,   47,   49,
 /*  1360 */    48,   52,   55,   46,   50,  979,  979,   57,   56,  305,
 /*  1370 */   358,  979,  979,   60,   67,   68,  979,  979,   71,   69,
 /*  1380 */    70,   72,  979,  979,   74,   73,  979,   34,  979,    7,
 /*  1390 */   979,  244,  862,  979, 1228, 1008,  979,  979, 1007,  219,
 /*  1400 */   788, 1006,  996,  997,  979,  998,  999,  979,  979,  789,
 /*  1410 */    33,  244, 1270,  979,  979,  979, 1164,  267, 1273,  979,
 /*  1420 */   979, 1274,  979, 1276, 1272,  979,  979, 1277,   44,  153,
 /*  1430 */   158,  979,  979,  979,  857,  979,  979, 1270,  128,  979,
 /*  1440 */   166, 1164,  147, 1273,  979,  979, 1274,  210, 1276, 1272,
 /*  1450 */   979,  979, 1277,   44,  153,  158, 1270,  979,  979,  979,
 /*  1460 */  1164,  269, 1273,  979,  979, 1274,  979, 1276, 1272,  979,
 /*  1470 */   979, 1277,   44,  153,  158, 1270,  979,  979,  979, 1164,
 /*  1480 */   270, 1273,  979,  979, 1274,  979, 1276, 1272,  979,  979,
 /*  1490 */  1277,   44,  153,  158,  244, 1270,  979,  979,  979, 1164,
 /*  1500 */   271, 1273,  979,  979, 1274,  979, 1276, 1272,  979,  979,
 /*  1510 */  1277,   44,  153,  158,  979,  979, 1270,  979,  979,  244,
 /*  1520 */  1164,  255, 1273,  979,  979, 1274,  979, 1276, 1272,  979,
 /*  1530 */   979, 1277,   44,  153,  158,  979, 1270,  979,  244,  979,
 /*  1540 */  1164,  272, 1273,  979,  979, 1274,  979, 1276, 1272,  979,
 /*  1550 */   979, 1277,   44,  153,  158, 1270,  979,  244,  979, 1164,
 /*  1560 */   148, 1273,  979,  979, 1274,  979, 1276, 1272,  979,  979,
 /*  1570 */  1277,   44,  153,  158, 1270,  979,  979,  244, 1164,  256,
 /*  1580 */  1273,  979,  979, 1274,  979, 1276, 1272,  979,  979, 1277,
 /*  1590 */    44,  153,  158,  979,  979, 1270,  979,  979,  244, 1164,
 /*  1600 */   257, 1273,  979,  979, 1274,  979, 1276, 1272,  979,  979,
 /*  1610 */  1277,   44,  153,  158,  979,  979,  979, 1270,  244,  979,
 /*  1620 */   979, 1164,  258, 1273,  979,  979, 1274,  979, 1276, 1272,
 /*  1630 */   979,  979, 1277,   44,  153,  158,  979,  244,  979,  979,
 /*  1640 */   979,  979,  979, 1270,  979,  979,  979, 1164,  149, 1273,
 /*  1650 */   979,  979, 1274,  979, 1276, 1272,  244,  979, 1277,   44,
 /*  1660 */   153,  158,  979, 1270,  979,  979,  979, 1164,  150, 1273,
 /*  1670 */   979,  979, 1274,  979, 1276, 1272,  979,  244, 1277,   44,
 /*  1680 */   153,  158,  979,  979,  979,  979, 1270,  979,  979,  979,
 /*  1690 */  1164,  273, 1273,  979,  979, 1274,  979, 1276, 1272,  244,
 /*  1700 */   979, 1277,   44,  153,  158, 1270,  979,  979,  979, 1164,
 /*  1710 */   259, 1273,  979,  979, 1274,  979, 1276, 1272,  979,  979,
 /*  1720 */  1277,   44,  153,  158,  979,  244, 1270,  979,  979,  979,
 /*  1730 */  1164,  260, 1273,  979,  979, 1274,  979, 1276, 1272,  979,
 /*  1740 */   979, 1277,   44,  153,  158,  244,  979,  979, 1270,  979,
 /*  1750 */   979,  979, 1164,  274, 1273,  979,  979, 1274,  979, 1276,
 /*  1760 */  1272,  979,  979, 1277,   44,  153,  158,  979,  244,  979,
 /*  1770 */   979,  979,  979,  979, 1270,  979,  979,  979, 1164,  275,
 /*  1780 */  1273,  979,  979, 1274,  979, 1276, 1272,  244,  979, 1277,
 /*  1790 */    44,  153,  158,  979, 1270,  979,  979,  979, 1164,  262,
 /*  1800 */  1273,  979,  979, 1274,  979, 1276, 1272,  979,  244, 1277,
 /*  1810 */    44,  153,  158,  979,  979,  979,  979, 1270,  979,  979,
 /*  1820 */   979, 1164,  263, 1273,  979,  979, 1274,  979, 1276, 1272,
 /*  1830 */   244,  979, 1277,   44,  153,  158, 1270,  979,  979,  979,
 /*  1840 */  1164,  264, 1273,  979,  979, 1274,  979, 1276, 1272,  979,
 /*  1850 */   979, 1277,   44,  153,  158,  979,  244, 1270,  979,  979,
 /*  1860 */   979, 1164,  277, 1273,  979,  979, 1274,  979, 1276, 1272,
 /*  1870 */   979,  979, 1277,   44,  153,  158,  244,  979,  979, 1270,
 /*  1880 */   979,  979,  979, 1164,  287, 1273,  979,  979, 1274,  979,
 /*  1890 */  1276, 1272,  979,  979, 1277,   44,  153,  158,  979,  244,
 /*  1900 */   979,  979,  979,  979,  979, 1270,  979,  979,  979, 1164,
 /*  1910 */   288, 1273,  979,  979, 1274,  979, 1276, 1272,  244,  979,
 /*  1920 */  1277,   44,  153,  158,  979, 1270,  979,  979,  979, 1164,
 /*  1930 */   289, 1273,  979,  979, 1274,  979, 1276, 1272,  979,  244,
 /*  1940 */  1277,   44,  153,  158,  979,  979,  979,  979, 1270,  979,
 /*  1950 */   979,  979, 1164,  290, 1273,  979,  979, 1274,  979, 1276,
 /*  1960 */  1272,  244,  979, 1277,   44,  153,  158, 1270,  979,  979,
 /*  1970 */   979, 1164,  291, 1273,  979,  979, 1274,  979, 1276, 1272,
 /*  1980 */   979,  979, 1277,   44,  153,  158,  979,  244, 1270,  979,
 /*  1990 */   979,  979, 1164,  292, 1273,  979,  979, 1274,  979, 1276,
 /*  2000 */  1272,  979,  979, 1277,   44,  153,  158,  244,  979,  979,
 /*  2010 */  1270,  979,  979,  979, 1164,  293, 1273,  979,  979, 1274,
 /*  2020 */   979, 1276, 1272,  979,  979, 1277,   44,  153,  158,  979,
 /*  2030 */   244,  979,  979,  979,  979,  979, 1270,  979,  979,  979,
 /*  2040 */  1164,  294, 1273,  979,  979, 1274,  979, 1276, 1272,  244,
 /*  2050 */   979, 1277,   44,  153,  158,  979, 1270,  979,  979,  979,
 /*  2060 */  1164,  295, 1273,  979,  979, 1274,  979, 1276, 1272,  979,
 /*  2070 */   244, 1277,   44,  153,  158,  979,  979,  979,  979, 1270,
 /*  2080 */   979,  979,  979, 1164,  296, 1273,  979,  979, 1274,  979,
 /*  2090 */  1276, 1272,  244,  979, 1277,   44,  153,  158, 1270,  979,
 /*  2100 */   979,  979, 1164,  397, 1273,  979,  979, 1274,  979, 1276,
 /*  2110 */  1272,  979,  979, 1277,   44,  153,  158,  979,  244, 1270,
 /*  2120 */   979,  979,  979, 1164,  398, 1273,  979,  979, 1274,  979,
 /*  2130 */  1276, 1272,  979,  979, 1277,   44,  153,  158,  244,  979,
 /*  2140 */   979, 1270,  979,  979,  979, 1164,  265, 1273,  979,  979,
 /*  2150 */  1274,  979, 1276, 1272,  979,  979, 1277,   44,  153,  158,
 /*  2160 */   979,  244,  979,  979,  979,  979,  979, 1270,  979,  979,
 /*  2170 */   979, 1164,  266, 1273,  979,  979, 1274,  979, 1276, 1272,
 /*  2180 */   244,  979, 1277,   44,  153,  158,  979, 1270,  979,  979,
 /*  2190 */   979, 1164, 1066, 1273,  979,  979, 1274,  979, 1276, 1272,
 /*  2200 */   979,  244, 1277,   44,  153,  158,  979,  979,  979,  979,
 /*  2210 */  1270,  979,  979,  979, 1164,  261, 1273,  979,  979, 1274,
 /*  2220 */   979, 1276, 1272,  244,  979, 1277,   44,  153,  158, 1270,
 /*  2230 */   979,  979,  979, 1164,  979, 1273,  979,  979, 1274,  979,
 /*  2240 */  1276, 1272,  979,  979, 1277,   44,  281,  158,  979,  244,
 /*  2250 */  1270,  979,  979,  979, 1164,  979, 1273,  979,  979, 1274,
 /*  2260 */   979, 1276, 1272,  979,  979, 1277,   44,  280,  158,  244,
 /*  2270 */   979,  979, 1270,  979,  979,  979, 1164,  979, 1273,  979,
 /*  2280 */   979, 1274,  979, 1276, 1272,  979,  979, 1277,   44,  152,
 /*  2290 */   158,  979,  244,  979,  979,  979,  979,  979, 1270,  979,
 /*  2300 */   979,  979, 1164,  979, 1273,  979,  979, 1274,  979, 1276,
 /*  2310 */  1272,  244,  979, 1277,   44,  145,  158,  979, 1270,  979,
 /*  2320 */   979,  979, 1164,  979, 1273,  979,  979, 1274,  979, 1276,
 /*  2330 */  1272,  979,  244, 1277,   44,  146,  158,  979,  979,  979,
 /*  2340 */   979, 1270,  979,  979,  979, 1164,  979, 1273,  979,  979,
 /*  2350 */  1274,  979, 1276, 1272,  244,  979, 1277,   44,  282,  158,
 /*  2360 */  1270,  979,  979,  979, 1164,  979, 1273,  979,  979, 1274,
 /*  2370 */   979, 1276, 1272,  979,  979, 1277,   44,  283,  158,  979,
 /*  2380 */   244, 1270,  979,  979,  979, 1164,  979, 1273,  979,  979,
 /*  2390 */  1274,  979, 1276, 1272,  979,  979, 1277,   44,  389,  158,
 /*  2400 */   244,  979,  979, 1270,  979,  979,  979, 1164,  979, 1273,
 /*  2410 */   979,  979, 1274,  979, 1276, 1272,  979,  979, 1277,   44,
 /*  2420 */   390,  158,  979,  244,  979,  979,  979,  979,  979, 1270,
 /*  2430 */   979,  979,  979, 1164,  979, 1273,  979,  979, 1274,  979,
 /*  2440 */  1276, 1272,  244,  979, 1277,   44,  391,  158,  979, 1270,
 /*  2450 */   979,  979,  979, 1164,  979, 1273,  979,  979, 1274,  979,
 /*  2460 */  1276, 1272,  979,  244, 1277,   44,  392,  158,  979,  979,
 /*  2470 */   979,  979, 1270,  979,  979,  979, 1164,  979, 1273,  979,
 /*  2480 */   979, 1274,  979, 1276, 1272,  244,  979, 1277,   44,  393,
 /*  2490 */   158, 1270,  979,  979,  979, 1164,  979, 1273,  979,  979,
 /*  2500 */  1274,  979, 1276, 1272,  979,  979, 1277,   44,  394,  158,
 /*  2510 */   979,  244, 1270,  979,  979,  979, 1164,  979, 1273,  979,
 /*  2520 */   979, 1274,  979, 1276, 1272,  979,  979, 1277,   44,  279,
 /*  2530 */   158,  244,  979,  979, 1270,  979,  979,  979, 1164,  979,
 /*  2540 */  1273,  979,  979, 1274,  979, 1276, 1272,  979,  979, 1277,
 /*  2550 */    44,  979,  157,  979,  244,  979,  979,  979, 1227, 1008,
 /*  2560 */   979,  979, 1007,  979,  979, 1006,  996,  997,  979,  998,
 /*  2570 */   999, 1156, 1008,  244,  979, 1007,  979,  979, 1006,  996,
 /*  2580 */   997,  979,  998,  999,  979,  979,  979,  979, 1011, 1008,
 /*  2590 */   979,  979, 1007,  979,  244, 1006,  996,  997,  979,  998,
 /*  2600 */   999, 1002, 1008,  979,  979, 1007,  979,  979, 1006,  996,
 /*  2610 */   997,  979,  998,  999,  236, 1008,  244,  979, 1007,  979,
 /*  2620 */   979, 1006,  996,  997,  979,  998,  999,
};
static const YYCODETYPE yy_lookahead[] = {
 /*     0 */   122,  123,  211,  156,  126,  256,  257,  186,  130,  131,
 /*    10 */   132,   11,   12,  135,  223,  137,  138,  174,  175,  141,
 /*    20 */   142,  143,  144,   23,  186,  135,   26,   27,  211,  212,
 /*    30 */   213,  214,  126,  216,   34,  145,  130,  220,  132,  161,
 /*    40 */   166,  135,  168,  137,  138,  134,   34,  141,  142,   49,
 /*    50 */   144,   51,   15,   16,   17,   18,   56,   57,   21,   22,
 /*    60 */   264,   11,   12,  135,  190,   65,  176,  234,  272,  240,
 /*    70 */    70,  238,    0,   23,   74,   27,   26,   27,   58,   29,
 /*    80 */    80,  252,   34,  236,   34,  139,  208,   87,   88,   89,
 /*    90 */    90,   91,  259,  260,  261,  262,  263,  207,  240,   49,
 /*   100 */   100,  135,  273,   83,  193,   85,   56,   57,  250,  251,
 /*   110 */   252,   11,   12,   65,  208,   65,  211,  212,  213,  214,
 /*   120 */    70,  216,   74,   23,   74,  220,   26,   27,   28,  128,
 /*   130 */    80,  273,   34,  135,   34,  207,   67,   87,   88,   89,
 /*   140 */    90,   91,   94,  211,  212,  213,  214,   62,  216,   49,
 /*   150 */   100,   79,  220,   34,   69,   79,   56,   57,   60,  128,
 /*   160 */   270,   11,   12,   65,   79,   65,  211,  212,  213,  214,
 /*   170 */    70,  216,  128,   23,   74,  220,   26,   27,  177,  178,
 /*   180 */    80,  109,  236,   98,   34,  109,  185,   87,   88,   89,
 /*   190 */    90,   91,  107,  192,  135,   24,   25,   26,  270,   49,
 /*   200 */   100,   34,  117,  135,  145,  207,   56,   57,  242,  243,
 /*   210 */    39,   11,   12,   34,   39,   65,  211,  212,  213,  214,
 /*   220 */    70,  216,  178,   23,   74,  220,   26,   27,  119,  185,
 /*   230 */    80,  128,   65,   34,   34,  170,  192,   87,   88,   89,
 /*   240 */    90,   91,  135,   58,   65,  135,  128,   62,  166,   49,
 /*   250 */   100,  127,  145,   74,   69,  145,   56,   57,  227,  135,
 /*   260 */   113,  114,  115,  127,   65,   65,  207,  127,  270,  133,
 /*   270 */    70,  135,  190,   27,   74,  135,  211,   92,   34,   34,
 /*   280 */    80,  163,  164,   98,   40,  182,  111,   87,   88,   89,
 /*   290 */    90,   91,   24,   25,   26,   34,  172,  210,  211,  181,
 /*   300 */   100,  214,  117,   66,  217,  218,  219,   34,  221,  222,
 /*   310 */   242,  243,  172,  184,  207,  128,   72,  207,  194,  195,
 /*   320 */   196,  197,  198,  199,  200,  201,  202,  203,  204,  270,
 /*   330 */   173,  228,   95,  209,  194,  195,  196,  197,  198,  199,
 /*   340 */   200,  201,  202,  203,  204,  128,  275,  276,  127,  209,
 /*   350 */   211,  212,  213,  214,  135,  216,  135,  111,  229,  220,
 /*   360 */   236,  167,  205,  206,  145,  127,  211,  212,  213,  214,
 /*   370 */    34,  216,  185,  135,   27,  220,  236,  270,  236,  192,
 /*   380 */   270,  120,  125,  126,   24,   25,   26,  130,  131,  132,
 /*   390 */   170,  128,  135,  172,  137,  138,  179,  128,  141,  142,
 /*   400 */   143,  144,  211,  212,  213,  214,  129,  216,  174,  175,
 /*   410 */   172,  220,  159,  160,  157,  194,  195,  196,  197,  198,
 /*   420 */   199,  200,  201,  202,  203,  204,  207,  169,  236,  169,
 /*   430 */   209,  211,  194,  195,  196,  197,  198,  199,  200,  201,
 /*   440 */   202,  203,  204,   29,  227,   31,  127,  209,  254,   19,
 /*   450 */    20,  236,  210,  211,  135,  192,  214,  236,   28,  217,
 /*   460 */   218,  219,  127,  221,  222,  208,  211,  212,  213,  214,
 /*   470 */   135,  216,   34,  265,  236,  220,   38,  124,   40,   41,
 /*   480 */    42,   43,   44,   45,   46,   47,   13,   14,  236,  270,
 /*   490 */   147,  172,   19,  148,  149,  150,  151,  228,  153,   28,
 /*   500 */   225,   63,  193,  211,  212,  213,  214,  172,  216,   71,
 /*   510 */    72,  158,  220,  194,  195,  196,  197,  198,  199,  200,
 /*   520 */   201,  202,  203,  204,  266,  267,  266,  267,  209,  194,
 /*   530 */   195,  196,  197,  198,  199,  200,  201,  202,  203,  204,
 /*   540 */    27,  126,   26,  127,  209,  130,  131,  132,  110,   33,
 /*   550 */   135,  135,  137,  138,  193,  236,  141,  142,  143,  144,
 /*   560 */   127,  211,  212,  213,  214,   26,  216,  236,  135,   26,
 /*   570 */   220,  236,   33,   26,  148,  149,   33,  162,  233,  153,
 /*   580 */    33,  155,  111,  187,  239,  240,  241,   26,  172,  244,
 /*   590 */   245,  246,  247,  248,   33,   31,   11,   12,  255,  226,
 /*   600 */    15,   16,   17,   18,  226,  172,   21,   22,   30,   31,
 /*   610 */   194,  195,  196,  197,  198,  199,  200,  201,  202,  203,
 /*   620 */   204,  226,  277,  208,  111,  209,  187,  194,  195,  196,
 /*   630 */   197,  198,  199,  200,  201,  202,  203,  204,   19,   20,
 /*   640 */   236,  127,  209,   26,   26,  230,  226,   28,  128,  135,
 /*   650 */    33,   33,  236,   19,   20,  226,   26,  231,  232,  233,
 /*   660 */   234,  235,   28,   33,   28,   28,  226,   31,   31,  236,
 /*   670 */   244,  245,  246,  247,  248,  111,   26,  148,  149,   77,
 /*   680 */    78,   27,  153,   33,  155,  236,  172,  210,  211,   28,
 /*   690 */    28,  214,   31,   31,  217,  218,  219,  236,  221,  222,
 /*   700 */   148,  149,  226,  277,  226,  153,  226,  155,  194,  195,
 /*   710 */   196,  197,  198,  199,  200,  201,  202,  203,  204,  187,
 /*   720 */     1,    2,    3,  209,    5,    6,    7,    8,  236,   10,
 /*   730 */    11,   12,   30,   31,   15,   16,   17,   18,  111,   30,
 /*   740 */    21,   22,   33,  127,   30,   31,   19,   20,   11,   12,
 /*   750 */   236,  135,   15,   16,   17,   18,   30,   31,   21,   22,
 /*   760 */   231,  232,  233,  234,  235,  111,   29,   30,   28,   28,
 /*   770 */   127,   31,   31,  244,  245,  246,  247,  248,  135,   27,
 /*   780 */   236,  236,   30,  231,  232,  233,  234,  235,  258,   28,
 /*   790 */   148,  149,   31,   27,  236,  153,  244,  245,  246,  247,
 /*   800 */   248,  236,  256,  236,  236,  229,  277,  258,  236,  174,
 /*   810 */   194,  195,  196,  197,  198,  199,  200,  201,  202,  203,
 /*   820 */   204,  169,  236,  210,  211,  209,  236,  214,   27,  277,
 /*   830 */   217,  218,  219,  236,  221,  222,  171,  194,  195,  196,
 /*   840 */   197,  198,  199,  200,  201,  202,  203,  204,  236,  167,
 /*   850 */    34,  271,  209,   32,   95,   34,  236,  236,  236,   38,
 /*   860 */   236,   40,   41,   42,   43,   44,   45,   46,   47,  191,
 /*   870 */   191,   34,  169,  231,  232,  233,  234,  235,  253,  146,
 /*   880 */   236,  236,  236,  236,  236,  118,  244,  245,  246,  247,
 /*   890 */   248,  236,   71,   72,   73,    1,    2,    3,    4,    5,
 /*   900 */     6,    7,    8,    9,   10,  236,  236,   13,   14,  146,
 /*   910 */   120,  147,  236,   19,   66,  211,  236,  236,  113,  277,
 /*   920 */   236,    1,    2,    3,    4,    5,    6,    7,    8,    9,
 /*   930 */    10,  236,  236,   13,   14,  236,  236,  236,  173,   19,
 /*   940 */   189,    1,    2,    3,    4,    5,    6,    7,    8,    9,
 /*   950 */    10,  236,   95,   13,   14,  211,   11,   12,  211,   19,
 /*   960 */    15,   16,   17,   18,  211,  211,   21,   22,   48,  183,
 /*   970 */     1,    2,    3,    4,    5,    6,    7,    8,    9,   10,
 /*   980 */   180,   86,   13,   14,  236,   39,  136,  191,   19,  211,
 /*   990 */   212,  213,  214,  191,  216,   50,   96,   28,  220,  188,
 /*  1000 */    27,  140,  188,  140,  140,  111,   27,    1,    2,    3,
 /*  1010 */     4,    5,    6,    7,    8,    9,   10,  140,  156,   13,
 /*  1020 */    14,   81,   26,  226,  236,   19,  152,    1,    2,    3,
 /*  1030 */     4,    5,    6,    7,    8,    9,   10,  238,  154,   13,
 /*  1040 */    14,  269,  236,   34,  268,   19,  237,   38,   34,   40,
 /*  1050 */    41,   42,   43,   44,   45,   46,   47,  108,   34,   33,
 /*  1060 */    84,    1,    2,    3,    4,    5,    6,    7,    8,    9,
 /*  1070 */    10,   34,   82,   13,   14,   34,   84,   27,   36,   19,
 /*  1080 */    71,   72,   76,   34,  106,   68,    1,   33,   27,   29,
 /*  1090 */   116,    1,    2,    3,    4,    5,    6,    7,    8,    9,
 /*  1100 */    10,   97,   30,   13,   14,   93,   30,   34,  211,   19,
 /*  1110 */    33,  214,  215,   34,  217,  218,  219,   33,  221,  222,
 /*  1120 */    30,  224,    1,    2,    3,    4,    5,    6,    7,    8,
 /*  1130 */     9,   10,   33,   33,   13,   14,   33,   11,   12,   34,
 /*  1140 */    19,   15,   16,   17,   18,   59,  249,   21,   22,   28,
 /*  1150 */    39,    1,    2,    3,    4,    5,    6,    7,    8,    9,
 /*  1160 */    10,  126,   30,   13,   14,  130,  111,  132,   34,   19,
 /*  1170 */   135,  274,  137,  138,   30,   49,  141,  142,   28,  144,
 /*  1180 */     1,    2,    3,    4,    5,    6,    7,    8,    9,   10,
 /*  1190 */    53,  104,   13,   14,   39,  104,   77,   55,   19,   37,
 /*  1200 */     1,    2,    3,    4,    5,    6,    7,    8,    9,   10,
 /*  1210 */    36,   34,   13,   14,   34,   27,   27,  115,   19,  211,
 /*  1220 */   212,  213,  214,   33,  216,   27,   33,   28,  220,    1,
 /*  1230 */     2,    3,    4,    5,    6,    7,    8,    9,   10,   34,
 /*  1240 */    35,   13,   14,  208,   27,   33,   61,   19,   34,  126,
 /*  1250 */    30,   36,   33,  130,  131,  132,   33,   52,  135,   54,
 /*  1260 */   137,  138,   30,   34,  141,  142,  143,  144,   24,   64,
 /*  1270 */    65,   34,   25,   66,   33,   33,   95,  101,   50,   74,
 /*  1280 */    75,  102,   30,    1,    2,    3,    4,    5,    6,    7,
 /*  1290 */     8,    9,   10,   30,   34,   13,   14,   27,   27,   22,
 /*  1300 */    34,   19,   34,   19,   99,   33,   33,   80,  103,  126,
 /*  1310 */   105,   30,   30,  130,  131,  132,  111,  112,  135,  278,
 /*  1320 */   137,  138,  278,  278,  141,  142,  143,  144,  125,  126,
 /*  1330 */   278,  208,  278,  130,  131,  132,  278,  278,  135,  278,
 /*  1340 */   137,  138,  278,  278,  141,  142,  143,  144,  165,  278,
 /*  1350 */   278,  278,  278,  230,  278,    1,    2,    3,    4,    5,
 /*  1360 */     6,    7,    8,    9,   10,  278,  278,   13,   14,   34,
 /*  1370 */    35,  278,  278,   19,   11,   12,  278,  278,   15,   16,
 /*  1380 */    17,   18,  278,  278,   21,   22,  278,   52,  278,   54,
 /*  1390 */   278,  208,   29,  278,  210,  211,  278,  278,  214,   64,
 /*  1400 */    65,  217,  218,  219,  278,  221,  222,  278,  278,   74,
 /*  1410 */    75,  208,  126,  278,  278,  278,  130,  131,  132,  278,
 /*  1420 */   278,  135,  278,  137,  138,  278,  278,  141,  142,  143,
 /*  1430 */   144,  278,  278,  278,   99,  278,  278,  126,  103,  278,
 /*  1440 */   105,  130,  131,  132,  278,  278,  135,  112,  137,  138,
 /*  1450 */   278,  278,  141,  142,  143,  144,  126,  278,  278,  278,
 /*  1460 */   130,  131,  132,  278,  278,  135,  278,  137,  138,  278,
 /*  1470 */   278,  141,  142,  143,  144,  126,  278,  278,  278,  130,
 /*  1480 */   131,  132,  278,  278,  135,  278,  137,  138,  278,  278,
 /*  1490 */   141,  142,  143,  144,  208,  126,  278,  278,  278,  130,
 /*  1500 */   131,  132,  278,  278,  135,  278,  137,  138,  278,  278,
 /*  1510 */   141,  142,  143,  144,  278,  278,  126,  278,  278,  208,
 /*  1520 */   130,  131,  132,  278,  278,  135,  278,  137,  138,  278,
 /*  1530 */   278,  141,  142,  143,  144,  278,  126,  278,  208,  278,
 /*  1540 */   130,  131,  132,  278,  278,  135,  278,  137,  138,  278,
 /*  1550 */   278,  141,  142,  143,  144,  126,  278,  208,  278,  130,
 /*  1560 */   131,  132,  278,  278,  135,  278,  137,  138,  278,  278,
 /*  1570 */   141,  142,  143,  144,  126,  278,  278,  208,  130,  131,
 /*  1580 */   132,  278,  278,  135,  278,  137,  138,  278,  278,  141,
 /*  1590 */   142,  143,  144,  278,  278,  126,  278,  278,  208,  130,
 /*  1600 */   131,  132,  278,  278,  135,  278,  137,  138,  278,  278,
 /*  1610 */   141,  142,  143,  144,  278,  278,  278,  126,  208,  278,
 /*  1620 */   278,  130,  131,  132,  278,  278,  135,  278,  137,  138,
 /*  1630 */   278,  278,  141,  142,  143,  144,  278,  208,  278,  278,
 /*  1640 */   278,  278,  278,  126,  278,  278,  278,  130,  131,  132,
 /*  1650 */   278,  278,  135,  278,  137,  138,  208,  278,  141,  142,
 /*  1660 */   143,  144,  278,  126,  278,  278,  278,  130,  131,  132,
 /*  1670 */   278,  278,  135,  278,  137,  138,  278,  208,  141,  142,
 /*  1680 */   143,  144,  278,  278,  278,  278,  126,  278,  278,  278,
 /*  1690 */   130,  131,  132,  278,  278,  135,  278,  137,  138,  208,
 /*  1700 */   278,  141,  142,  143,  144,  126,  278,  278,  278,  130,
 /*  1710 */   131,  132,  278,  278,  135,  278,  137,  138,  278,  278,
 /*  1720 */   141,  142,  143,  144,  278,  208,  126,  278,  278,  278,
 /*  1730 */   130,  131,  132,  278,  278,  135,  278,  137,  138,  278,
 /*  1740 */   278,  141,  142,  143,  144,  208,  278,  278,  126,  278,
 /*  1750 */   278,  278,  130,  131,  132,  278,  278,  135,  278,  137,
 /*  1760 */   138,  278,  278,  141,  142,  143,  144,  278,  208,  278,
 /*  1770 */   278,  278,  278,  278,  126,  278,  278,  278,  130,  131,
 /*  1780 */   132,  278,  278,  135,  278,  137,  138,  208,  278,  141,
 /*  1790 */   142,  143,  144,  278,  126,  278,  278,  278,  130,  131,
 /*  1800 */   132,  278,  278,  135,  278,  137,  138,  278,  208,  141,
 /*  1810 */   142,  143,  144,  278,  278,  278,  278,  126,  278,  278,
 /*  1820 */   278,  130,  131,  132,  278,  278,  135,  278,  137,  138,
 /*  1830 */   208,  278,  141,  142,  143,  144,  126,  278,  278,  278,
 /*  1840 */   130,  131,  132,  278,  278,  135,  278,  137,  138,  278,
 /*  1850 */   278,  141,  142,  143,  144,  278,  208,  126,  278,  278,
 /*  1860 */   278,  130,  131,  132,  278,  278,  135,  278,  137,  138,
 /*  1870 */   278,  278,  141,  142,  143,  144,  208,  278,  278,  126,
 /*  1880 */   278,  278,  278,  130,  131,  132,  278,  278,  135,  278,
 /*  1890 */   137,  138,  278,  278,  141,  142,  143,  144,  278,  208,
 /*  1900 */   278,  278,  278,  278,  278,  126,  278,  278,  278,  130,
 /*  1910 */   131,  132,  278,  278,  135,  278,  137,  138,  208,  278,
 /*  1920 */   141,  142,  143,  144,  278,  126,  278,  278,  278,  130,
 /*  1930 */   131,  132,  278,  278,  135,  278,  137,  138,  278,  208,
 /*  1940 */   141,  142,  143,  144,  278,  278,  278,  278,  126,  278,
 /*  1950 */   278,  278,  130,  131,  132,  278,  278,  135,  278,  137,
 /*  1960 */   138,  208,  278,  141,  142,  143,  144,  126,  278,  278,
 /*  1970 */   278,  130,  131,  132,  278,  278,  135,  278,  137,  138,
 /*  1980 */   278,  278,  141,  142,  143,  144,  278,  208,  126,  278,
 /*  1990 */   278,  278,  130,  131,  132,  278,  278,  135,  278,  137,
 /*  2000 */   138,  278,  278,  141,  142,  143,  144,  208,  278,  278,
 /*  2010 */   126,  278,  278,  278,  130,  131,  132,  278,  278,  135,
 /*  2020 */   278,  137,  138,  278,  278,  141,  142,  143,  144,  278,
 /*  2030 */   208,  278,  278,  278,  278,  278,  126,  278,  278,  278,
 /*  2040 */   130,  131,  132,  278,  278,  135,  278,  137,  138,  208,
 /*  2050 */   278,  141,  142,  143,  144,  278,  126,  278,  278,  278,
 /*  2060 */   130,  131,  132,  278,  278,  135,  278,  137,  138,  278,
 /*  2070 */   208,  141,  142,  143,  144,  278,  278,  278,  278,  126,
 /*  2080 */   278,  278,  278,  130,  131,  132,  278,  278,  135,  278,
 /*  2090 */   137,  138,  208,  278,  141,  142,  143,  144,  126,  278,
 /*  2100 */   278,  278,  130,  131,  132,  278,  278,  135,  278,  137,
 /*  2110 */   138,  278,  278,  141,  142,  143,  144,  278,  208,  126,
 /*  2120 */   278,  278,  278,  130,  131,  132,  278,  278,  135,  278,
 /*  2130 */   137,  138,  278,  278,  141,  142,  143,  144,  208,  278,
 /*  2140 */   278,  126,  278,  278,  278,  130,  131,  132,  278,  278,
 /*  2150 */   135,  278,  137,  138,  278,  278,  141,  142,  143,  144,
 /*  2160 */   278,  208,  278,  278,  278,  278,  278,  126,  278,  278,
 /*  2170 */   278,  130,  131,  132,  278,  278,  135,  278,  137,  138,
 /*  2180 */   208,  278,  141,  142,  143,  144,  278,  126,  278,  278,
 /*  2190 */   278,  130,  131,  132,  278,  278,  135,  278,  137,  138,
 /*  2200 */   278,  208,  141,  142,  143,  144,  278,  278,  278,  278,
 /*  2210 */   126,  278,  278,  278,  130,  131,  132,  278,  278,  135,
 /*  2220 */   278,  137,  138,  208,  278,  141,  142,  143,  144,  126,
 /*  2230 */   278,  278,  278,  130,  278,  132,  278,  278,  135,  278,
 /*  2240 */   137,  138,  278,  278,  141,  142,  143,  144,  278,  208,
 /*  2250 */   126,  278,  278,  278,  130,  278,  132,  278,  278,  135,
 /*  2260 */   278,  137,  138,  278,  278,  141,  142,  143,  144,  208,
 /*  2270 */   278,  278,  126,  278,  278,  278,  130,  278,  132,  278,
 /*  2280 */   278,  135,  278,  137,  138,  278,  278,  141,  142,  143,
 /*  2290 */   144,  278,  208,  278,  278,  278,  278,  278,  126,  278,
 /*  2300 */   278,  278,  130,  278,  132,  278,  278,  135,  278,  137,
 /*  2310 */   138,  208,  278,  141,  142,  143,  144,  278,  126,  278,
 /*  2320 */   278,  278,  130,  278,  132,  278,  278,  135,  278,  137,
 /*  2330 */   138,  278,  208,  141,  142,  143,  144,  278,  278,  278,
 /*  2340 */   278,  126,  278,  278,  278,  130,  278,  132,  278,  278,
 /*  2350 */   135,  278,  137,  138,  208,  278,  141,  142,  143,  144,
 /*  2360 */   126,  278,  278,  278,  130,  278,  132,  278,  278,  135,
 /*  2370 */   278,  137,  138,  278,  278,  141,  142,  143,  144,  278,
 /*  2380 */   208,  126,  278,  278,  278,  130,  278,  132,  278,  278,
 /*  2390 */   135,  278,  137,  138,  278,  278,  141,  142,  143,  144,
 /*  2400 */   208,  278,  278,  126,  278,  278,  278,  130,  278,  132,
 /*  2410 */   278,  278,  135,  278,  137,  138,  278,  278,  141,  142,
 /*  2420 */   143,  144,  278,  208,  278,  278,  278,  278,  278,  126,
 /*  2430 */   278,  278,  278,  130,  278,  132,  278,  278,  135,  278,
 /*  2440 */   137,  138,  208,  278,  141,  142,  143,  144,  278,  126,
 /*  2450 */   278,  278,  278,  130,  278,  132,  278,  278,  135,  278,
 /*  2460 */   137,  138,  278,  208,  141,  142,  143,  144,  278,  278,
 /*  2470 */   278,  278,  126,  278,  278,  278,  130,  278,  132,  278,
 /*  2480 */   278,  135,  278,  137,  138,  208,  278,  141,  142,  143,
 /*  2490 */   144,  126,  278,  278,  278,  130,  278,  132,  278,  278,
 /*  2500 */   135,  278,  137,  138,  278,  278,  141,  142,  143,  144,
 /*  2510 */   278,  208,  126,  278,  278,  278,  130,  278,  132,  278,
 /*  2520 */   278,  135,  278,  137,  138,  278,  278,  141,  142,  143,
 /*  2530 */   144,  208,  278,  278,  126,  278,  278,  278,  130,  278,
 /*  2540 */   132,  278,  278,  135,  278,  137,  138,  278,  278,  141,
 /*  2550 */   142,  278,  144,  278,  208,  278,  278,  278,  210,  211,
 /*  2560 */   278,  278,  214,  278,  278,  217,  218,  219,  278,  221,
 /*  2570 */   222,  210,  211,  208,  278,  214,  278,  278,  217,  218,
 /*  2580 */   219,  278,  221,  222,  278,  278,  278,  278,  210,  211,
 /*  2590 */   278,  278,  214,  278,  208,  217,  218,  219,  278,  221,
 /*  2600 */   222,  210,  211,  278,  278,  214,  278,  278,  217,  218,
 /*  2610 */   219,  278,  221,  222,  210,  211,  208,  278,  214,  278,
 /*  2620 */   278,  217,  218,  219,  278,  221,  222,  121,  121,  121,
 /*  2630 */   121,  121,  121,  121,  121,  121,  121,  121,  121,  121,
 /*  2640 */   121,  121,  121,  121,  121,  121,  121,  121,  121,  121,
 /*  2650 */   121,  121,  121,  121,  121,  121,  121,  121,  121,  121,
 /*  2660 */   121,  121,  121,  121,  121,  121,  121,  121,  121,  121,
 /*  2670 */   121,  121,  121,  121,  121,  121,  121,  121,  121,  121,
 /*  2680 */   121,  121,  121,  121,  121,  121,  121,  121,  121,  121,
 /*  2690 */   121,  121,  121,  121,  121,  121,  121,  121,  121,  121,
 /*  2700 */   121,  121,  121,  121,  121,  121,  121,  121,  121,  121,
 /*  2710 */   121,  121,  121,  121,  121,  121,  121,  121,  121,  121,
 /*  2720 */   121,  121,  121,  121,  121,  121,  121,  121,  121,  121,
 /*  2730 */   121,  121,  121,  121,  121,  121,  121,  121,  121,  121,
 /*  2740 */   121,  121,  121,  121,  121,  121,  121,  121,
};
#define YY_SHIFT_COUNT    (402)
#define YY_SHIFT_MIN      (0)
#define YY_SHIFT_MAX      (1363)
static const unsigned short int yy_shift_ofst[] = {
 /*     0 */    76, 1205, 1205, 1205, 1205, 1205, 1205, 1205, 1205, 1205,
 /*    10 */     0,   85,  185,  185,  185,   85,   50,  150, 1335, 1335,
 /*    20 */   185,  100,  150,  200,  200,  200,  200,  200,  200,  200,
 /*    30 */   200,  200,  200,  200,  200,  200,  200,  200,  200,  200,
 /*    40 */   200,  200,  200,  200,  200,  200,  200,  200,  200,  200,
 /*    50 */   200,  200,  200,  200,  200,  200,  200,  200,  200,  200,
 /*    60 */   200,  200,  200,  200,  200,  200,  200,  200,  200,  200,
 /*    70 */   200,  200,  200,  200,  200,  200,  438,  200,  200,  200,
 /*    80 */  1009, 1009, 1009, 1009, 1009, 1009, 1009, 1009, 1009, 1009,
 /*    90 */    20,  821,  821,  821,  821,  821,  821,  821,  821,  821,
 /*   100 */   821,  821,  821,  821,   48,  167,   48,   48,   48,   48,
 /*   110 */    98,  167,   48,   48,  179,  179,  179,  147,   72,  199,
 /*   120 */   199,  199,   12,   12,   69,  268,  244,  175,  261,  246,
 /*   130 */   199,  199,  199,  119,  245,  109,  273,  336,   69,  347,
 /*   140 */   273,  109, 2627, 2627, 2627,  719,  719,  894,  920,  894,
 /*   150 */   894,  894,  945, 1126,  171,  360,  360,  360,  360,  471,
 /*   160 */   237,  516,  539,  543,  237,  547,  513,  199,  561,  617,
 /*   170 */   564,  564,  618,  630,  650,  237,  627,  627,  627,  766,
 /*   180 */   627,  627,  119,  766,  627,  627,  245,  627,  109,  627,
 /*   190 */   627,   12,  801,  627,  627,  347,  816,  627,  627,  627,
 /*   200 */   627,  759,  759,   12,  837,  627,  627,  627,  627,  767,
 /*   210 */   627,  627,  627,  627,  767,  790,  627,  627,  627,  627,
 /*   220 */   627,  627,  627,  273,  805,  627,  627,  848,  627,  273,
 /*   230 */   273,  273,  273,  857,  895,  627,  946,  759,  759,  900,
 /*   240 */   973,  900,  973,  973,  979,  973,  996,  627,  627, 2627,
 /*   250 */  2627, 2627, 2627, 2627, 2627,  969,  940, 1006, 1026, 1060,
 /*   260 */  1090, 1121, 1150, 1179, 1199, 1228, 1282, 1354, 1354, 1354,
 /*   270 */  1354, 1354, 1354, 1354, 1354, 1354, 1354, 1354, 1354,  737,
 /*   280 */  1363,  585,   37,   37,  430,  619,  634,  473,  473,  473,
 /*   290 */   473,  473,  473,  473,  473,  473,  473,  636,  637,  661,
 /*   300 */   662,  578,  709,  702,  602,  654,  714,  727,  740,  727,
 /*   310 */   741,  726,  752,  761,  414, 1014,  949, 1024,  976, 1037,
 /*   320 */   990, 1041,  992, 1050, 1042, 1049,  978, 1017, 1085, 1061,
 /*   330 */  1054,  974, 1004, 1012, 1072, 1073, 1077, 1079, 1084, 1099,
 /*   340 */  1100, 1103, 1105, 1076, 1086, 1111, 1132, 1055, 1134, 1137,
 /*   350 */  1144, 1087, 1091, 1155, 1119, 1142, 1162, 1174, 1177, 1180,
 /*   360 */  1188, 1190, 1189, 1198, 1193, 1102, 1217, 1212, 1185, 1214,
 /*   370 */  1215, 1219, 1223, 1220, 1232, 1229, 1244, 1237, 1247, 1207,
 /*   380 */  1181, 1241, 1242, 1252, 1263, 1176, 1260, 1270, 1271, 1277,
 /*   390 */  1277, 1277, 1277, 1277, 1277, 1266, 1268, 1284, 1284, 1272,
 /*   400 */  1273, 1281, 1227,
};
#define YY_REDUCE_COUNT (254)
#define YY_REDUCE_MIN   (-251)
#define YY_REDUCE_MAX   (2408)
static const short yy_reduce_ofst[] = {
 /*     0 */  -142,  124,  140,  221,  238,  319,  335,  416,  433,  514,
 /*    10 */  -122,  345,  426,  529,  552,  345,  257,  415,  616,  643,
 /*    20 */   642, 1183, 1123, 1203, 1286, 1311, 1330, 1349, 1369, 1390,
 /*    30 */  1410, 1429, 1448, 1469, 1491, 1517, 1537, 1560, 1579, 1600,
 /*    40 */  1622, 1648, 1668, 1691, 1710, 1731, 1753, 1779, 1799, 1822,
 /*    50 */  1841, 1862, 1884, 1910, 1930, 1953, 1972, 1993, 2015, 2041,
 /*    60 */  2061, 2084, 2103, 2124, 2146, 2172, 2192, 2215, 2234, 2255,
 /*    70 */  2277, 2303, 2323, 2346, 2365, 2386,  897,  -94, 1035, 2408,
 /*    80 */    87,  242,  477,  613, 1184, 2348, 2361, 2378, 2391, 2404,
 /*    90 */  -167, -183,  -95,  -68,  -45,    5,  139,  155,  191,  255,
 /*   100 */   292,  350,  778, 1008, -110,    1,   59,  107,  110,  219,
 /*   110 */   118,   44,  -72,   -2,  -34,   68,  136,  157, -171,  217,
 /*   120 */   187,  103,  258,  260, -126,  -89, -209,  -54,  343, -153,
 /*   130 */    31,  263,  269, -251,  129, -157,   65,   71,   82,  194,
 /*   140 */   220,  234,  253,  353, -204, -179, -162,  142,  277,  192,
 /*   150 */   215,  252,  208,  275,  309,  361,  361,  361,  361,  331,
 /*   160 */   396,  373,  378,  395,  439,  420,  404,  520,  429,  440,
 /*   170 */   449,  461,  476,  478,  480,  532,  492,  544,  545,  530,
 /*   180 */   558,  565,  546,  549,  567,  568,  576,  572,  635,  586,
 /*   190 */   590,  652,  665,  597,  612,  682,  580,  620,  621,  622,
 /*   200 */   624,  678,  679,  703,  625,  644,  645,  646,  647,  733,
 /*   210 */   648,  655,  669,  670,  763,  764,  676,  680,  681,  684,
 /*   220 */   695,  696,  699,  704,  765,  700,  701,  751,  715,  744,
 /*   230 */   747,  753,  754,  786,  800,  748,  850,  796,  802,  811,
 /*   240 */   861,  814,  863,  864,  862,  877,  797,  788,  806,  799,
 /*   250 */   874,  884,  772,  776,  809,
};
static const YYACTIONTYPE yy_default[] = {
 /*     0 */   977, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240,
 /*    10 */  1033, 1221, 1303, 1303, 1303, 1220,  977,  977,  977,  977,
 /*    20 */  1303,  977, 1298,  977,  977,  977,  977,  977,  977,  977,
 /*    30 */   977,  977,  977,  977,  977,  977,  977,  977,  977,  977,
 /*    40 */   977,  977,  977,  977,  977,  977,  977,  977,  977,  977,
 /*    50 */   977,  977,  977,  977,  977,  977,  977,  977,  977,  977,
 /*    60 */   977,  977,  977,  977,  977,  977,  977,  977,  977,  977,
 /*    70 */   977,  977,  977,  977,  977,  977,  977,  977,  977,  977,
 /*    80 */   977,  977,  977,  977,  977,  977,  977,  977,  977,  977,
 /*    90 */  1304,  977,  977,  977,  977,  977,  977,  977,  977,  977,
 /*   100 */   977,  977,  977,  977,  977,  977,  977,  977,  977,  977,
 /*   110 */  1046, 1291,  977,  977, 1305, 1305,  977, 1243,  977,  977,
 /*   120 */   977,  977, 1309, 1309, 1091, 1269,  977,  977, 1301,  977,
 /*   130 */  1154,  977, 1047,  977,  977, 1299,  977,  977, 1091, 1094,
 /*   140 */   977, 1299, 1028, 1009, 1308,  977,  977,  977, 1024,  977,
 /*   150 */   977,  977,  977, 1065,  977, 1280, 1279, 1278, 1080,  977,
 /*   160 */  1176,  977,  977,  977, 1176,  977,  977,  977,  977,  977,
 /*   170 */   977,  977,  977,  977,  977, 1176,  977,  977,  977,  977,
 /*   180 */  1140,  977,  977,  977, 1137,  977,  977,  977,  977,  977,
 /*   190 */   977,  977,  977,  977,  977, 1094,  977,  977,  977,  977,
 /*   200 */   977, 1281, 1281,  977,  977,  977,  977,  977,  977, 1292,
 /*   210 */   977,  977,  977,  977, 1292, 1301,  977,  977,  977,  977,
 /*   220 */   977,  977,  977,  977, 1244,  977,  977, 1060,  977,  977,
 /*   230 */   977,  977,  977, 1290, 1153,  977,  977, 1281, 1281, 1181,
 /*   240 */  1183, 1181, 1183, 1183,  977, 1183,  977,  977,  977, 1304,
 /*   250 */  1219, 1190, 1170, 1169, 1001,  977,  977,  977,  977,  977,
 /*   260 */   977,  977,  977,  977,  977,  977,  977, 1165, 1031, 1032,
 /*   270 */  1302, 1293, 1025, 1130,  991,  993, 1089, 1090,  989,  977,
 /*   280 */   977, 1079, 1088, 1087,  977,  977,  977, 1078, 1077, 1076,
 /*   290 */  1075, 1074, 1073, 1072, 1071, 1070, 1069,  977,  977,  977,
 /*   300 */   977,  977,  977,  977,  977, 1125,  977, 1255,  977, 1254,
 /*   310 */   977,  977, 1125,  977,  977,  977,  977,  977,  977,  977,
 /*   320 */  1131,  977,  977,  977,  977,  977,  977,  977,  977,  977,
 /*   330 */   977,  977,  977,  977,  977,  977,  977,  977,  977,  977,
 /*   340 */   977,  977,  977, 1119,  977,  977,  977, 1195,  977,  977,
 /*   350 */   977,  977,  977,  977,  977,  977,  977,  977,  977,  977,
 /*   360 */   977,  977,  977,  977, 1248,  977,  977,  977,  977,  977,
 /*   370 */   977,  977,  977,  977, 1056,  977,  977,  977,  977, 1178,
 /*   380 */  1177,  977,  977,  990,  992,  977,  977,  977, 1125, 1086,
 /*   390 */  1085, 1084, 1083, 1082, 1081,  977,  977, 1068, 1067,  977,
 /*   400 */   977,  977,  977,
};
/********** End of lemon-generated parsing tables *****************************/

/* The next table maps tokens (terminal symbols) into fallback tokens.  
** If a construct like the following:
** 
**      %fallback ID X Y Z.
**
** appears in the grammar, then ID becomes a fallback token for X, Y,
** and Z.  Whenever one of the tokens X, Y, or Z is input to the parser
** but it does not parse, the type of the token is changed to ID and
** the parse is retried before an error is thrown.
**
** This feature can be used, for example, to cause some keywords in a language
** to revert to identifiers if they keyword does not apply in the context where
** it appears.
*/
#ifdef YYFALLBACK
static const YYCODETYPE yyFallback[] = {
};
#endif /* YYFALLBACK */

/* The following structure represents a single element of the
** parser's stack.  Information stored includes:
**
**   +  The state number for the parser at this level of the stack.
**
**   +  The value of the token stored at this level of the stack.
**      (In other words, the "major" token.)
**
**   +  The semantic value stored at this level of the stack.  This is
**      the information used by the action routines in the grammar.
**      It is sometimes called the "minor" token.
**
** After the "shift" half of a SHIFTREDUCE action, the stateno field
** actually contains the reduce action for the second half of the
** SHIFTREDUCE.
*/
struct yyStackEntry {
  YYACTIONTYPE stateno;  /* The state-number, or reduce action in SHIFTREDUCE */
  YYCODETYPE major;      /* The major token value.  This is the code
                         ** number for the token at this stack level */
  YYMINORTYPE minor;     /* The user-supplied minor token value.  This
                         ** is the value of the token  */
};
typedef struct yyStackEntry yyStackEntry;

/* The state of the parser is completely contained in an instance of
** the following structure */
struct yyParser {
  yyStackEntry *yytos;          /* Pointer to top element of the stack */
#ifdef YYTRACKMAXSTACKDEPTH
  int yyhwm;                    /* High-water mark of the stack */
#endif
#ifndef YYNOERRORRECOVERY
  int yyerrcnt;                 /* Shifts left before out of the error */
#endif
  ParseARG_SDECL                /* A place to hold %extra_argument */
  ParseCTX_SDECL                /* A place to hold %extra_context */
  yyStackEntry *yystackEnd;           /* Last entry in the stack */
  yyStackEntry *yystack;              /* The parser stack */
  yyStackEntry yystk0[YYSTACKDEPTH];  /* Initial stack space */
};
typedef struct yyParser yyParser;

#include <assert.h>
#ifndef NDEBUG
#include <stdio.h>
static FILE *yyTraceFILE = 0;
static char *yyTracePrompt = 0;
#endif /* NDEBUG */

#ifndef NDEBUG
/* 
** Turn parser tracing on by giving a stream to which to write the trace
** and a prompt to preface each trace message.  Tracing is turned off
** by making either argument NULL 
**
** Inputs:
** <ul>
** <li> A FILE* to which trace output should be written.
**      If NULL, then tracing is turned off.
** <li> A prefix string written at the beginning of every
**      line of trace output.  If NULL, then tracing is
**      turned off.
** </ul>
**
** Outputs:
** None.
*/
void ParseTrace(FILE *TraceFILE, char *zTracePrompt){
  yyTraceFILE = TraceFILE;
  yyTracePrompt = zTracePrompt;
  if( yyTraceFILE==0 ) yyTracePrompt = 0;
  else if( yyTracePrompt==0 ) yyTraceFILE = 0;
}
#endif /* NDEBUG */

#if defined(YYCOVERAGE) || !defined(NDEBUG)
/* For tracing shifts, the names of all terminals and nonterminals
** are required.  The following table supplies these names */
static const char *const yyTokenName[] = { 
  /*    0 */ "$",
  /*    1 */ "TOK_EQUAL",
  /*    2 */ "TOK_GREATER_EQUAL",
  /*    3 */ "TOK_GREATER_THAN",
  /*    4 */ "TOK_IN",
  /*    5 */ "TOK_INST_EQUAL",
  /*    6 */ "TOK_INST_NOT_EQUAL",
  /*    7 */ "TOK_LESS_EQUAL",
  /*    8 */ "TOK_LESS_THAN",
  /*    9 */ "TOK_LIKE",
  /*   10 */ "TOK_NOT_EQUAL",
  /*   11 */ "TOK_MINUS",
  /*   12 */ "TOK_PLUS",
  /*   13 */ "TOK_OR",
  /*   14 */ "TOK_XOR",
  /*   15 */ "TOK_DIV",
  /*   16 */ "TOK_MOD",
  /*   17 */ "TOK_REAL_DIV",
  /*   18 */ "TOK_TIMES",
  /*   19 */ "TOK_AND",
  /*   20 */ "TOK_ANDOR",
  /*   21 */ "TOK_CONCAT_OP",
  /*   22 */ "TOK_EXP",
  /*   23 */ "TOK_NOT",
  /*   24 */ "TOK_DOT",
  /*   25 */ "TOK_BACKSLASH",
  /*   26 */ "TOK_LEFT_BRACKET",
  /*   27 */ "TOK_LEFT_PAREN",
  /*   28 */ "TOK_RIGHT_PAREN",
  /*   29 */ "TOK_RIGHT_BRACKET",
  /*   30 */ "TOK_COLON",
  /*   31 */ "TOK_COMMA",
  /*   32 */ "TOK_AGGREGATE",
  /*   33 */ "TOK_OF",
  /*   34 */ "TOK_IDENTIFIER",
  /*   35 */ "TOK_ALIAS",
  /*   36 */ "TOK_FOR",
  /*   37 */ "TOK_END_ALIAS",
  /*   38 */ "TOK_ARRAY",
  /*   39 */ "TOK_ASSIGNMENT",
  /*   40 */ "TOK_BAG",
  /*   41 */ "TOK_BOOLEAN",
  /*   42 */ "TOK_INTEGER",
  /*   43 */ "TOK_REAL",
  /*   44 */ "TOK_NUMBER",
  /*   45 */ "TOK_LOGICAL",
  /*   46 */ "TOK_BINARY",
  /*   47 */ "TOK_STRING",
  /*   48 */ "TOK_BY",
  /*   49 */ "TOK_LEFT_CURL",
  /*   50 */ "TOK_RIGHT_CURL",
  /*   51 */ "TOK_OTHERWISE",
  /*   52 */ "TOK_CASE",
  /*   53 */ "TOK_END_CASE",
  /*   54 */ "TOK_BEGIN",
  /*   55 */ "TOK_END",
  /*   56 */ "TOK_PI",
  /*   57 */ "TOK_E",
  /*   58 */ "TOK_CONSTANT",
  /*   59 */ "TOK_END_CONSTANT",
  /*   60 */ "TOK_DERIVE",
  /*   61 */ "TOK_END_ENTITY",
  /*   62 */ "TOK_ENTITY",
  /*   63 */ "TOK_ENUMERATION",
  /*   64 */ "TOK_ESCAPE",
  /*   65 */ "TOK_SELF",
  /*   66 */ "TOK_OPTIONAL",
  /*   67 */ "TOK_VAR",
  /*   68 */ "TOK_END_FUNCTION",
  /*   69 */ "TOK_FUNCTION",
  /*   70 */ "TOK_BUILTIN_FUNCTION",
  /*   71 */ "TOK_LIST",
  /*   72 */ "TOK_SET",
  /*   73 */ "TOK_GENERIC",
  /*   74 */ "TOK_QUESTION_MARK",
  /*   75 */ "TOK_IF",
  /*   76 */ "TOK_THEN",
  /*   77 */ "TOK_END_IF",
  /*   78 */ "TOK_ELSE",
  /*   79 */ "TOK_INCLUDE",
  /*   80 */ "TOK_STRING_LITERAL",
  /*   81 */ "TOK_TO",
  /*   82 */ "TOK_AS",
  /*   83 */ "TOK_REFERENCE",
  /*   84 */ "TOK_FROM",
  /*   85 */ "TOK_USE",
  /*   86 */ "TOK_INVERSE",
  /*   87 */ "TOK_INTEGER_LITERAL",
  /*   88 */ "TOK_REAL_LITERAL",
  /*   89 */ "TOK_STRING_LITERAL_ENCODED",
  /*   90 */ "TOK_LOGICAL_LITERAL",
  /*   91 */ "TOK_BINARY_LITERAL",
  /*   92 */ "TOK_LOCAL",
  /*   93 */ "TOK_END_LOCAL",
  /*   94 */ "TOK_ONEOF",
  /*   95 */ "TOK_UNIQUE",
  /*   96 */ "TOK_FIXED",
  /*   97 */ "TOK_END_PROCEDURE",
  /*   98 */ "TOK_PROCEDURE",
  /*   99 */ "TOK_BUILTIN_PROCEDURE",
  /*  100 */ "TOK_QUERY",
  /*  101 */ "TOK_ALL_IN",
  /*  102 */ "TOK_SUCH_THAT",
  /*  103 */ "TOK_REPEAT",
  /*  104 */ "TOK_END_REPEAT",
  /*  105 */ "TOK_RETURN",
  /*  106 */ "TOK_END_RULE",
  /*  107 */ "TOK_RULE",
  /*  108 */ "TOK_END_SCHEMA",
  /*  109 */ "TOK_SCHEMA",
  /*  110 */ "TOK_SELECT",
  /*  111 */ "TOK_SEMICOLON",
  /*  112 */ "TOK_SKIP",
  /*  113 */ "TOK_SUBTYPE",
  /*  114 */ "TOK_ABSTRACT",
  /*  115 */ "TOK_SUPERTYPE",
  /*  116 */ "TOK_END_TYPE",
  /*  117 */ "TOK_TYPE",
  /*  118 */ "TOK_UNTIL",
  /*  119 */ "TOK_WHERE",
  /*  120 */ "TOK_WHILE",
  /*  121 */ "statement_list",
  /*  122 */ "case_action",
  /*  123 */ "case_otherwise",
  /*  124 */ "entity_body",
  /*  125 */ "aggregate_init_element",
  /*  126 */ "aggregate_initializer",
  /*  127 */ "assignable",
  /*  128 */ "attribute_decl",
  /*  129 */ "by_expression",
  /*  130 */ "constant",
  /*  131 */ "expression",
  /*  132 */ "function_call",
  /*  133 */ "general_ref",
  /*  134 */ "group_ref",
  /*  135 */ "identifier",
  /*  136 */ "initializer",
  /*  137 */ "interval",
  /*  138 */ "literal",
  /*  139 */ "local_initializer",
  /*  140 */ "precision_spec",
  /*  141 */ "query_expression",
  /*  142 */ "query_start",
  /*  143 */ "simple_expression",
  /*  144 */ "unary_expression",
  /*  145 */ "supertype_expression",
  /*  146 */ "until_control",
  /*  147 */ "while_control",
  /*  148 */ "function_header",
  /*  149 */ "fh_lineno",
  /*  150 */ "rule_header",
  /*  151 */ "rh_start",
  /*  152 */ "rh_get_line",
  /*  153 */ "procedure_header",
  /*  154 */ "ph_get_line",
  /*  155 */ "action_body",
  /*  156 */ "actual_parameters",
  /*  157 */ "aggregate_init_body",
  /*  158 */ "explicit_attr_list",
  /*  159 */ "case_action_list",
  /*  160 */ "case_block",
  /*  161 */ "case_labels",
  /*  162 */ "where_clause_list",
  /*  163 */ "derive_decl",
  /*  164 */ "explicit_attribute",
  /*  165 */ "expression_list",
  /*  166 */ "formal_parameter",
  /*  167 */ "formal_parameter_list",
  /*  168 */ "formal_parameter_rep",
  /*  169 */ "id_list",
  /*  170 */ "defined_type_list",
  /*  171 */ "nested_id_list",
  /*  172 */ "statement_rep",
  /*  173 */ "subtype_decl",
  /*  174 */ "where_rule",
  /*  175 */ "where_rule_OPT",
  /*  176 */ "supertype_expression_list",
  /*  177 */ "labelled_attrib_list_list",
  /*  178 */ "labelled_attrib_list",
  /*  179 */ "inverse_attr_list",
  /*  180 */ "inverse_clause",
  /*  181 */ "attribute_decl_list",
  /*  182 */ "derived_attribute_rep",
  /*  183 */ "unique_clause",
  /*  184 */ "rule_formal_parameter_list",
  /*  185 */ "qualified_attr_list",
  /*  186 */ "rel_op",
  /*  187 */ "optional_or_unique",
  /*  188 */ "optional_fixed",
  /*  189 */ "optional",
  /*  190 */ "var",
  /*  191 */ "unique",
  /*  192 */ "qualified_attr",
  /*  193 */ "qualifier",
  /*  194 */ "alias_statement",
  /*  195 */ "assignment_statement",
  /*  196 */ "case_statement",
  /*  197 */ "compound_statement",
  /*  198 */ "escape_statement",
  /*  199 */ "if_statement",
  /*  200 */ "proc_call_statement",
  /*  201 */ "repeat_statement",
  /*  202 */ "return_statement",
  /*  203 */ "skip_statement",
  /*  204 */ "statement",
  /*  205 */ "subsuper_decl",
  /*  206 */ "supertype_decl",
  /*  207 */ "supertype_factor",
  /*  208 */ "function_id",
  /*  209 */ "procedure_id",
  /*  210 */ "attribute_type",
  /*  211 */ "defined_type",
  /*  212 */ "parameter_type",
  /*  213 */ "generic_type",
  /*  214 */ "basic_type",
  /*  215 */ "select_type",
  /*  216 */ "aggregate_type",
  /*  217 */ "aggregation_type",
  /*  218 */ "array_type",
  /*  219 */ "bag_type",
  /*  220 */ "conformant_aggregation",
  /*  221 */ "list_type",
  /*  222 */ "set_type",
  /*  223 */ "set_or_bag_of_entity",
  /*  224 */ "type",
  /*  225 */ "cardinality_op",
  /*  226 */ "bound_spec",
  /*  227 */ "inverse_attr",
  /*  228 */ "derived_attribute",
  /*  229 */ "rule_formal_parameter",
  /*  230 */ "where_clause",
  /*  231 */ "action_body_item_rep",
  /*  232 */ "action_body_item",
  /*  233 */ "declaration",
  /*  234 */ "constant_decl",
  /*  235 */ "local_decl",
  /*  236 */ "semicolon",
  /*  237 */ "alias_push_scope",
  /*  238 */ "block_list",
  /*  239 */ "block_member",
  /*  240 */ "include_directive",
  /*  241 */ "rule_decl",
  /*  242 */ "constant_body",
  /*  243 */ "constant_body_list",
  /*  244 */ "entity_decl",
  /*  245 */ "function_decl",
  /*  246 */ "procedure_decl",
  /*  247 */ "type_decl",
  /*  248 */ "entity_header",
  /*  249 */ "enumeration_type",
  /*  250 */ "express_file",
  /*  251 */ "schema_decl_list",
  /*  252 */ "schema_decl",
  /*  253 */ "fh_push_scope",
  /*  254 */ "fh_plist",
  /*  255 */ "increment_control",
  /*  256 */ "rename",
  /*  257 */ "rename_list",
  /*  258 */ "parened_rename_list",
  /*  259 */ "reference_clause",
  /*  260 */ "reference_head",
  /*  261 */ "use_clause",
  /*  262 */ "use_head",
  /*  263 */ "interface_specification",
  /*  264 */ "interface_specification_list",
  /*  265 */ "right_curl",
  /*  266 */ "local_variable",
  /*  267 */ "local_body",
  /*  268 */ "local_decl_rules_on",
  /*  269 */ "local_decl_rules_off",
  /*  270 */ "oneof_op",
  /*  271 */ "ph_push_scope",
  /*  272 */ "schema_body",
  /*  273 */ "schema_header",
  /*  274 */ "type_item_body",
  /*  275 */ "type_item",
  /*  276 */ "ti_start",
  /*  277 */ "td_start",
};
#endif /* defined(YYCOVERAGE) || !defined(NDEBUG) */

#ifndef NDEBUG
/* For tracing reduce actions, the names of all rules are required.
*/
static const char *const yyRuleName[] = {
 /*   0 */ "action_body ::= action_body_item_rep statement_rep",
 /*   1 */ "action_body_item ::= declaration",
 /*   2 */ "action_body_item ::= constant_decl",
 /*   3 */ "action_body_item ::= local_decl",
 /*   4 */ "action_body_item_rep ::= action_body_item action_body_item_rep",
 /*   5 */ "actual_parameters ::= TOK_LEFT_PAREN expression_list TOK_RIGHT_PAREN",
 /*   6 */ "actual_parameters ::= TOK_LEFT_PAREN TOK_RIGHT_PAREN",
 /*   7 */ "aggregate_initializer ::= TOK_LEFT_BRACKET TOK_RIGHT_BRACKET",
 /*   8 */ "aggregate_initializer ::= TOK_LEFT_BRACKET aggregate_init_body TOK_RIGHT_BRACKET",
 /*   9 */ "aggregate_init_element ::= expression",
 /*  10 */ "aggregate_init_body ::= aggregate_init_element",
 /*  11 */ "aggregate_init_body ::= aggregate_init_element TOK_COLON expression",
 /*  12 */ "aggregate_init_body ::= aggregate_init_body TOK_COMMA aggregate_init_element",
 /*  13 */ "aggregate_init_body ::= aggregate_init_body TOK_COMMA aggregate_init_element TOK_COLON expression",
 /*  14 */ "aggregate_type ::= TOK_AGGREGATE TOK_OF parameter_type",
 /*  15 */ "aggregate_type ::= TOK_AGGREGATE TOK_COLON TOK_IDENTIFIER TOK_OF parameter_type",
 /*  16 */ "aggregation_type ::= array_type",
 /*  17 */ "aggregation_type ::= bag_type",
 /*  18 */ "aggregation_type ::= list_type",
 /*  19 */ "aggregation_type ::= set_type",
 /*  20 */ "alias_statement ::= TOK_ALIAS TOK_IDENTIFIER TOK_FOR general_ref semicolon alias_push_scope statement_rep TOK_END_ALIAS semicolon",
 /*  21 */ "alias_push_scope ::=",
 /*  22 */ "array_type ::= TOK_ARRAY bound_spec TOK_OF optional_or_unique attribute_type",
 /*  23 */ "assignable ::= assignable qualifier",
 /*  24 */ "assignable ::= identifier",
 /*  25 */ "assignment_statement ::= assignable TOK_ASSIGNMENT expression semicolon",
 /*  26 */ "attribute_type ::= aggregation_type",
 /*  27 */ "attribute_type ::= basic_type",
 /*  28 */ "attribute_type ::= defined_type",
 /*  29 */ "explicit_attr_list ::=",
 /*  30 */ "explicit_attr_list ::= explicit_attr_list explicit_attribute",
 /*  31 */ "bag_type ::= TOK_BAG bound_spec TOK_OF attribute_type",
 /*  32 */ "bag_type ::= TOK_BAG TOK_OF attribute_type",
 /*  33 */ "basic_type ::= TOK_BOOLEAN",
 /*  34 */ "basic_type ::= TOK_INTEGER precision_spec",
 /*  35 */ "basic_type ::= TOK_REAL precision_spec",
 /*  36 */ "basic_type ::= TOK_NUMBER",
 /*  37 */ "basic_type ::= TOK_LOGICAL",
 /*  38 */ "basic_type ::= TOK_BINARY precision_spec optional_fixed",
 /*  39 */ "basic_type ::= TOK_STRING precision_spec optional_fixed",
 /*  40 */ "block_list ::= block_list block_member",
 /*  41 */ "block_member ::= declaration",
 /*  42 */ "block_member ::= include_directive",
 /*  43 */ "block_member ::= rule_decl",
 /*  44 */ "by_expression ::=",
 /*  45 */ "by_expression ::= TOK_BY expression",
 /*  46 */ "cardinality_op ::= TOK_LEFT_CURL expression TOK_COLON expression TOK_RIGHT_CURL",
 /*  47 */ "case_action ::= case_labels TOK_COLON statement",
 /*  48 */ "case_action_list ::=",
 /*  49 */ "case_action_list ::= case_action_list case_action",
 /*  50 */ "case_block ::= case_action_list case_otherwise",
 /*  51 */ "case_labels ::= expression",
 /*  52 */ "case_labels ::= case_labels TOK_COMMA expression",
 /*  53 */ "case_otherwise ::=",
 /*  54 */ "case_otherwise ::= TOK_OTHERWISE TOK_COLON statement",
 /*  55 */ "case_statement ::= TOK_CASE expression TOK_OF case_block TOK_END_CASE semicolon",
 /*  56 */ "compound_statement ::= TOK_BEGIN statement_rep TOK_END semicolon",
 /*  57 */ "constant ::= TOK_PI",
 /*  58 */ "constant ::= TOK_E",
 /*  59 */ "constant_body ::= identifier TOK_COLON attribute_type TOK_ASSIGNMENT expression semicolon",
 /*  60 */ "constant_body_list ::= constant_body constant_body_list",
 /*  61 */ "constant_decl ::= TOK_CONSTANT constant_body_list TOK_END_CONSTANT semicolon",
 /*  62 */ "declaration ::= entity_decl",
 /*  63 */ "declaration ::= function_decl",
 /*  64 */ "declaration ::= procedure_decl",
 /*  65 */ "declaration ::= type_decl",
 /*  66 */ "derive_decl ::=",
 /*  67 */ "derive_decl ::= TOK_DERIVE derived_attribute_rep",
 /*  68 */ "derived_attribute ::= attribute_decl TOK_COLON attribute_type initializer semicolon",
 /*  69 */ "derived_attribute_rep ::= derived_attribute",
 /*  70 */ "derived_attribute_rep ::= derived_attribute_rep derived_attribute",
 /*  71 */ "entity_body ::= explicit_attr_list derive_decl inverse_clause unique_clause where_rule_OPT",
 /*  72 */ "entity_decl ::= entity_header subsuper_decl semicolon entity_body TOK_END_ENTITY semicolon",
 /*  73 */ "entity_header ::= TOK_ENTITY TOK_IDENTIFIER",
 /*  74 */ "enumeration_type ::= TOK_ENUMERATION TOK_OF nested_id_list",
 /*  75 */ "escape_statement ::= TOK_ESCAPE semicolon",
 /*  76 */ "attribute_decl ::= TOK_IDENTIFIER",
 /*  77 */ "attribute_decl ::= TOK_SELF TOK_BACKSLASH TOK_IDENTIFIER TOK_DOT TOK_IDENTIFIER",
 /*  78 */ "attribute_decl_list ::= attribute_decl",
 /*  79 */ "attribute_decl_list ::= attribute_decl_list TOK_COMMA attribute_decl",
 /*  80 */ "optional ::=",
 /*  81 */ "optional ::= TOK_OPTIONAL",
 /*  82 */ "explicit_attribute ::= attribute_decl_list TOK_COLON optional attribute_type semicolon",
 /*  83 */ "schema_decl_list ::= schema_decl",
 /*  84 */ "schema_decl_list ::= schema_decl_list schema_decl",
 /*  85 */ "expression ::= simple_expression",
 /*  86 */ "expression ::= expression TOK_AND expression",
 /*  87 */ "expression ::= expression TOK_OR expression",
 /*  88 */ "expression ::= expression TOK_XOR expression",
 /*  89 */ "expression ::= expression TOK_LESS_THAN expression",
 /*  90 */ "expression ::= expression TOK_GREATER_THAN expression",
 /*  91 */ "expression ::= expression TOK_EQUAL expression",
 /*  92 */ "expression ::= expression TOK_LESS_EQUAL expression",
 /*  93 */ "expression ::= expression TOK_GREATER_EQUAL expression",
 /*  94 */ "expression ::= expression TOK_NOT_EQUAL expression",
 /*  95 */ "expression ::= expression TOK_INST_EQUAL expression",
 /*  96 */ "expression ::= expression TOK_INST_NOT_EQUAL expression",
 /*  97 */ "expression ::= expression TOK_IN expression",
 /*  98 */ "expression ::= expression TOK_LIKE expression",
 /*  99 */ "expression ::= simple_expression cardinality_op simple_expression",
 /* 100 */ "simple_expression ::= unary_expression",
 /* 101 */ "simple_expression ::= simple_expression TOK_CONCAT_OP simple_expression",
 /* 102 */ "simple_expression ::= simple_expression TOK_EXP simple_expression",
 /* 103 */ "simple_expression ::= simple_expression TOK_TIMES simple_expression",
 /* 104 */ "simple_expression ::= simple_expression TOK_DIV simple_expression",
 /* 105 */ "simple_expression ::= simple_expression TOK_REAL_DIV simple_expression",
 /* 106 */ "simple_expression ::= simple_expression TOK_MOD simple_expression",
 /* 107 */ "simple_expression ::= simple_expression TOK_PLUS simple_expression",
 /* 108 */ "simple_expression ::= simple_expression TOK_MINUS simple_expression",
 /* 109 */ "expression_list ::= expression",
 /* 110 */ "expression_list ::= expression_list TOK_COMMA expression",
 /* 111 */ "var ::=",
 /* 112 */ "var ::= TOK_VAR",
 /* 113 */ "formal_parameter ::= var id_list TOK_COLON parameter_type",
 /* 114 */ "formal_parameter_list ::=",
 /* 115 */ "formal_parameter_list ::= TOK_LEFT_PAREN formal_parameter_rep TOK_RIGHT_PAREN",
 /* 116 */ "formal_parameter_rep ::= formal_parameter",
 /* 117 */ "formal_parameter_rep ::= formal_parameter_rep semicolon formal_parameter",
 /* 118 */ "parameter_type ::= basic_type",
 /* 119 */ "parameter_type ::= conformant_aggregation",
 /* 120 */ "parameter_type ::= defined_type",
 /* 121 */ "parameter_type ::= generic_type",
 /* 122 */ "function_call ::= function_id actual_parameters",
 /* 123 */ "function_decl ::= function_header action_body TOK_END_FUNCTION semicolon",
 /* 124 */ "function_header ::= fh_lineno fh_push_scope fh_plist TOK_COLON parameter_type semicolon",
 /* 125 */ "fh_lineno ::= TOK_FUNCTION",
 /* 126 */ "fh_push_scope ::= TOK_IDENTIFIER",
 /* 127 */ "fh_plist ::= formal_parameter_list",
 /* 128 */ "function_id ::= TOK_IDENTIFIER",
 /* 129 */ "function_id ::= TOK_BUILTIN_FUNCTION",
 /* 130 */ "conformant_aggregation ::= aggregate_type",
 /* 131 */ "conformant_aggregation ::= TOK_ARRAY TOK_OF optional_or_unique parameter_type",
 /* 132 */ "conformant_aggregation ::= TOK_ARRAY bound_spec TOK_OF optional_or_unique parameter_type",
 /* 133 */ "conformant_aggregation ::= TOK_BAG TOK_OF parameter_type",
 /* 134 */ "conformant_aggregation ::= TOK_BAG bound_spec TOK_OF parameter_type",
 /* 135 */ "conformant_aggregation ::= TOK_LIST TOK_OF unique parameter_type",
 /* 136 */ "conformant_aggregation ::= TOK_LIST bound_spec TOK_OF unique parameter_type",
 /* 137 */ "conformant_aggregation ::= TOK_SET TOK_OF parameter_type",
 /* 138 */ "conformant_aggregation ::= TOK_SET bound_spec TOK_OF parameter_type",
 /* 139 */ "generic_type ::= TOK_GENERIC",
 /* 140 */ "generic_type ::= TOK_GENERIC TOK_COLON TOK_IDENTIFIER",
 /* 141 */ "id_list ::= TOK_IDENTIFIER",
 /* 142 */ "id_list ::= id_list TOK_COMMA TOK_IDENTIFIER",
 /* 143 */ "identifier ::= TOK_SELF",
 /* 144 */ "identifier ::= TOK_QUESTION_MARK",
 /* 145 */ "identifier ::= TOK_IDENTIFIER",
 /* 146 */ "if_statement ::= TOK_IF expression TOK_THEN statement_rep TOK_END_IF semicolon",
 /* 147 */ "if_statement ::= TOK_IF expression TOK_THEN statement_rep TOK_ELSE statement_rep TOK_END_IF semicolon",
 /* 148 */ "include_directive ::= TOK_INCLUDE TOK_STRING_LITERAL semicolon",
 /* 149 */ "increment_control ::= TOK_IDENTIFIER TOK_ASSIGNMENT expression TOK_TO expression by_expression",
 /* 150 */ "initializer ::= TOK_ASSIGNMENT expression",
 /* 151 */ "rename ::= TOK_IDENTIFIER",
 /* 152 */ "rename ::= TOK_IDENTIFIER TOK_AS TOK_IDENTIFIER",
 /* 153 */ "rename_list ::= rename",
 /* 154 */ "rename_list ::= rename_list TOK_COMMA rename",
 /* 155 */ "reference_clause ::= TOK_REFERENCE TOK_FROM TOK_IDENTIFIER semicolon",
 /* 156 */ "reference_clause ::= reference_head parened_rename_list semicolon",
 /* 157 */ "reference_head ::= TOK_REFERENCE TOK_FROM TOK_IDENTIFIER",
 /* 158 */ "use_clause ::= TOK_USE TOK_FROM TOK_IDENTIFIER semicolon",
 /* 159 */ "use_clause ::= use_head parened_rename_list semicolon",
 /* 160 */ "use_head ::= TOK_USE TOK_FROM TOK_IDENTIFIER",
 /* 161 */ "interface_specification ::= use_clause",
 /* 162 */ "interface_specification ::= reference_clause",
 /* 163 */ "interface_specification_list ::= interface_specification_list interface_specification",
 /* 164 */ "interval ::= TOK_LEFT_CURL simple_expression rel_op simple_expression rel_op simple_expression right_curl",
 /* 165 */ "set_or_bag_of_entity ::= defined_type",
 /* 166 */ "set_or_bag_of_entity ::= TOK_SET TOK_OF defined_type",
 /* 167 */ "set_or_bag_of_entity ::= TOK_SET bound_spec TOK_OF defined_type",
 /* 168 */ "set_or_bag_of_entity ::= TOK_BAG bound_spec TOK_OF defined_type",
 /* 169 */ "set_or_bag_of_entity ::= TOK_BAG TOK_OF defined_type",
 /* 170 */ "inverse_attr_list ::= inverse_attr",
 /* 171 */ "inverse_attr_list ::= inverse_attr_list inverse_attr",
 /* 172 */ "inverse_attr ::= attribute_decl TOK_COLON set_or_bag_of_entity TOK_FOR TOK_IDENTIFIER semicolon",
 /* 173 */ "inverse_clause ::=",
 /* 174 */ "inverse_clause ::= TOK_INVERSE inverse_attr_list",
 /* 175 */ "bound_spec ::= TOK_LEFT_BRACKET expression TOK_COLON expression TOK_RIGHT_BRACKET",
 /* 176 */ "list_type ::= TOK_LIST bound_spec TOK_OF unique attribute_type",
 /* 177 */ "list_type ::= TOK_LIST TOK_OF unique attribute_type",
 /* 178 */ "literal ::= TOK_INTEGER_LITERAL",
 /* 179 */ "literal ::= TOK_REAL_LITERAL",
 /* 180 */ "literal ::= TOK_STRING_LITERAL",
 /* 181 */ "literal ::= TOK_STRING_LITERAL_ENCODED",
 /* 182 */ "literal ::= TOK_LOGICAL_LITERAL",
 /* 183 */ "literal ::= TOK_BINARY_LITERAL",
 /* 184 */ "literal ::= constant",
 /* 185 */ "local_initializer ::= TOK_ASSIGNMENT expression",
 /* 186 */ "local_variable ::= id_list TOK_COLON parameter_type semicolon",
 /* 187 */ "local_variable ::= id_list TOK_COLON parameter_type local_initializer semicolon",
 /* 188 */ "local_body ::= local_variable local_body",
 /* 189 */ "local_decl_rules_on ::=",
 /* 190 */ "local_decl_rules_off ::=",
 /* 191 */ "defined_type ::= TOK_IDENTIFIER",
 /* 192 */ "defined_type_list ::= defined_type",
 /* 193 */ "defined_type_list ::= defined_type_list TOK_COMMA defined_type",
 /* 194 */ "nested_id_list ::= TOK_LEFT_PAREN id_list TOK_RIGHT_PAREN",
 /* 195 */ "oneof_op ::= TOK_ONEOF",
 /* 196 */ "optional_or_unique ::=",
 /* 197 */ "optional_or_unique ::= TOK_OPTIONAL",
 /* 198 */ "optional_or_unique ::= TOK_UNIQUE",
 /* 199 */ "optional_or_unique ::= TOK_OPTIONAL TOK_UNIQUE",
 /* 200 */ "optional_or_unique ::= TOK_UNIQUE TOK_OPTIONAL",
 /* 201 */ "optional_fixed ::=",
 /* 202 */ "optional_fixed ::= TOK_FIXED",
 /* 203 */ "precision_spec ::=",
 /* 204 */ "precision_spec ::= TOK_LEFT_PAREN expression TOK_RIGHT_PAREN",
 /* 205 */ "proc_call_statement ::= procedure_id actual_parameters semicolon",
 /* 206 */ "proc_call_statement ::= procedure_id semicolon",
 /* 207 */ "procedure_decl ::= procedure_header action_body TOK_END_PROCEDURE semicolon",
 /* 208 */ "procedure_header ::= TOK_PROCEDURE ph_get_line ph_push_scope formal_parameter_list semicolon",
 /* 209 */ "ph_push_scope ::= TOK_IDENTIFIER",
 /* 210 */ "ph_get_line ::=",
 /* 211 */ "procedure_id ::= TOK_IDENTIFIER",
 /* 212 */ "procedure_id ::= TOK_BUILTIN_PROCEDURE",
 /* 213 */ "group_ref ::= TOK_BACKSLASH TOK_IDENTIFIER",
 /* 214 */ "qualifier ::= TOK_DOT TOK_IDENTIFIER",
 /* 215 */ "qualifier ::= TOK_BACKSLASH TOK_IDENTIFIER",
 /* 216 */ "qualifier ::= TOK_LEFT_BRACKET simple_expression TOK_RIGHT_BRACKET",
 /* 217 */ "qualifier ::= TOK_LEFT_BRACKET simple_expression TOK_COLON simple_expression TOK_RIGHT_BRACKET",
 /* 218 */ "query_expression ::= query_start expression TOK_RIGHT_PAREN",
 /* 219 */ "query_start ::= TOK_QUERY TOK_LEFT_PAREN TOK_IDENTIFIER TOK_ALL_IN expression TOK_SUCH_THAT",
 /* 220 */ "rel_op ::= TOK_LESS_THAN",
 /* 221 */ "rel_op ::= TOK_GREATER_THAN",
 /* 222 */ "rel_op ::= TOK_EQUAL",
 /* 223 */ "rel_op ::= TOK_LESS_EQUAL",
 /* 224 */ "rel_op ::= TOK_GREATER_EQUAL",
 /* 225 */ "rel_op ::= TOK_NOT_EQUAL",
 /* 226 */ "rel_op ::= TOK_INST_EQUAL",
 /* 227 */ "rel_op ::= TOK_INST_NOT_EQUAL",
 /* 228 */ "repeat_statement ::= TOK_REPEAT increment_control while_control until_control semicolon statement_rep TOK_END_REPEAT semicolon",
 /* 229 */ "repeat_statement ::= TOK_REPEAT while_control until_control semicolon statement_rep TOK_END_REPEAT semicolon",
 /* 230 */ "return_statement ::= TOK_RETURN semicolon",
 /* 231 */ "return_statement ::= TOK_RETURN TOK_LEFT_PAREN expression TOK_RIGHT_PAREN semicolon",
 /* 232 */ "right_curl ::= TOK_RIGHT_CURL",
 /* 233 */ "rule_decl ::= rule_header action_body where_rule TOK_END_RULE semicolon",
 /* 234 */ "rule_formal_parameter ::= TOK_IDENTIFIER",
 /* 235 */ "rule_formal_parameter_list ::= rule_formal_parameter",
 /* 236 */ "rule_formal_parameter_list ::= rule_formal_parameter_list TOK_COMMA rule_formal_parameter",
 /* 237 */ "rule_header ::= rh_start rule_formal_parameter_list TOK_RIGHT_PAREN semicolon",
 /* 238 */ "rh_start ::= TOK_RULE rh_get_line TOK_IDENTIFIER TOK_FOR TOK_LEFT_PAREN",
 /* 239 */ "rh_get_line ::=",
 /* 240 */ "schema_body ::= interface_specification_list block_list",
 /* 241 */ "schema_body ::= interface_specification_list constant_decl block_list",
 /* 242 */ "schema_decl ::= schema_header schema_body TOK_END_SCHEMA semicolon",
 /* 243 */ "schema_decl ::= include_directive",
 /* 244 */ "schema_header ::= TOK_SCHEMA TOK_IDENTIFIER semicolon",
 /* 245 */ "select_type ::= TOK_SELECT TOK_LEFT_PAREN defined_type_list TOK_RIGHT_PAREN",
 /* 246 */ "semicolon ::= TOK_SEMICOLON",
 /* 247 */ "set_type ::= TOK_SET bound_spec TOK_OF attribute_type",
 /* 248 */ "set_type ::= TOK_SET TOK_OF attribute_type",
 /* 249 */ "skip_statement ::= TOK_SKIP semicolon",
 /* 250 */ "statement ::= alias_statement",
 /* 251 */ "statement ::= assignment_statement",
 /* 252 */ "statement ::= case_statement",
 /* 253 */ "statement ::= compound_statement",
 /* 254 */ "statement ::= escape_statement",
 /* 255 */ "statement ::= if_statement",
 /* 256 */ "statement ::= proc_call_statement",
 /* 257 */ "statement ::= repeat_statement",
 /* 258 */ "statement ::= return_statement",
 /* 259 */ "statement ::= skip_statement",
 /* 260 */ "statement_rep ::=",
 /* 261 */ "statement_rep ::= semicolon statement_rep",
 /* 262 */ "statement_rep ::= statement statement_rep",
 /* 263 */ "subsuper_decl ::=",
 /* 264 */ "subsuper_decl ::= supertype_decl",
 /* 265 */ "subsuper_decl ::= subtype_decl",
 /* 266 */ "subsuper_decl ::= supertype_decl subtype_decl",
 /* 267 */ "subtype_decl ::= TOK_SUBTYPE TOK_OF TOK_LEFT_PAREN defined_type_list TOK_RIGHT_PAREN",
 /* 268 */ "supertype_decl ::= TOK_ABSTRACT TOK_SUPERTYPE",
 /* 269 */ "supertype_decl ::= TOK_SUPERTYPE TOK_OF TOK_LEFT_PAREN supertype_expression TOK_RIGHT_PAREN",
 /* 270 */ "supertype_decl ::= TOK_ABSTRACT TOK_SUPERTYPE TOK_OF TOK_LEFT_PAREN supertype_expression TOK_RIGHT_PAREN",
 /* 271 */ "supertype_expression ::= supertype_factor",
 /* 272 */ "supertype_expression ::= supertype_expression TOK_AND supertype_factor",
 /* 273 */ "supertype_expression ::= supertype_expression TOK_ANDOR supertype_factor",
 /* 274 */ "supertype_expression_list ::= supertype_expression",
 /* 275 */ "supertype_expression_list ::= supertype_expression_list TOK_COMMA supertype_expression",
 /* 276 */ "supertype_factor ::= identifier",
 /* 277 */ "supertype_factor ::= oneof_op TOK_LEFT_PAREN supertype_expression_list TOK_RIGHT_PAREN",
 /* 278 */ "supertype_factor ::= TOK_LEFT_PAREN supertype_expression TOK_RIGHT_PAREN",
 /* 279 */ "type ::= aggregation_type",
 /* 280 */ "type ::= basic_type",
 /* 281 */ "type ::= defined_type",
 /* 282 */ "type ::= select_type",
 /* 283 */ "type_item_body ::= enumeration_type",
 /* 284 */ "type_item_body ::= type",
 /* 285 */ "ti_start ::= TOK_IDENTIFIER TOK_EQUAL",
 /* 286 */ "type_decl ::= td_start TOK_END_TYPE semicolon",
 /* 287 */ "td_start ::= TOK_TYPE type_item where_rule_OPT",
 /* 288 */ "general_ref ::= assignable group_ref",
 /* 289 */ "general_ref ::= assignable",
 /* 290 */ "unary_expression ::= aggregate_initializer",
 /* 291 */ "unary_expression ::= unary_expression qualifier",
 /* 292 */ "unary_expression ::= literal",
 /* 293 */ "unary_expression ::= function_call",
 /* 294 */ "unary_expression ::= identifier",
 /* 295 */ "unary_expression ::= TOK_LEFT_PAREN expression TOK_RIGHT_PAREN",
 /* 296 */ "unary_expression ::= interval",
 /* 297 */ "unary_expression ::= query_expression",
 /* 298 */ "unary_expression ::= TOK_NOT unary_expression",
 /* 299 */ "unary_expression ::= TOK_PLUS unary_expression",
 /* 300 */ "unary_expression ::= TOK_MINUS unary_expression",
 /* 301 */ "unique ::=",
 /* 302 */ "unique ::= TOK_UNIQUE",
 /* 303 */ "qualified_attr ::= attribute_decl",
 /* 304 */ "qualified_attr_list ::= qualified_attr",
 /* 305 */ "qualified_attr_list ::= qualified_attr_list TOK_COMMA qualified_attr",
 /* 306 */ "labelled_attrib_list ::= qualified_attr_list semicolon",
 /* 307 */ "labelled_attrib_list ::= TOK_IDENTIFIER TOK_COLON qualified_attr_list semicolon",
 /* 308 */ "labelled_attrib_list_list ::= labelled_attrib_list",
 /* 309 */ "labelled_attrib_list_list ::= labelled_attrib_list_list labelled_attrib_list",
 /* 310 */ "unique_clause ::=",
 /* 311 */ "unique_clause ::= TOK_UNIQUE labelled_attrib_list_list",
 /* 312 */ "until_control ::=",
 /* 313 */ "until_control ::= TOK_UNTIL expression",
 /* 314 */ "where_clause ::= expression semicolon",
 /* 315 */ "where_clause ::= TOK_IDENTIFIER TOK_COLON expression semicolon",
 /* 316 */ "where_clause_list ::= where_clause",
 /* 317 */ "where_clause_list ::= where_clause_list where_clause",
 /* 318 */ "where_rule ::= TOK_WHERE where_clause_list",
 /* 319 */ "where_rule_OPT ::=",
 /* 320 */ "where_rule_OPT ::= where_rule",
 /* 321 */ "while_control ::=",
 /* 322 */ "while_control ::= TOK_WHILE expression",
 /* 323 */ "action_body_item_rep ::=",
 /* 324 */ "block_list ::=",
 /* 325 */ "constant_body_list ::=",
 /* 326 */ "express_file ::= schema_decl_list",
 /* 327 */ "parened_rename_list ::= TOK_LEFT_PAREN rename_list TOK_RIGHT_PAREN",
 /* 328 */ "interface_specification_list ::=",
 /* 329 */ "local_body ::=",
 /* 330 */ "local_decl ::= TOK_LOCAL local_decl_rules_on local_body TOK_END_LOCAL semicolon local_decl_rules_off",
 /* 331 */ "type_item ::= ti_start type_item_body semicolon",
};
#endif /* NDEBUG */


#if YYGROWABLESTACK
/*
** Try to increase the size of the parser stack.  Return the number
** of errors.  Return 0 on success.
*/
static int yyGrowStack(yyParser *p){
  int oldSize = 1 + (int)(p->yystackEnd - p->yystack);
  int newSize;
  int idx;
  yyStackEntry *pNew;
#ifdef YYSIZELIMIT
  int nLimit = YYSIZELIMIT(ParseCTX(p));
#endif

  newSize = oldSize*2 + 100;
#ifdef YYSIZELIMIT
  if( newSize>nLimit ){
    newSize = nLimit;
    if( newSize<=oldSize ) return 1;
  }
#endif
  idx = (int)(p->yytos - p->yystack);
  if( p->yystack==p->yystk0 ){
    pNew = YYREALLOC(0, newSize*sizeof(pNew[0]), ParseCTX(p));
    if( pNew==0 ) return 1;
    memcpy(pNew, p->yystack, oldSize*sizeof(pNew[0]));
  }else{
    pNew = YYREALLOC(p->yystack, newSize*sizeof(pNew[0]), ParseCTX(p));
    if( pNew==0 ) return 1;
  }
  p->yystack = pNew;
  p->yytos = &p->yystack[idx];
#ifndef NDEBUG
  if( yyTraceFILE ){
    fprintf(yyTraceFILE,"%sStack grows from %d to %d entries.\n",
            yyTracePrompt, oldSize, newSize);
  }
#endif
  p->yystackEnd = &p->yystack[newSize-1];
  return 0;
}
#endif /* YYGROWABLESTACK */

#if !YYGROWABLESTACK
/* For builds that do no have a growable stack, yyGrowStack always
** returns an error.
*/
# define yyGrowStack(X) 1
#endif

/* Datatype of the argument to the memory allocated passed as the
** second argument to ParseAlloc() below.  This can be changed by
** putting an appropriate #define in the %include section of the input
** grammar.
*/
#ifndef YYMALLOCARGTYPE
# define YYMALLOCARGTYPE size_t
#endif

/* Initialize a new parser that has already been allocated.
*/
void ParseInit(void *yypRawParser ParseCTX_PDECL){
  yyParser *yypParser = (yyParser*)yypRawParser;
  ParseCTX_STORE
#ifdef YYTRACKMAXSTACKDEPTH
  yypParser->yyhwm = 0;
#endif
  yypParser->yystack = yypParser->yystk0;
  yypParser->yystackEnd = &yypParser->yystack[YYSTACKDEPTH-1];
#ifndef YYNOERRORRECOVERY
  yypParser->yyerrcnt = -1;
#endif
  yypParser->yytos = yypParser->yystack;
  yypParser->yystack[0].stateno = 0;
  yypParser->yystack[0].major = 0;
}

#ifndef Parse_ENGINEALWAYSONSTACK
/* 
** This function allocates a new parser.
** The only argument is a pointer to a function which works like
** malloc.
**
** Inputs:
** A pointer to the function used to allocate memory.
**
** Outputs:
** A pointer to a parser.  This pointer is used in subsequent calls
** to Parse and ParseFree.
*/
void *ParseAlloc(void *(*mallocProc)(YYMALLOCARGTYPE) ParseCTX_PDECL){
  yyParser *yypParser;
  yypParser = (yyParser*)(*mallocProc)( (YYMALLOCARGTYPE)sizeof(yyParser) );
  if( yypParser ){
    ParseCTX_STORE
    ParseInit(yypParser ParseCTX_PARAM);
  }
  return (void*)yypParser;
}
#endif /* Parse_ENGINEALWAYSONSTACK */


/* The following function deletes the "minor type" or semantic value
** associated with a symbol.  The symbol can be either a terminal
** or nonterminal. "yymajor" is the symbol code, and "yypminor" is
** a pointer to the value to be deleted.  The code used to do the 
** deletions is derived from the %destructor and/or %token_destructor
** directives of the input grammar.
*/
static void yy_destructor(
  yyParser *yypParser,    /* The parser */
  YYCODETYPE yymajor,     /* Type code for object to destroy */
  YYMINORTYPE *yypminor   /* The object to be destroyed */
){
  ParseARG_FETCH
  ParseCTX_FETCH
  switch( yymajor ){
    /* Here is inserted the actions which take place when a
    ** terminal or non-terminal is destroyed.  This can happen
    ** when the symbol is popped from the stack during a
    ** reduce or during error processing or when a parser is 
    ** being destroyed before it is finished parsing.
    **
    ** Note: during a reduce, the only symbols destroyed are those
    ** which appear on the RHS of the rule, but which are *not* used
    ** inside the C code.
    */
/********* Begin destructor definitions ***************************************/
    case 121: /* statement_list */
{
#line 124 "expparse.y"

    if (parseData.scanner == NULL) {
    (yypminor->yy0).string = (char*)NULL;
    }

#line 2004 "expparse.c"
}
      break;
/********* End destructor definitions *****************************************/
    default:  break;   /* If no destructor action specified: do nothing */
  }
}

/*
** Pop the parser's stack once.
**
** If there is a destructor routine associated with the token which
** is popped from the stack, then call it.
*/
static void yy_pop_parser_stack(yyParser *pParser){
  yyStackEntry *yytos;
  assert( pParser->yytos!=0 );
  assert( pParser->yytos > pParser->yystack );
  yytos = pParser->yytos--;
#ifndef NDEBUG
  if( yyTraceFILE ){
    fprintf(yyTraceFILE,"%sPopping %s\n",
      yyTracePrompt,
      yyTokenName[yytos->major]);
  }
#endif
  yy_destructor(pParser, yytos->major, &yytos->minor);
}

/*
** Clear all secondary memory allocations from the parser
*/
void ParseFinalize(void *p){
  yyParser *pParser = (yyParser*)p;

  /* In-lined version of calling yy_pop_parser_stack() for each
  ** element left in the stack */
  yyStackEntry *yytos = pParser->yytos;
  while( yytos>pParser->yystack ){
#ifndef NDEBUG
    if( yyTraceFILE ){
      fprintf(yyTraceFILE,"%sPopping %s\n",
        yyTracePrompt,
        yyTokenName[yytos->major]);
    }
#endif
    if( yytos->major>=YY_MIN_DSTRCTR ){
      yy_destructor(pParser, yytos->major, &yytos->minor);
    }
    yytos--;
  }

#if YYGROWABLESTACK
  if( pParser->yystack!=pParser->yystk0 ){
    YYFREE(pParser->yystack, ParseCTX(pParser));
  }
#endif
}

#ifndef Parse_ENGINEALWAYSONSTACK
/* 
** Deallocate and destroy a parser.  Destructors are called for
** all stack elements before shutting the parser down.
**
** If the YYPARSEFREENEVERNULL macro exists (for example because it
** is defined in a %include section of the input grammar) then it is
** assumed that the input pointer is never NULL.
*/
void ParseFree(
  void *p,                    /* The parser to be deleted */
  void (*freeProc)(void*)     /* Function used to reclaim memory */
){
#ifndef YYPARSEFREENEVERNULL
  if( p==0 ) return;
#endif
  ParseFinalize(p);
  (*freeProc)(p);
}
#endif /* Parse_ENGINEALWAYSONSTACK */

/*
** Return the peak depth of the stack for a parser.
*/
#ifdef YYTRACKMAXSTACKDEPTH
int ParseStackPeak(void *p){
  yyParser *pParser = (yyParser*)p;
  return pParser->yyhwm;
}
#endif

/* This array of booleans keeps track of the parser statement
** coverage.  The element yycoverage[X][Y] is set when the parser
** is in state X and has a lookahead token Y.  In a well-tested
** systems, every element of this matrix should end up being set.
*/
#if defined(YYCOVERAGE)
static unsigned char yycoverage[YYNSTATE][YYNTOKEN];
#endif

/*
** Write into out a description of every state/lookahead combination that
**
**   (1)  has not been used by the parser, and
**   (2)  is not a syntax error.
**
** Return the number of missed state/lookahead combinations.
*/
#if defined(YYCOVERAGE)
int ParseCoverage(FILE *out){
  int stateno, iLookAhead, i;
  int nMissed = 0;
  for(stateno=0; stateno<YYNSTATE; stateno++){
    i = yy_shift_ofst[stateno];
    for(iLookAhead=0; iLookAhead<YYNTOKEN; iLookAhead++){
      if( yy_lookahead[i+iLookAhead]!=iLookAhead ) continue;
      if( yycoverage[stateno][iLookAhead]==0 ) nMissed++;
      if( out ){
        fprintf(out,"State %d lookahead %s %s\n", stateno,
                yyTokenName[iLookAhead],
                yycoverage[stateno][iLookAhead] ? "ok" : "missed");
      }
    }
  }
  return nMissed;
}
#endif

/*
** Find the appropriate action for a parser given the terminal
** look-ahead token iLookAhead.
*/
static YYACTIONTYPE yy_find_shift_action(
  YYCODETYPE iLookAhead,    /* The look-ahead token */
  YYACTIONTYPE stateno      /* Current state number */
){
  int i;

  if( stateno>YY_MAX_SHIFT ) return stateno;
  assert( stateno <= YY_SHIFT_COUNT );
#if defined(YYCOVERAGE)
  yycoverage[stateno][iLookAhead] = 1;
#endif
  do{
    i = yy_shift_ofst[stateno];
    assert( i>=0 );
    assert( i<=YY_ACTTAB_COUNT );
    assert( i+YYNTOKEN<=(int)YY_NLOOKAHEAD );
    assert( iLookAhead!=YYNOCODE );
    assert( iLookAhead < YYNTOKEN );
    i += iLookAhead;
    assert( i<(int)YY_NLOOKAHEAD );
    if( yy_lookahead[i]!=iLookAhead ){
#ifdef YYFALLBACK
      YYCODETYPE iFallback;            /* Fallback token */
      assert( iLookAhead<sizeof(yyFallback)/sizeof(yyFallback[0]) );
      iFallback = yyFallback[iLookAhead];
      if( iFallback!=0 ){
#ifndef NDEBUG
        if( yyTraceFILE ){
          fprintf(yyTraceFILE, "%sFALLBACK %s => %s\n",
             yyTracePrompt, yyTokenName[iLookAhead], yyTokenName[iFallback]);
        }
#endif
        assert( yyFallback[iFallback]==0 ); /* Fallback loop must terminate */
        iLookAhead = iFallback;
        continue;
      }
#endif
#ifdef YYWILDCARD
      {
        int j = i - iLookAhead + YYWILDCARD;
        assert( j<(int)(sizeof(yy_lookahead)/sizeof(yy_lookahead[0])) );
        if( yy_lookahead[j]==YYWILDCARD && iLookAhead>0 ){
#ifndef NDEBUG
          if( yyTraceFILE ){
            fprintf(yyTraceFILE, "%sWILDCARD %s => %s\n",
               yyTracePrompt, yyTokenName[iLookAhead],
               yyTokenName[YYWILDCARD]);
          }
#endif /* NDEBUG */
          return yy_action[j];
        }
      }
#endif /* YYWILDCARD */
      return yy_default[stateno];
    }else{
      assert( i>=0 && i<(int)(sizeof(yy_action)/sizeof(yy_action[0])) );
      return yy_action[i];
    }
  }while(1);
}

/*
** Find the appropriate action for a parser given the non-terminal
** look-ahead token iLookAhead.
*/
static YYACTIONTYPE yy_find_reduce_action(
  YYACTIONTYPE stateno,     /* Current state number */
  YYCODETYPE iLookAhead     /* The look-ahead token */
){
  int i;
#ifdef YYERRORSYMBOL
  if( stateno>YY_REDUCE_COUNT ){
    return yy_default[stateno];
  }
#else
  assert( stateno<=YY_REDUCE_COUNT );
#endif
  i = yy_reduce_ofst[stateno];
  assert( iLookAhead!=YYNOCODE );
  i += iLookAhead;
#ifdef YYERRORSYMBOL
  if( i<0 || i>=YY_ACTTAB_COUNT || yy_lookahead[i]!=iLookAhead ){
    return yy_default[stateno];
  }
#else
  assert( i>=0 && i<YY_ACTTAB_COUNT );
  assert( yy_lookahead[i]==iLookAhead );
#endif
  return yy_action[i];
}

/*
** The following routine is called if the stack overflows.
*/
static void yyStackOverflow(yyParser *yypParser){
   ParseARG_FETCH
   ParseCTX_FETCH
#ifndef NDEBUG
   if( yyTraceFILE ){
     fprintf(yyTraceFILE,"%sStack Overflow!\n",yyTracePrompt);
   }
#endif
   while( yypParser->yytos>yypParser->yystack ) yy_pop_parser_stack(yypParser);
   /* Here code is inserted which will execute if the parser
   ** stack every overflows */
/******** Begin %stack_overflow code ******************************************/
#line 2439 "expparse.y"

    fprintf(stderr, "Express parser experienced stack overflow.\n");
    /* 
     * fprintf(stderr, "Last token had value %x\n", yypMinor->yy0.val);
     * fprintf(stderr, "Last token had value %x\n", yypParser->yytos->minor.yy0.val);
     */
#line 2248 "expparse.c"
/******** End %stack_overflow code ********************************************/
   ParseARG_STORE /* Suppress warning about unused %extra_argument var */
   ParseCTX_STORE
}

/*
** Print tracing information for a SHIFT action
*/
#ifndef NDEBUG
static void yyTraceShift(yyParser *yypParser, int yyNewState, const char *zTag){
  if( yyTraceFILE ){
    if( yyNewState<YYNSTATE ){
      fprintf(yyTraceFILE,"%s%s '%s', go to state %d\n",
         yyTracePrompt, zTag, yyTokenName[yypParser->yytos->major],
         yyNewState);
    }else{
      fprintf(yyTraceFILE,"%s%s '%s', pending reduce %d\n",
         yyTracePrompt, zTag, yyTokenName[yypParser->yytos->major],
         yyNewState - YY_MIN_REDUCE);
    }
  }
}
#else
# define yyTraceShift(X,Y,Z)
#endif

/*
** Perform a shift action.
*/
static void yy_shift(
  yyParser *yypParser,          /* The parser to be shifted */
  YYACTIONTYPE yyNewState,      /* The new state to shift in */
  YYCODETYPE yyMajor,           /* The major token to shift in */
  ParseTOKENTYPE yyMinor        /* The minor token to shift in */
){
  yyStackEntry *yytos;
  yypParser->yytos++;
#ifdef YYTRACKMAXSTACKDEPTH
  if( (int)(yypParser->yytos - yypParser->yystack)>yypParser->yyhwm ){
    yypParser->yyhwm++;
    assert( yypParser->yyhwm == (int)(yypParser->yytos - yypParser->yystack) );
  }
#endif
  yytos = yypParser->yytos;
  if( yytos>yypParser->yystackEnd ){
    if( yyGrowStack(yypParser) ){
      yypParser->yytos--;
      yyStackOverflow(yypParser);
      return;
    }
    yytos = yypParser->yytos;
    assert( yytos <= yypParser->yystackEnd );
  }
  if( yyNewState > YY_MAX_SHIFT ){
    yyNewState += YY_MIN_REDUCE - YY_MIN_SHIFTREDUCE;
  }
  yytos->stateno = yyNewState;
  yytos->major = yyMajor;
  yytos->minor.yy0 = yyMinor;
  yyTraceShift(yypParser, yyNewState, "Shift");
}

/* For rule J, yyRuleInfoLhs[J] contains the symbol on the left-hand side
** of that rule */
static const YYCODETYPE yyRuleInfoLhs[] = {
   155,  /* (0) action_body ::= action_body_item_rep statement_rep */
   232,  /* (1) action_body_item ::= declaration */
   232,  /* (2) action_body_item ::= constant_decl */
   232,  /* (3) action_body_item ::= local_decl */
   231,  /* (4) action_body_item_rep ::= action_body_item action_body_item_rep */
   156,  /* (5) actual_parameters ::= TOK_LEFT_PAREN expression_list TOK_RIGHT_PAREN */
   156,  /* (6) actual_parameters ::= TOK_LEFT_PAREN TOK_RIGHT_PAREN */
   126,  /* (7) aggregate_initializer ::= TOK_LEFT_BRACKET TOK_RIGHT_BRACKET */
   126,  /* (8) aggregate_initializer ::= TOK_LEFT_BRACKET aggregate_init_body TOK_RIGHT_BRACKET */
   125,  /* (9) aggregate_init_element ::= expression */
   157,  /* (10) aggregate_init_body ::= aggregate_init_element */
   157,  /* (11) aggregate_init_body ::= aggregate_init_element TOK_COLON expression */
   157,  /* (12) aggregate_init_body ::= aggregate_init_body TOK_COMMA aggregate_init_element */
   157,  /* (13) aggregate_init_body ::= aggregate_init_body TOK_COMMA aggregate_init_element TOK_COLON expression */
   216,  /* (14) aggregate_type ::= TOK_AGGREGATE TOK_OF parameter_type */
   216,  /* (15) aggregate_type ::= TOK_AGGREGATE TOK_COLON TOK_IDENTIFIER TOK_OF parameter_type */
   217,  /* (16) aggregation_type ::= array_type */
   217,  /* (17) aggregation_type ::= bag_type */
   217,  /* (18) aggregation_type ::= list_type */
   217,  /* (19) aggregation_type ::= set_type */
   194,  /* (20) alias_statement ::= TOK_ALIAS TOK_IDENTIFIER TOK_FOR general_ref semicolon alias_push_scope statement_rep TOK_END_ALIAS semicolon */
   237,  /* (21) alias_push_scope ::= */
   218,  /* (22) array_type ::= TOK_ARRAY bound_spec TOK_OF optional_or_unique attribute_type */
   127,  /* (23) assignable ::= assignable qualifier */
   127,  /* (24) assignable ::= identifier */
   195,  /* (25) assignment_statement ::= assignable TOK_ASSIGNMENT expression semicolon */
   210,  /* (26) attribute_type ::= aggregation_type */
   210,  /* (27) attribute_type ::= basic_type */
   210,  /* (28) attribute_type ::= defined_type */
   158,  /* (29) explicit_attr_list ::= */
   158,  /* (30) explicit_attr_list ::= explicit_attr_list explicit_attribute */
   219,  /* (31) bag_type ::= TOK_BAG bound_spec TOK_OF attribute_type */
   219,  /* (32) bag_type ::= TOK_BAG TOK_OF attribute_type */
   214,  /* (33) basic_type ::= TOK_BOOLEAN */
   214,  /* (34) basic_type ::= TOK_INTEGER precision_spec */
   214,  /* (35) basic_type ::= TOK_REAL precision_spec */
   214,  /* (36) basic_type ::= TOK_NUMBER */
   214,  /* (37) basic_type ::= TOK_LOGICAL */
   214,  /* (38) basic_type ::= TOK_BINARY precision_spec optional_fixed */
   214,  /* (39) basic_type ::= TOK_STRING precision_spec optional_fixed */
   238,  /* (40) block_list ::= block_list block_member */
   239,  /* (41) block_member ::= declaration */
   239,  /* (42) block_member ::= include_directive */
   239,  /* (43) block_member ::= rule_decl */
   129,  /* (44) by_expression ::= */
   129,  /* (45) by_expression ::= TOK_BY expression */
   225,  /* (46) cardinality_op ::= TOK_LEFT_CURL expression TOK_COLON expression TOK_RIGHT_CURL */
   122,  /* (47) case_action ::= case_labels TOK_COLON statement */
   159,  /* (48) case_action_list ::= */
   159,  /* (49) case_action_list ::= case_action_list case_action */
   160,  /* (50) case_block ::= case_action_list case_otherwise */
   161,  /* (51) case_labels ::= expression */
   161,  /* (52) case_labels ::= case_labels TOK_COMMA expression */
   123,  /* (53) case_otherwise ::= */
   123,  /* (54) case_otherwise ::= TOK_OTHERWISE TOK_COLON statement */
   196,  /* (55) case_statement ::= TOK_CASE expression TOK_OF case_block TOK_END_CASE semicolon */
   197,  /* (56) compound_statement ::= TOK_BEGIN statement_rep TOK_END semicolon */
   130,  /* (57) constant ::= TOK_PI */
   130,  /* (58) constant ::= TOK_E */
   242,  /* (59) constant_body ::= identifier TOK_COLON attribute_type TOK_ASSIGNMENT expression semicolon */
   243,  /* (60) constant_body_list ::= constant_body constant_body_list */
   234,  /* (61) constant_decl ::= TOK_CONSTANT constant_body_list TOK_END_CONSTANT semicolon */
   233,  /* (62) declaration ::= entity_decl */
   233,  /* (63) declaration ::= function_decl */
   233,  /* (64) declaration ::= procedure_decl */
   233,  /* (65) declaration ::= type_decl */
   163,  /* (66) derive_decl ::= */
   163,  /* (67) derive_decl ::= TOK_DERIVE derived_attribute_rep */
   228,  /* (68) derived_attribute ::= attribute_decl TOK_COLON attribute_type initializer semicolon */
   182,  /* (69) derived_attribute_rep ::= derived_attribute */
   182,  /* (70) derived_attribute_rep ::= derived_attribute_rep derived_attribute */
   124,  /* (71) entity_body ::= explicit_attr_list derive_decl inverse_clause unique_clause where_rule_OPT */
   244,  /* (72) entity_decl ::= entity_header subsuper_decl semicolon entity_body TOK_END_ENTITY semicolon */
   248,  /* (73) entity_header ::= TOK_ENTITY TOK_IDENTIFIER */
   249,  /* (74) enumeration_type ::= TOK_ENUMERATION TOK_OF nested_id_list */
   198,  /* (75) escape_statement ::= TOK_ESCAPE semicolon */
   128,  /* (76) attribute_decl ::= TOK_IDENTIFIER */
   128,  /* (77) attribute_decl ::= TOK_SELF TOK_BACKSLASH TOK_IDENTIFIER TOK_DOT TOK_IDENTIFIER */
   181,  /* (78) attribute_decl_list ::= attribute_decl */
   181,  /* (79) attribute_decl_list ::= attribute_decl_list TOK_COMMA attribute_decl */
   189,  /* (80) optional ::= */
   189,  /* (81) optional ::= TOK_OPTIONAL */
   164,  /* (82) explicit_attribute ::= attribute_decl_list TOK_COLON optional attribute_type semicolon */
   251,  /* (83) schema_decl_list ::= schema_decl */
   251,  /* (84) schema_decl_list ::= schema_decl_list schema_decl */
   131,  /* (85) expression ::= simple_expression */
   131,  /* (86) expression ::= expression TOK_AND expression */
   131,  /* (87) expression ::= expression TOK_OR expression */
   131,  /* (88) expression ::= expression TOK_XOR expression */
   131,  /* (89) expression ::= expression TOK_LESS_THAN expression */
   131,  /* (90) expression ::= expression TOK_GREATER_THAN expression */
   131,  /* (91) expression ::= expression TOK_EQUAL expression */
   131,  /* (92) expression ::= expression TOK_LESS_EQUAL expression */
   131,  /* (93) expression ::= expression TOK_GREATER_EQUAL expression */
   131,  /* (94) expression ::= expression TOK_NOT_EQUAL expression */
   131,  /* (95) expression ::= expression TOK_INST_EQUAL expression */
   131,  /* (96) expression ::= expression TOK_INST_NOT_EQUAL expression */
   131,  /* (97) expression ::= expression TOK_IN expression */
   131,  /* (98) expression ::= expression TOK_LIKE expression */
   131,  /* (99) expression ::= simple_expression cardinality_op simple_expression */
   143,  /* (100) simple_expression ::= unary_expression */
   143,  /* (101) simple_expression ::= simple_expression TOK_CONCAT_OP simple_expression */
   143,  /* (102) simple_expression ::= simple_expression TOK_EXP simple_expression */
   143,  /* (103) simple_expression ::= simple_expression TOK_TIMES simple_expression */
   143,  /* (104) simple_expression ::= simple_expression TOK_DIV simple_expression */
   143,  /* (105) simple_expression ::= simple_expression TOK_REAL_DIV simple_expression */
   143,  /* (106) simple_expression ::= simple_expression TOK_MOD simple_expression */
   143,  /* (107) simple_expression ::= simple_expression TOK_PLUS simple_expression */
   143,  /* (108) simple_expression ::= simple_expression TOK_MINUS simple_expression */
   165,  /* (109) expression_list ::= expression */
   165,  /* (110) expression_list ::= expression_list TOK_COMMA expression */
   190,  /* (111) var ::= */
   190,  /* (112) var ::= TOK_VAR */
   166,  /* (113) formal_parameter ::= var id_list TOK_COLON parameter_type */
   167,  /* (114) formal_parameter_list ::= */
   167,  /* (115) formal_parameter_list ::= TOK_LEFT_PAREN formal_parameter_rep TOK_RIGHT_PAREN */
   168,  /* (116) formal_parameter_rep ::= formal_parameter */
   168,  /* (117) formal_parameter_rep ::= formal_parameter_rep semicolon formal_parameter */
   212,  /* (118) parameter_type ::= basic_type */
   212,  /* (119) parameter_type ::= conformant_aggregation */
   212,  /* (120) parameter_type ::= defined_type */
   212,  /* (121) parameter_type ::= generic_type */
   132,  /* (122) function_call ::= function_id actual_parameters */
   245,  /* (123) function_decl ::= function_header action_body TOK_END_FUNCTION semicolon */
   148,  /* (124) function_header ::= fh_lineno fh_push_scope fh_plist TOK_COLON parameter_type semicolon */
   149,  /* (125) fh_lineno ::= TOK_FUNCTION */
   253,  /* (126) fh_push_scope ::= TOK_IDENTIFIER */
   254,  /* (127) fh_plist ::= formal_parameter_list */
   208,  /* (128) function_id ::= TOK_IDENTIFIER */
   208,  /* (129) function_id ::= TOK_BUILTIN_FUNCTION */
   220,  /* (130) conformant_aggregation ::= aggregate_type */
   220,  /* (131) conformant_aggregation ::= TOK_ARRAY TOK_OF optional_or_unique parameter_type */
   220,  /* (132) conformant_aggregation ::= TOK_ARRAY bound_spec TOK_OF optional_or_unique parameter_type */
   220,  /* (133) conformant_aggregation ::= TOK_BAG TOK_OF parameter_type */
   220,  /* (134) conformant_aggregation ::= TOK_BAG bound_spec TOK_OF parameter_type */
   220,  /* (135) conformant_aggregation ::= TOK_LIST TOK_OF unique parameter_type */
   220,  /* (136) conformant_aggregation ::= TOK_LIST bound_spec TOK_OF unique parameter_type */
   220,  /* (137) conformant_aggregation ::= TOK_SET TOK_OF parameter_type */
   220,  /* (138) conformant_aggregation ::= TOK_SET bound_spec TOK_OF parameter_type */
   213,  /* (139) generic_type ::= TOK_GENERIC */
   213,  /* (140) generic_type ::= TOK_GENERIC TOK_COLON TOK_IDENTIFIER */
   169,  /* (141) id_list ::= TOK_IDENTIFIER */
   169,  /* (142) id_list ::= id_list TOK_COMMA TOK_IDENTIFIER */
   135,  /* (143) identifier ::= TOK_SELF */
   135,  /* (144) identifier ::= TOK_QUESTION_MARK */
   135,  /* (145) identifier ::= TOK_IDENTIFIER */
   199,  /* (146) if_statement ::= TOK_IF expression TOK_THEN statement_rep TOK_END_IF semicolon */
   199,  /* (147) if_statement ::= TOK_IF expression TOK_THEN statement_rep TOK_ELSE statement_rep TOK_END_IF semicolon */
   240,  /* (148) include_directive ::= TOK_INCLUDE TOK_STRING_LITERAL semicolon */
   255,  /* (149) increment_control ::= TOK_IDENTIFIER TOK_ASSIGNMENT expression TOK_TO expression by_expression */
   136,  /* (150) initializer ::= TOK_ASSIGNMENT expression */
   256,  /* (151) rename ::= TOK_IDENTIFIER */
   256,  /* (152) rename ::= TOK_IDENTIFIER TOK_AS TOK_IDENTIFIER */
   257,  /* (153) rename_list ::= rename */
   257,  /* (154) rename_list ::= rename_list TOK_COMMA rename */
   259,  /* (155) reference_clause ::= TOK_REFERENCE TOK_FROM TOK_IDENTIFIER semicolon */
   259,  /* (156) reference_clause ::= reference_head parened_rename_list semicolon */
   260,  /* (157) reference_head ::= TOK_REFERENCE TOK_FROM TOK_IDENTIFIER */
   261,  /* (158) use_clause ::= TOK_USE TOK_FROM TOK_IDENTIFIER semicolon */
   261,  /* (159) use_clause ::= use_head parened_rename_list semicolon */
   262,  /* (160) use_head ::= TOK_USE TOK_FROM TOK_IDENTIFIER */
   263,  /* (161) interface_specification ::= use_clause */
   263,  /* (162) interface_specification ::= reference_clause */
   264,  /* (163) interface_specification_list ::= interface_specification_list interface_specification */
   137,  /* (164) interval ::= TOK_LEFT_CURL simple_expression rel_op simple_expression rel_op simple_expression right_curl */
   223,  /* (165) set_or_bag_of_entity ::= defined_type */
   223,  /* (166) set_or_bag_of_entity ::= TOK_SET TOK_OF defined_type */
   223,  /* (167) set_or_bag_of_entity ::= TOK_SET bound_spec TOK_OF defined_type */
   223,  /* (168) set_or_bag_of_entity ::= TOK_BAG bound_spec TOK_OF defined_type */
   223,  /* (169) set_or_bag_of_entity ::= TOK_BAG TOK_OF defined_type */
   179,  /* (170) inverse_attr_list ::= inverse_attr */
   179,  /* (171) inverse_attr_list ::= inverse_attr_list inverse_attr */
   227,  /* (172) inverse_attr ::= attribute_decl TOK_COLON set_or_bag_of_entity TOK_FOR TOK_IDENTIFIER semicolon */
   180,  /* (173) inverse_clause ::= */
   180,  /* (174) inverse_clause ::= TOK_INVERSE inverse_attr_list */
   226,  /* (175) bound_spec ::= TOK_LEFT_BRACKET expression TOK_COLON expression TOK_RIGHT_BRACKET */
   221,  /* (176) list_type ::= TOK_LIST bound_spec TOK_OF unique attribute_type */
   221,  /* (177) list_type ::= TOK_LIST TOK_OF unique attribute_type */
   138,  /* (178) literal ::= TOK_INTEGER_LITERAL */
   138,  /* (179) literal ::= TOK_REAL_LITERAL */
   138,  /* (180) literal ::= TOK_STRING_LITERAL */
   138,  /* (181) literal ::= TOK_STRING_LITERAL_ENCODED */
   138,  /* (182) literal ::= TOK_LOGICAL_LITERAL */
   138,  /* (183) literal ::= TOK_BINARY_LITERAL */
   138,  /* (184) literal ::= constant */
   139,  /* (185) local_initializer ::= TOK_ASSIGNMENT expression */
   266,  /* (186) local_variable ::= id_list TOK_COLON parameter_type semicolon */
   266,  /* (187) local_variable ::= id_list TOK_COLON parameter_type local_initializer semicolon */
   267,  /* (188) local_body ::= local_variable local_body */
   268,  /* (189) local_decl_rules_on ::= */
   269,  /* (190) local_decl_rules_off ::= */
   211,  /* (191) defined_type ::= TOK_IDENTIFIER */
   170,  /* (192) defined_type_list ::= defined_type */
   170,  /* (193) defined_type_list ::= defined_type_list TOK_COMMA defined_type */
   171,  /* (194) nested_id_list ::= TOK_LEFT_PAREN id_list TOK_RIGHT_PAREN */
   270,  /* (195) oneof_op ::= TOK_ONEOF */
   187,  /* (196) optional_or_unique ::= */
   187,  /* (197) optional_or_unique ::= TOK_OPTIONAL */
   187,  /* (198) optional_or_unique ::= TOK_UNIQUE */
   187,  /* (199) optional_or_unique ::= TOK_OPTIONAL TOK_UNIQUE */
   187,  /* (200) optional_or_unique ::= TOK_UNIQUE TOK_OPTIONAL */
   188,  /* (201) optional_fixed ::= */
   188,  /* (202) optional_fixed ::= TOK_FIXED */
   140,  /* (203) precision_spec ::= */
   140,  /* (204) precision_spec ::= TOK_LEFT_PAREN expression TOK_RIGHT_PAREN */
   200,  /* (205) proc_call_statement ::= procedure_id actual_parameters semicolon */
   200,  /* (206) proc_call_statement ::= procedure_id semicolon */
   246,  /* (207) procedure_decl ::= procedure_header action_body TOK_END_PROCEDURE semicolon */
   153,  /* (208) procedure_header ::= TOK_PROCEDURE ph_get_line ph_push_scope formal_parameter_list semicolon */
   271,  /* (209) ph_push_scope ::= TOK_IDENTIFIER */
   154,  /* (210) ph_get_line ::= */
   209,  /* (211) procedure_id ::= TOK_IDENTIFIER */
   209,  /* (212) procedure_id ::= TOK_BUILTIN_PROCEDURE */
   134,  /* (213) group_ref ::= TOK_BACKSLASH TOK_IDENTIFIER */
   193,  /* (214) qualifier ::= TOK_DOT TOK_IDENTIFIER */
   193,  /* (215) qualifier ::= TOK_BACKSLASH TOK_IDENTIFIER */
   193,  /* (216) qualifier ::= TOK_LEFT_BRACKET simple_expression TOK_RIGHT_BRACKET */
   193,  /* (217) qualifier ::= TOK_LEFT_BRACKET simple_expression TOK_COLON simple_expression TOK_RIGHT_BRACKET */
   141,  /* (218) query_expression ::= query_start expression TOK_RIGHT_PAREN */
   142,  /* (219) query_start ::= TOK_QUERY TOK_LEFT_PAREN TOK_IDENTIFIER TOK_ALL_IN expression TOK_SUCH_THAT */
   186,  /* (220) rel_op ::= TOK_LESS_THAN */
   186,  /* (221) rel_op ::= TOK_GREATER_THAN */
   186,  /* (222) rel_op ::= TOK_EQUAL */
   186,  /* (223) rel_op ::= TOK_LESS_EQUAL */
   186,  /* (224) rel_op ::= TOK_GREATER_EQUAL */
   186,  /* (225) rel_op ::= TOK_NOT_EQUAL */
   186,  /* (226) rel_op ::= TOK_INST_EQUAL */
   186,  /* (227) rel_op ::= TOK_INST_NOT_EQUAL */
   201,  /* (228) repeat_statement ::= TOK_REPEAT increment_control while_control until_control semicolon statement_rep TOK_END_REPEAT semicolon */
   201,  /* (229) repeat_statement ::= TOK_REPEAT while_control until_control semicolon statement_rep TOK_END_REPEAT semicolon */
   202,  /* (230) return_statement ::= TOK_RETURN semicolon */
   202,  /* (231) return_statement ::= TOK_RETURN TOK_LEFT_PAREN expression TOK_RIGHT_PAREN semicolon */
   265,  /* (232) right_curl ::= TOK_RIGHT_CURL */
   241,  /* (233) rule_decl ::= rule_header action_body where_rule TOK_END_RULE semicolon */
   229,  /* (234) rule_formal_parameter ::= TOK_IDENTIFIER */
   184,  /* (235) rule_formal_parameter_list ::= rule_formal_parameter */
   184,  /* (236) rule_formal_parameter_list ::= rule_formal_parameter_list TOK_COMMA rule_formal_parameter */
   150,  /* (237) rule_header ::= rh_start rule_formal_parameter_list TOK_RIGHT_PAREN semicolon */
   151,  /* (238) rh_start ::= TOK_RULE rh_get_line TOK_IDENTIFIER TOK_FOR TOK_LEFT_PAREN */
   152,  /* (239) rh_get_line ::= */
   272,  /* (240) schema_body ::= interface_specification_list block_list */
   272,  /* (241) schema_body ::= interface_specification_list constant_decl block_list */
   252,  /* (242) schema_decl ::= schema_header schema_body TOK_END_SCHEMA semicolon */
   252,  /* (243) schema_decl ::= include_directive */
   273,  /* (244) schema_header ::= TOK_SCHEMA TOK_IDENTIFIER semicolon */
   215,  /* (245) select_type ::= TOK_SELECT TOK_LEFT_PAREN defined_type_list TOK_RIGHT_PAREN */
   236,  /* (246) semicolon ::= TOK_SEMICOLON */
   222,  /* (247) set_type ::= TOK_SET bound_spec TOK_OF attribute_type */
   222,  /* (248) set_type ::= TOK_SET TOK_OF attribute_type */
   203,  /* (249) skip_statement ::= TOK_SKIP semicolon */
   204,  /* (250) statement ::= alias_statement */
   204,  /* (251) statement ::= assignment_statement */
   204,  /* (252) statement ::= case_statement */
   204,  /* (253) statement ::= compound_statement */
   204,  /* (254) statement ::= escape_statement */
   204,  /* (255) statement ::= if_statement */
   204,  /* (256) statement ::= proc_call_statement */
   204,  /* (257) statement ::= repeat_statement */
   204,  /* (258) statement ::= return_statement */
   204,  /* (259) statement ::= skip_statement */
   172,  /* (260) statement_rep ::= */
   172,  /* (261) statement_rep ::= semicolon statement_rep */
   172,  /* (262) statement_rep ::= statement statement_rep */
   205,  /* (263) subsuper_decl ::= */
   205,  /* (264) subsuper_decl ::= supertype_decl */
   205,  /* (265) subsuper_decl ::= subtype_decl */
   205,  /* (266) subsuper_decl ::= supertype_decl subtype_decl */
   173,  /* (267) subtype_decl ::= TOK_SUBTYPE TOK_OF TOK_LEFT_PAREN defined_type_list TOK_RIGHT_PAREN */
   206,  /* (268) supertype_decl ::= TOK_ABSTRACT TOK_SUPERTYPE */
   206,  /* (269) supertype_decl ::= TOK_SUPERTYPE TOK_OF TOK_LEFT_PAREN supertype_expression TOK_RIGHT_PAREN */
   206,  /* (270) supertype_decl ::= TOK_ABSTRACT TOK_SUPERTYPE TOK_OF TOK_LEFT_PAREN supertype_expression TOK_RIGHT_PAREN */
   145,  /* (271) supertype_expression ::= supertype_factor */
   145,  /* (272) supertype_expression ::= supertype_expression TOK_AND supertype_factor */
   145,  /* (273) supertype_expression ::= supertype_expression TOK_ANDOR supertype_factor */
   176,  /* (274) supertype_expression_list ::= supertype_expression */
   176,  /* (275) supertype_expression_list ::= supertype_expression_list TOK_COMMA supertype_expression */
   207,  /* (276) supertype_factor ::= identifier */
   207,  /* (277) supertype_factor ::= oneof_op TOK_LEFT_PAREN supertype_expression_list TOK_RIGHT_PAREN */
   207,  /* (278) supertype_factor ::= TOK_LEFT_PAREN supertype_expression TOK_RIGHT_PAREN */
   224,  /* (279) type ::= aggregation_type */
   224,  /* (280) type ::= basic_type */
   224,  /* (281) type ::= defined_type */
   224,  /* (282) type ::= select_type */
   274,  /* (283) type_item_body ::= enumeration_type */
   274,  /* (284) type_item_body ::= type */
   276,  /* (285) ti_start ::= TOK_IDENTIFIER TOK_EQUAL */
   247,  /* (286) type_decl ::= td_start TOK_END_TYPE semicolon */
   277,  /* (287) td_start ::= TOK_TYPE type_item where_rule_OPT */
   133,  /* (288) general_ref ::= assignable group_ref */
   133,  /* (289) general_ref ::= assignable */
   144,  /* (290) unary_expression ::= aggregate_initializer */
   144,  /* (291) unary_expression ::= unary_expression qualifier */
   144,  /* (292) unary_expression ::= literal */
   144,  /* (293) unary_expression ::= function_call */
   144,  /* (294) unary_expression ::= identifier */
   144,  /* (295) unary_expression ::= TOK_LEFT_PAREN expression TOK_RIGHT_PAREN */
   144,  /* (296) unary_expression ::= interval */
   144,  /* (297) unary_expression ::= query_expression */
   144,  /* (298) unary_expression ::= TOK_NOT unary_expression */
   144,  /* (299) unary_expression ::= TOK_PLUS unary_expression */
   144,  /* (300) unary_expression ::= TOK_MINUS unary_expression */
   191,  /* (301) unique ::= */
   191,  /* (302) unique ::= TOK_UNIQUE */
   192,  /* (303) qualified_attr ::= attribute_decl */
   185,  /* (304) qualified_attr_list ::= qualified_attr */
   185,  /* (305) qualified_attr_list ::= qualified_attr_list TOK_COMMA qualified_attr */
   178,  /* (306) labelled_attrib_list ::= qualified_attr_list semicolon */
   178,  /* (307) labelled_attrib_list ::= TOK_IDENTIFIER TOK_COLON qualified_attr_list semicolon */
   177,  /* (308) labelled_attrib_list_list ::= labelled_attrib_list */
   177,  /* (309) labelled_attrib_list_list ::= labelled_attrib_list_list labelled_attrib_list */
   183,  /* (310) unique_clause ::= */
   183,  /* (311) unique_clause ::= TOK_UNIQUE labelled_attrib_list_list */
   146,  /* (312) until_control ::= */
   146,  /* (313) until_control ::= TOK_UNTIL expression */
   230,  /* (314) where_clause ::= expression semicolon */
   230,  /* (315) where_clause ::= TOK_IDENTIFIER TOK_COLON expression semicolon */
   162,  /* (316) where_clause_list ::= where_clause */
   162,  /* (317) where_clause_list ::= where_clause_list where_clause */
   174,  /* (318) where_rule ::= TOK_WHERE where_clause_list */
   175,  /* (319) where_rule_OPT ::= */
   175,  /* (320) where_rule_OPT ::= where_rule */
   147,  /* (321) while_control ::= */
   147,  /* (322) while_control ::= TOK_WHILE expression */
   231,  /* (323) action_body_item_rep ::= */
   238,  /* (324) block_list ::= */
   243,  /* (325) constant_body_list ::= */
   250,  /* (326) express_file ::= schema_decl_list */
   258,  /* (327) parened_rename_list ::= TOK_LEFT_PAREN rename_list TOK_RIGHT_PAREN */
   264,  /* (328) interface_specification_list ::= */
   267,  /* (329) local_body ::= */
   235,  /* (330) local_decl ::= TOK_LOCAL local_decl_rules_on local_body TOK_END_LOCAL semicolon local_decl_rules_off */
   275,  /* (331) type_item ::= ti_start type_item_body semicolon */
};

/* For rule J, yyRuleInfoNRhs[J] contains the negative of the number
** of symbols on the right-hand side of that rule. */
static const signed char yyRuleInfoNRhs[] = {
   -2,  /* (0) action_body ::= action_body_item_rep statement_rep */
   -1,  /* (1) action_body_item ::= declaration */
   -1,  /* (2) action_body_item ::= constant_decl */
   -1,  /* (3) action_body_item ::= local_decl */
   -2,  /* (4) action_body_item_rep ::= action_body_item action_body_item_rep */
   -3,  /* (5) actual_parameters ::= TOK_LEFT_PAREN expression_list TOK_RIGHT_PAREN */
   -2,  /* (6) actual_parameters ::= TOK_LEFT_PAREN TOK_RIGHT_PAREN */
   -2,  /* (7) aggregate_initializer ::= TOK_LEFT_BRACKET TOK_RIGHT_BRACKET */
   -3,  /* (8) aggregate_initializer ::= TOK_LEFT_BRACKET aggregate_init_body TOK_RIGHT_BRACKET */
   -1,  /* (9) aggregate_init_element ::= expression */
   -1,  /* (10) aggregate_init_body ::= aggregate_init_element */
   -3,  /* (11) aggregate_init_body ::= aggregate_init_element TOK_COLON expression */
   -3,  /* (12) aggregate_init_body ::= aggregate_init_body TOK_COMMA aggregate_init_element */
   -5,  /* (13) aggregate_init_body ::= aggregate_init_body TOK_COMMA aggregate_init_element TOK_COLON expression */
   -3,  /* (14) aggregate_type ::= TOK_AGGREGATE TOK_OF parameter_type */
   -5,  /* (15) aggregate_type ::= TOK_AGGREGATE TOK_COLON TOK_IDENTIFIER TOK_OF parameter_type */
   -1,  /* (16) aggregation_type ::= array_type */
   -1,  /* (17) aggregation_type ::= bag_type */
   -1,  /* (18) aggregation_type ::= list_type */
   -1,  /* (19) aggregation_type ::= set_type */
   -9,  /* (20) alias_statement ::= TOK_ALIAS TOK_IDENTIFIER TOK_FOR general_ref semicolon alias_push_scope statement_rep TOK_END_ALIAS semicolon */
    0,  /* (21) alias_push_scope ::= */
   -5,  /* (22) array_type ::= TOK_ARRAY bound_spec TOK_OF optional_or_unique attribute_type */
   -2,  /* (23) assignable ::= assignable qualifier */
   -1,  /* (24) assignable ::= identifier */
   -4,  /* (25) assignment_statement ::= assignable TOK_ASSIGNMENT expression semicolon */
   -1,  /* (26) attribute_type ::= aggregation_type */
   -1,  /* (27) attribute_type ::= basic_type */
   -1,  /* (28) attribute_type ::= defined_type */
    0,  /* (29) explicit_attr_list ::= */
   -2,  /* (30) explicit_attr_list ::= explicit_attr_list explicit_attribute */
   -4,  /* (31) bag_type ::= TOK_BAG bound_spec TOK_OF attribute_type */
   -3,  /* (32) bag_type ::= TOK_BAG TOK_OF attribute_type */
   -1,  /* (33) basic_type ::= TOK_BOOLEAN */
   -2,  /* (34) basic_type ::= TOK_INTEGER precision_spec */
   -2,  /* (35) basic_type ::= TOK_REAL precision_spec */
   -1,  /* (36) basic_type ::= TOK_NUMBER */
   -1,  /* (37) basic_type ::= TOK_LOGICAL */
   -3,  /* (38) basic_type ::= TOK_BINARY precision_spec optional_fixed */
   -3,  /* (39) basic_type ::= TOK_STRING precision_spec optional_fixed */
   -2,  /* (40) block_list ::= block_list block_member */
   -1,  /* (41) block_member ::= declaration */
   -1,  /* (42) block_member ::= include_directive */
   -1,  /* (43) block_member ::= rule_decl */
    0,  /* (44) by_expression ::= */
   -2,  /* (45) by_expression ::= TOK_BY expression */
   -5,  /* (46) cardinality_op ::= TOK_LEFT_CURL expression TOK_COLON expression TOK_RIGHT_CURL */
   -3,  /* (47) case_action ::= case_labels TOK_COLON statement */
    0,  /* (48) case_action_list ::= */
   -2,  /* (49) case_action_list ::= case_action_list case_action */
   -2,  /* (50) case_block ::= case_action_list case_otherwise */
   -1,  /* (51) case_labels ::= expression */
   -3,  /* (52) case_labels ::= case_labels TOK_COMMA expression */
    0,  /* (53) case_otherwise ::= */
   -3,  /* (54) case_otherwise ::= TOK_OTHERWISE TOK_COLON statement */
   -6,  /* (55) case_statement ::= TOK_CASE expression TOK_OF case_block TOK_END_CASE semicolon */
   -4,  /* (56) compound_statement ::= TOK_BEGIN statement_rep TOK_END semicolon */
   -1,  /* (57) constant ::= TOK_PI */
   -1,  /* (58) constant ::= TOK_E */
   -6,  /* (59) constant_body ::= identifier TOK_COLON attribute_type TOK_ASSIGNMENT expression semicolon */
   -2,  /* (60) constant_body_list ::= constant_body constant_body_list */
   -4,  /* (61) constant_decl ::= TOK_CONSTANT constant_body_list TOK_END_CONSTANT semicolon */
   -1,  /* (62) declaration ::= entity_decl */
   -1,  /* (63) declaration ::= function_decl */
   -1,  /* (64) declaration ::= procedure_decl */
   -1,  /* (65) declaration ::= type_decl */
    0,  /* (66) derive_decl ::= */
   -2,  /* (67) derive_decl ::= TOK_DERIVE derived_attribute_rep */
   -5,  /* (68) derived_attribute ::= attribute_decl TOK_COLON attribute_type initializer semicolon */
   -1,  /* (69) derived_attribute_rep ::= derived_attribute */
   -2,  /* (70) derived_attribute_rep ::= derived_attribute_rep derived_attribute */
   -5,  /* (71) entity_body ::= explicit_attr_list derive_decl inverse_clause unique_clause where_rule_OPT */
   -6,  /* (72) entity_decl ::= entity_header subsuper_decl semicolon entity_body TOK_END_ENTITY semicolon */
   -2,  /* (73) entity_header ::= TOK_ENTITY TOK_IDENTIFIER */
   -3,  /* (74) enumeration_type ::= TOK_ENUMERATION TOK_OF nested_id_list */
   -2,  /* (75) escape_statement ::= TOK_ESCAPE semicolon */
   -1,  /* (76) attribute_decl ::= TOK_IDENTIFIER */
   -5,  /* (77) attribute_decl ::= TOK_SELF TOK_BACKSLASH TOK_IDENTIFIER TOK_DOT TOK_IDENTIFIER */
   -1,  /* (78) attribute_decl_list ::= attribute_decl */
   -3,  /* (79) attribute_decl_list ::= attribute_decl_list TOK_COMMA attribute_decl */
    0,  /* (80) optional ::= */
   -1,  /* (81) optional ::= TOK_OPTIONAL */
   -5,  /* (82) explicit_attribute ::= attribute_decl_list TOK_COLON optional attribute_type semicolon */
   -1,  /* (83) schema_decl_list ::= schema_decl */
   -2,  /* (84) schema_decl_list ::= schema_decl_list schema_decl */
   -1,  /* (85) expression ::= simple_expression */
   -3,  /* (86) expression ::= expression TOK_AND expression */
   -3,  /* (87) expression ::= expression TOK_OR expression */
   -3,  /* (88) expression ::= expression TOK_XOR expression */
   -3,  /* (89) expression ::= expression TOK_LESS_THAN expression */
   -3,  /* (90) expression ::= expression TOK_GREATER_THAN expression */
   -3,  /* (91) expression ::= expression TOK_EQUAL expression */
   -3,  /* (92) expression ::= expression TOK_LESS_EQUAL expression */
   -3,  /* (93) expression ::= expression TOK_GREATER_EQUAL expression */
   -3,  /* (94) expression ::= expression TOK_NOT_EQUAL expression */
   -3,  /* (95) expression ::= expression TOK_INST_EQUAL expression */
   -3,  /* (96) expression ::= expression TOK_INST_NOT_EQUAL expression */
   -3,  /* (97) expression ::= expression TOK_IN expression */
   -3,  /* (98) expression ::= expression TOK_LIKE expression */
   -3,  /* (99) expression ::= simple_expression cardinality_op simple_expression */
   -1,  /* (100) simple_expression ::= unary_expression */
   -3,  /* (101) simple_expression ::= simple_expression TOK_CONCAT_OP simple_expression */
   -3,  /* (102) simple_expression ::= simple_expression TOK_EXP simple_expression */
   -3,  /* (103) simple_expression ::= simple_expression TOK_TIMES simple_expression */
   -3,  /* (104) simple_expression ::= simple_expression TOK_DIV simple_expression */
   -3,  /* (105) simple_expression ::= simple_expression TOK_REAL_DIV simple_expression */
   -3,  /* (106) simple_expression ::= simple_expression TOK_MOD simple_expression */
   -3,  /* (107) simple_expression ::= simple_expression TOK_PLUS simple_expression */
   -3,  /* (108) simple_expression ::= simple_expression TOK_MINUS simple_expression */
   -1,  /* (109) expression_list ::= expression */
   -3,  /* (110) expression_list ::= expression_list TOK_COMMA expression */
    0,  /* (111) var ::= */
   -1,  /* (112) var ::= TOK_VAR */
   -4,  /* (113) formal_parameter ::= var id_list TOK_COLON parameter_type */
    0,  /* (114) formal_parameter_list ::= */
   -3,  /* (115) formal_parameter_list ::= TOK_LEFT_PAREN formal_parameter_rep TOK_RIGHT_PAREN */
   -1,  /* (116) formal_parameter_rep ::= formal_parameter */
   -3,  /* (117) formal_parameter_rep ::= formal_parameter_rep semicolon formal_parameter */
   -1,  /* (118) parameter_type ::= basic_type */
   -1,  /* (119) parameter_type ::= conformant_aggregation */
   -1,  /* (120) parameter_type ::= defined_type */
   -1,  /* (121) parameter_type ::= generic_type */
   -2,  /* (122) function_call ::= function_id actual_parameters */
   -4,  /* (123) function_decl ::= function_header action_body TOK_END_FUNCTION semicolon */
   -6,  /* (124) function_header ::= fh_lineno fh_push_scope fh_plist TOK_COLON parameter_type semicolon */
   -1,  /* (125) fh_lineno ::= TOK_FUNCTION */
   -1,  /* (126) fh_push_scope ::= TOK_IDENTIFIER */
   -1,  /* (127) fh_plist ::= formal_parameter_list */
   -1,  /* (128) function_id ::= TOK_IDENTIFIER */
   -1,  /* (129) function_id ::= TOK_BUILTIN_FUNCTION */
   -1,  /* (130) conformant_aggregation ::= aggregate_type */
   -4,  /* (131) conformant_aggregation ::= TOK_ARRAY TOK_OF optional_or_unique parameter_type */
   -5,  /* (132) conformant_aggregation ::= TOK_ARRAY bound_spec TOK_OF optional_or_unique parameter_type */
   -3,  /* (133) conformant_aggregation ::= TOK_BAG TOK_OF parameter_type */
   -4,  /* (134) conformant_aggregation ::= TOK_BAG bound_spec TOK_OF parameter_type */
   -4,  /* (135) conformant_aggregation ::= TOK_LIST TOK_OF unique parameter_type */
   -5,  /* (136) conformant_aggregation ::= TOK_LIST bound_spec TOK_OF unique parameter_type */
   -3,  /* (137) conformant_aggregation ::= TOK_SET TOK_OF parameter_type */
   -4,  /* (138) conformant_aggregation ::= TOK_SET bound_spec TOK_OF parameter_type */
   -1,  /* (139) generic_type ::= TOK_GENERIC */
   -3,  /* (140) generic_type ::= TOK_GENERIC TOK_COLON TOK_IDENTIFIER */
   -1,  /* (141) id_list ::= TOK_IDENTIFIER */
   -3,  /* (142) id_list ::= id_list TOK_COMMA TOK_IDENTIFIER */
   -1,  /* (143) identifier ::= TOK_SELF */
   -1,  /* (144) identifier ::= TOK_QUESTION_MARK */
   -1,  /* (145) identifier ::= TOK_IDENTIFIER */
   -6,  /* (146) if_statement ::= TOK_IF expression TOK_THEN statement_rep TOK_END_IF semicolon */
   -8,  /* (147) if_statement ::= TOK_IF expression TOK_THEN statement_rep TOK_ELSE statement_rep TOK_END_IF semicolon */
   -3,  /* (148) include_directive ::= TOK_INCLUDE TOK_STRING_LITERAL semicolon */
   -6,  /* (149) increment_control ::= TOK_IDENTIFIER TOK_ASSIGNMENT expression TOK_TO expression by_expression */
   -2,  /* (150) initializer ::= TOK_ASSIGNMENT expression */
   -1,  /* (151) rename ::= TOK_IDENTIFIER */
   -3,  /* (152) rename ::= TOK_IDENTIFIER TOK_AS TOK_IDENTIFIER */
   -1,  /* (153) rename_list ::= rename */
   -3,  /* (154) rename_list ::= rename_list TOK_COMMA rename */
   -4,  /* (155) reference_clause ::= TOK_REFERENCE TOK_FROM TOK_IDENTIFIER semicolon */
   -3,  /* (156) reference_clause ::= reference_head parened_rename_list semicolon */
   -3,  /* (157) reference_head ::= TOK_REFERENCE TOK_FROM TOK_IDENTIFIER */
   -4,  /* (158) use_clause ::= TOK_USE TOK_FROM TOK_IDENTIFIER semicolon */
   -3,  /* (159) use_clause ::= use_head parened_rename_list semicolon */
   -3,  /* (160) use_head ::= TOK_USE TOK_FROM TOK_IDENTIFIER */
   -1,  /* (161) interface_specification ::= use_clause */
   -1,  /* (162) interface_specification ::= reference_clause */
   -2,  /* (163) interface_specification_list ::= interface_specification_list interface_specification */
   -7,  /* (164) interval ::= TOK_LEFT_CURL simple_expression rel_op simple_expression rel_op simple_expression right_curl */
   -1,  /* (165) set_or_bag_of_entity ::= defined_type */
   -3,  /* (166) set_or_bag_of_entity ::= TOK_SET TOK_OF defined_type */
   -4,  /* (167) set_or_bag_of_entity ::= TOK_SET bound_spec TOK_OF defined_type */
   -4,  /* (168) set_or_bag_of_entity ::= TOK_BAG bound_spec TOK_OF defined_type */
   -3,  /* (169) set_or_bag_of_entity ::= TOK_BAG TOK_OF defined_type */
   -1,  /* (170) inverse_attr_list ::= inverse_attr */
   -2,  /* (171) inverse_attr_list ::= inverse_attr_list inverse_attr */
   -6,  /* (172) inverse_attr ::= attribute_decl TOK_COLON set_or_bag_of_entity TOK_FOR TOK_IDENTIFIER semicolon */
    0,  /* (173) inverse_clause ::= */
   -2,  /* (174) inverse_clause ::= TOK_INVERSE inverse_attr_list */
   -5,  /* (175) bound_spec ::= TOK_LEFT_BRACKET expression TOK_COLON expression TOK_RIGHT_BRACKET */
   -5,  /* (176) list_type ::= TOK_LIST bound_spec TOK_OF unique attribute_type */
   -4,  /* (177) list_type ::= TOK_LIST TOK_OF unique attribute_type */
   -1,  /* (178) literal ::= TOK_INTEGER_LITERAL */
   -1,  /* (179) literal ::= TOK_REAL_LITERAL */
   -1,  /* (180) literal ::= TOK_STRING_LITERAL */
   -1,  /* (181) literal ::= TOK_STRING_LITERAL_ENCODED */
   -1,  /* (182) literal ::= TOK_LOGICAL_LITERAL */
   -1,  /* (183) literal ::= TOK_BINARY_LITERAL */
   -1,  /* (184) literal ::= constant */
   -2,  /* (185) local_initializer ::= TOK_ASSIGNMENT expression */
   -4,  /* (186) local_variable ::= id_list TOK_COLON parameter_type semicolon */
   -5,  /* (187) local_variable ::= id_list TOK_COLON parameter_type local_initializer semicolon */
   -2,  /* (188) local_body ::= local_variable local_body */
    0,  /* (189) local_decl_rules_on ::= */
    0,  /* (190) local_decl_rules_off ::= */
   -1,  /* (191) defined_type ::= TOK_IDENTIFIER */
   -1,  /* (192) defined_type_list ::= defined_type */
   -3,  /* (193) defined_type_list ::= defined_type_list TOK_COMMA defined_type */
   -3,  /* (194) nested_id_list ::= TOK_LEFT_PAREN id_list TOK_RIGHT_PAREN */
   -1,  /* (195) oneof_op ::= TOK_ONEOF */
    0,  /* (196) optional_or_unique ::= */
   -1,  /* (197) optional_or_unique ::= TOK_OPTIONAL */
   -1,  /* (198) optional_or_unique ::= TOK_UNIQUE */
   -2,  /* (199) optional_or_unique ::= TOK_OPTIONAL TOK_UNIQUE */
   -2,  /* (200) optional_or_unique ::= TOK_UNIQUE TOK_OPTIONAL */
    0,  /* (201) optional_fixed ::= */
   -1,  /* (202) optional_fixed ::= TOK_FIXED */
    0,  /* (203) precision_spec ::= */
   -3,  /* (204) precision_spec ::= TOK_LEFT_PAREN expression TOK_RIGHT_PAREN */
   -3,  /* (205) proc_call_statement ::= procedure_id actual_parameters semicolon */
   -2,  /* (206) proc_call_statement ::= procedure_id semicolon */
   -4,  /* (207) procedure_decl ::= procedure_header action_body TOK_END_PROCEDURE semicolon */
   -5,  /* (208) procedure_header ::= TOK_PROCEDURE ph_get_line ph_push_scope formal_parameter_list semicolon */
   -1,  /* (209) ph_push_scope ::= TOK_IDENTIFIER */
    0,  /* (210) ph_get_line ::= */
   -1,  /* (211) procedure_id ::= TOK_IDENTIFIER */
   -1,  /* (212) procedure_id ::= TOK_BUILTIN_PROCEDURE */
   -2,  /* (213) group_ref ::= TOK_BACKSLASH TOK_IDENTIFIER */
   -2,  /* (214) qualifier ::= TOK_DOT TOK_IDENTIFIER */
   -2,  /* (215) qualifier ::= TOK_BACKSLASH TOK_IDENTIFIER */
   -3,  /* (216) qualifier ::= TOK_LEFT_BRACKET simple_expression TOK_RIGHT_BRACKET */
   -5,  /* (217) qualifier ::= TOK_LEFT_BRACKET simple_expression TOK_COLON simple_expression TOK_RIGHT_BRACKET */
   -3,  /* (218) query_expression ::= query_start expression TOK_RIGHT_PAREN */
   -6,  /* (219) query_start ::= TOK_QUERY TOK_LEFT_PAREN TOK_IDENTIFIER TOK_ALL_IN expression TOK_SUCH_THAT */
   -1,  /* (220) rel_op ::= TOK_LESS_THAN */
   -1,  /* (221) rel_op ::= TOK_GREATER_THAN */
   -1,  /* (222) rel_op ::= TOK_EQUAL */
   -1,  /* (223) rel_op ::= TOK_LESS_EQUAL */
   -1,  /* (224) rel_op ::= TOK_GREATER_EQUAL */
   -1,  /* (225) rel_op ::= TOK_NOT_EQUAL */
   -1,  /* (226) rel_op ::= TOK_INST_EQUAL */
   -1,  /* (227) rel_op ::= TOK_INST_NOT_EQUAL */
   -8,  /* (228) repeat_statement ::= TOK_REPEAT increment_control while_control until_control semicolon statement_rep TOK_END_REPEAT semicolon */
   -7,  /* (229) repeat_statement ::= TOK_REPEAT while_control until_control semicolon statement_rep TOK_END_REPEAT semicolon */
   -2,  /* (230) return_statement ::= TOK_RETURN semicolon */
   -5,  /* (231) return_statement ::= TOK_RETURN TOK_LEFT_PAREN expression TOK_RIGHT_PAREN semicolon */
   -1,  /* (232) right_curl ::= TOK_RIGHT_CURL */
   -5,  /* (233) rule_decl ::= rule_header action_body where_rule TOK_END_RULE semicolon */
   -1,  /* (234) rule_formal_parameter ::= TOK_IDENTIFIER */
   -1,  /* (235) rule_formal_parameter_list ::= rule_formal_parameter */
   -3,  /* (236) rule_formal_parameter_list ::= rule_formal_parameter_list TOK_COMMA rule_formal_parameter */
   -4,  /* (237) rule_header ::= rh_start rule_formal_parameter_list TOK_RIGHT_PAREN semicolon */
   -5,  /* (238) rh_start ::= TOK_RULE rh_get_line TOK_IDENTIFIER TOK_FOR TOK_LEFT_PAREN */
    0,  /* (239) rh_get_line ::= */
   -2,  /* (240) schema_body ::= interface_specification_list block_list */
   -3,  /* (241) schema_body ::= interface_specification_list constant_decl block_list */
   -4,  /* (242) schema_decl ::= schema_header schema_body TOK_END_SCHEMA semicolon */
   -1,  /* (243) schema_decl ::= include_directive */
   -3,  /* (244) schema_header ::= TOK_SCHEMA TOK_IDENTIFIER semicolon */
   -4,  /* (245) select_type ::= TOK_SELECT TOK_LEFT_PAREN defined_type_list TOK_RIGHT_PAREN */
   -1,  /* (246) semicolon ::= TOK_SEMICOLON */
   -4,  /* (247) set_type ::= TOK_SET bound_spec TOK_OF attribute_type */
   -3,  /* (248) set_type ::= TOK_SET TOK_OF attribute_type */
   -2,  /* (249) skip_statement ::= TOK_SKIP semicolon */
   -1,  /* (250) statement ::= alias_statement */
   -1,  /* (251) statement ::= assignment_statement */
   -1,  /* (252) statement ::= case_statement */
   -1,  /* (253) statement ::= compound_statement */
   -1,  /* (254) statement ::= escape_statement */
   -1,  /* (255) statement ::= if_statement */
   -1,  /* (256) statement ::= proc_call_statement */
   -1,  /* (257) statement ::= repeat_statement */
   -1,  /* (258) statement ::= return_statement */
   -1,  /* (259) statement ::= skip_statement */
    0,  /* (260) statement_rep ::= */
   -2,  /* (261) statement_rep ::= semicolon statement_rep */
   -2,  /* (262) statement_rep ::= statement statement_rep */
    0,  /* (263) subsuper_decl ::= */
   -1,  /* (264) subsuper_decl ::= supertype_decl */
   -1,  /* (265) subsuper_decl ::= subtype_decl */
   -2,  /* (266) subsuper_decl ::= supertype_decl subtype_decl */
   -5,  /* (267) subtype_decl ::= TOK_SUBTYPE TOK_OF TOK_LEFT_PAREN defined_type_list TOK_RIGHT_PAREN */
   -2,  /* (268) supertype_decl ::= TOK_ABSTRACT TOK_SUPERTYPE */
   -5,  /* (269) supertype_decl ::= TOK_SUPERTYPE TOK_OF TOK_LEFT_PAREN supertype_expression TOK_RIGHT_PAREN */
   -6,  /* (270) supertype_decl ::= TOK_ABSTRACT TOK_SUPERTYPE TOK_OF TOK_LEFT_PAREN supertype_expression TOK_RIGHT_PAREN */
   -1,  /* (271) supertype_expression ::= supertype_factor */
   -3,  /* (272) supertype_expression ::= supertype_expression TOK_AND supertype_factor */
   -3,  /* (273) supertype_expression ::= supertype_expression TOK_ANDOR supertype_factor */
   -1,  /* (274) supertype_expression_list ::= supertype_expression */
   -3,  /* (275) supertype_expression_list ::= supertype_expression_list TOK_COMMA supertype_expression */
   -1,  /* (276) supertype_factor ::= identifier */
   -4,  /* (277) supertype_factor ::= oneof_op TOK_LEFT_PAREN supertype_expression_list TOK_RIGHT_PAREN */
   -3,  /* (278) supertype_factor ::= TOK_LEFT_PAREN supertype_expression TOK_RIGHT_PAREN */
   -1,  /* (279) type ::= aggregation_type */
   -1,  /* (280) type ::= basic_type */
   -1,  /* (281) type ::= defined_type */
   -1,  /* (282) type ::= select_type */
   -1,  /* (283) type_item_body ::= enumeration_type */
   -1,  /* (284) type_item_body ::= type */
   -2,  /* (285) ti_start ::= TOK_IDENTIFIER TOK_EQUAL */
   -3,  /* (286) type_decl ::= td_start TOK_END_TYPE semicolon */
   -3,  /* (287) td_start ::= TOK_TYPE type_item where_rule_OPT */
   -2,  /* (288) general_ref ::= assignable group_ref */
   -1,  /* (289) general_ref ::= assignable */
   -1,  /* (290) unary_expression ::= aggregate_initializer */
   -2,  /* (291) unary_expression ::= unary_expression qualifier */
   -1,  /* (292) unary_expression ::= literal */
   -1,  /* (293) unary_expression ::= function_call */
   -1,  /* (294) unary_expression ::= identifier */
   -3,  /* (295) unary_expression ::= TOK_LEFT_PAREN expression TOK_RIGHT_PAREN */
   -1,  /* (296) unary_expression ::= interval */
   -1,  /* (297) unary_expression ::= query_expression */
   -2,  /* (298) unary_expression ::= TOK_NOT unary_expression */
   -2,  /* (299) unary_expression ::= TOK_PLUS unary_expression */
   -2,  /* (300) unary_expression ::= TOK_MINUS unary_expression */
    0,  /* (301) unique ::= */
   -1,  /* (302) unique ::= TOK_UNIQUE */
   -1,  /* (303) qualified_attr ::= attribute_decl */
   -1,  /* (304) qualified_attr_list ::= qualified_attr */
   -3,  /* (305) qualified_attr_list ::= qualified_attr_list TOK_COMMA qualified_attr */
   -2,  /* (306) labelled_attrib_list ::= qualified_attr_list semicolon */
   -4,  /* (307) labelled_attrib_list ::= TOK_IDENTIFIER TOK_COLON qualified_attr_list semicolon */
   -1,  /* (308) labelled_attrib_list_list ::= labelled_attrib_list */
   -2,  /* (309) labelled_attrib_list_list ::= labelled_attrib_list_list labelled_attrib_list */
    0,  /* (310) unique_clause ::= */
   -2,  /* (311) unique_clause ::= TOK_UNIQUE labelled_attrib_list_list */
    0,  /* (312) until_control ::= */
   -2,  /* (313) until_control ::= TOK_UNTIL expression */
   -2,  /* (314) where_clause ::= expression semicolon */
   -4,  /* (315) where_clause ::= TOK_IDENTIFIER TOK_COLON expression semicolon */
   -1,  /* (316) where_clause_list ::= where_clause */
   -2,  /* (317) where_clause_list ::= where_clause_list where_clause */
   -2,  /* (318) where_rule ::= TOK_WHERE where_clause_list */
    0,  /* (319) where_rule_OPT ::= */
   -1,  /* (320) where_rule_OPT ::= where_rule */
    0,  /* (321) while_control ::= */
   -2,  /* (322) while_control ::= TOK_WHILE expression */
    0,  /* (323) action_body_item_rep ::= */
    0,  /* (324) block_list ::= */
    0,  /* (325) constant_body_list ::= */
   -1,  /* (326) express_file ::= schema_decl_list */
   -3,  /* (327) parened_rename_list ::= TOK_LEFT_PAREN rename_list TOK_RIGHT_PAREN */
    0,  /* (328) interface_specification_list ::= */
    0,  /* (329) local_body ::= */
   -6,  /* (330) local_decl ::= TOK_LOCAL local_decl_rules_on local_body TOK_END_LOCAL semicolon local_decl_rules_off */
   -3,  /* (331) type_item ::= ti_start type_item_body semicolon */
};

static void yy_accept(yyParser*);  /* Forward Declaration */

/*
** Perform a reduce action and the shift that must immediately
** follow the reduce.
**
** The yyLookahead and yyLookaheadToken parameters provide reduce actions
** access to the lookahead token (if any).  The yyLookahead will be YYNOCODE
** if the lookahead token has already been consumed.  As this procedure is
** only called from one place, optimizing compilers will in-line it, which
** means that the extra parameters have no performance impact.
*/
static YYACTIONTYPE yy_reduce(
  yyParser *yypParser,         /* The parser */
  unsigned int yyruleno,       /* Number of the rule by which to reduce */
  int yyLookahead,             /* Lookahead token, or YYNOCODE if none */
  ParseTOKENTYPE yyLookaheadToken  /* Value of the lookahead token */
  ParseCTX_PDECL                   /* %extra_context */
){
  int yygoto;                     /* The next state */
  YYACTIONTYPE yyact;             /* The next action */
  yyStackEntry *yymsp;            /* The top of the parser's stack */
  int yysize;                     /* Amount to pop the stack */
  ParseARG_FETCH
  (void)yyLookahead;
  (void)yyLookaheadToken;
  yymsp = yypParser->yytos;

  switch( yyruleno ){
  /* Beginning here are the reduction cases.  A typical example
  ** follows:
  **   case 0:
  **  #line <lineno> <grammarfile>
  **     { ... }           // User supplied code
  **  #line <lineno> <thisfile>
  **     break;
  */
/********** Begin reduce actions **********************************************/
        YYMINORTYPE yylhsminor;
      case 0: /* action_body ::= action_body_item_rep statement_rep */
      case 67: /* derive_decl ::= TOK_DERIVE derived_attribute_rep */ yytestcase(yyruleno==67);
      case 174: /* inverse_clause ::= TOK_INVERSE inverse_attr_list */ yytestcase(yyruleno==174);
      case 261: /* statement_rep ::= semicolon statement_rep */ yytestcase(yyruleno==261);
      case 311: /* unique_clause ::= TOK_UNIQUE labelled_attrib_list_list */ yytestcase(yyruleno==311);
      case 318: /* where_rule ::= TOK_WHERE where_clause_list */ yytestcase(yyruleno==318);
#line 297 "expparse.y"
{
    yymsp[-1].minor.yy235 = yymsp[0].minor.yy235;
}
#line 3034 "expparse.c"
        break;
      case 1: /* action_body_item ::= declaration */
      case 2: /* action_body_item ::= constant_decl */ yytestcase(yyruleno==2);
      case 3: /* action_body_item ::= local_decl */ yytestcase(yyruleno==3);
      case 41: /* block_member ::= declaration */ yytestcase(yyruleno==41);
      case 42: /* block_member ::= include_directive */ yytestcase(yyruleno==42);
      case 43: /* block_member ::= rule_decl */ yytestcase(yyruleno==43);
      case 62: /* declaration ::= entity_decl */ yytestcase(yyruleno==62);
      case 63: /* declaration ::= function_decl */ yytestcase(yyruleno==63);
      case 64: /* declaration ::= procedure_decl */ yytestcase(yyruleno==64);
      case 65: /* declaration ::= type_decl */ yytestcase(yyruleno==65);
      case 83: /* schema_decl_list ::= schema_decl */ yytestcase(yyruleno==83);
      case 153: /* rename_list ::= rename */ yytestcase(yyruleno==153);
      case 161: /* interface_specification ::= use_clause */ yytestcase(yyruleno==161);
      case 162: /* interface_specification ::= reference_clause */ yytestcase(yyruleno==162);
      case 195: /* oneof_op ::= TOK_ONEOF */ yytestcase(yyruleno==195);
      case 243: /* schema_decl ::= include_directive */ yytestcase(yyruleno==243);
      case 283: /* type_item_body ::= enumeration_type */ yytestcase(yyruleno==283);
#line 303 "expparse.y"
{
    yylhsminor.yy0 = yymsp[0].minor.yy0;
}
#line 3057 "expparse.c"
  yymsp[0].minor.yy0 = yylhsminor.yy0;
        break;
      case 4: /* action_body_item_rep ::= action_body_item action_body_item_rep */
      case 40: /* block_list ::= block_list block_member */ yytestcase(yyruleno==40);
      case 60: /* constant_body_list ::= constant_body constant_body_list */ yytestcase(yyruleno==60);
      case 84: /* schema_decl_list ::= schema_decl_list schema_decl */ yytestcase(yyruleno==84);
      case 163: /* interface_specification_list ::= interface_specification_list interface_specification */ yytestcase(yyruleno==163);
      case 188: /* local_body ::= local_variable local_body */ yytestcase(yyruleno==188);
      case 240: /* schema_body ::= interface_specification_list block_list */ yytestcase(yyruleno==240);
#line 320 "expparse.y"
{
    yylhsminor.yy0 = yymsp[-1].minor.yy0;
}
#line 3071 "expparse.c"
  yymsp[-1].minor.yy0 = yylhsminor.yy0;
        break;
      case 5: /* actual_parameters ::= TOK_LEFT_PAREN expression_list TOK_RIGHT_PAREN */
      case 194: /* nested_id_list ::= TOK_LEFT_PAREN id_list TOK_RIGHT_PAREN */ yytestcase(yyruleno==194);
#line 337 "expparse.y"
{
    yymsp[-2].minor.yy235 = yymsp[-1].minor.yy235;
}
#line 3080 "expparse.c"
        break;
      case 6: /* actual_parameters ::= TOK_LEFT_PAREN TOK_RIGHT_PAREN */
#line 341 "expparse.y"
{
    yymsp[-1].minor.yy235 = 0;
}
#line 3087 "expparse.c"
        break;
      case 7: /* aggregate_initializer ::= TOK_LEFT_BRACKET TOK_RIGHT_BRACKET */
#line 347 "expparse.y"
{
    yymsp[-1].minor.yy509 = EXPcreate(Type_Aggregate);
    yymsp[-1].minor.yy509->u.list = LISTcreate();
}
#line 3095 "expparse.c"
        break;
      case 8: /* aggregate_initializer ::= TOK_LEFT_BRACKET aggregate_init_body TOK_RIGHT_BRACKET */
#line 353 "expparse.y"
{
    yymsp[-2].minor.yy509 = EXPcreate(Type_Aggregate);
    yymsp[-2].minor.yy509->u.list = yymsp[-1].minor.yy235;
}
#line 3103 "expparse.c"
        break;
      case 9: /* aggregate_init_element ::= expression */
      case 24: /* assignable ::= identifier */ yytestcase(yyruleno==24);
      case 85: /* expression ::= simple_expression */ yytestcase(yyruleno==85);
      case 100: /* simple_expression ::= unary_expression */ yytestcase(yyruleno==100);
      case 184: /* literal ::= constant */ yytestcase(yyruleno==184);
      case 289: /* general_ref ::= assignable */ yytestcase(yyruleno==289);
      case 290: /* unary_expression ::= aggregate_initializer */ yytestcase(yyruleno==290);
      case 292: /* unary_expression ::= literal */ yytestcase(yyruleno==292);
      case 293: /* unary_expression ::= function_call */ yytestcase(yyruleno==293);
      case 294: /* unary_expression ::= identifier */ yytestcase(yyruleno==294);
      case 296: /* unary_expression ::= interval */ yytestcase(yyruleno==296);
      case 297: /* unary_expression ::= query_expression */ yytestcase(yyruleno==297);
      case 303: /* qualified_attr ::= attribute_decl */ yytestcase(yyruleno==303);
#line 359 "expparse.y"
{
    yylhsminor.yy509 = yymsp[0].minor.yy509;
}
#line 3122 "expparse.c"
  yymsp[0].minor.yy509 = yylhsminor.yy509;
        break;
      case 10: /* aggregate_init_body ::= aggregate_init_element */
      case 109: /* expression_list ::= expression */ yytestcase(yyruleno==109);
      case 274: /* supertype_expression_list ::= supertype_expression */ yytestcase(yyruleno==274);
      case 304: /* qualified_attr_list ::= qualified_attr */ yytestcase(yyruleno==304);
#line 364 "expparse.y"
{
    yylhsminor.yy235 = LISTcreate();
    LISTadd_last(yylhsminor.yy235, (Generic)yymsp[0].minor.yy509);
}
#line 3134 "expparse.c"
  yymsp[0].minor.yy235 = yylhsminor.yy235;
        break;
      case 11: /* aggregate_init_body ::= aggregate_init_element TOK_COLON expression */
#line 369 "expparse.y"
{
    yylhsminor.yy235 = LISTcreate();
    LISTadd_last(yylhsminor.yy235, (Generic)yymsp[-2].minor.yy509);

    LISTadd_last(yylhsminor.yy235, (Generic)yymsp[0].minor.yy509);

    yymsp[0].minor.yy509->type = Type_Repeat;
}
#line 3147 "expparse.c"
  yymsp[-2].minor.yy235 = yylhsminor.yy235;
        break;
      case 12: /* aggregate_init_body ::= aggregate_init_body TOK_COMMA aggregate_init_element */
#line 379 "expparse.y"
{ 
    yylhsminor.yy235 = yymsp[-2].minor.yy235;

    LISTadd_last(yylhsminor.yy235, (Generic)yymsp[0].minor.yy509);

}
#line 3158 "expparse.c"
  yymsp[-2].minor.yy235 = yylhsminor.yy235;
        break;
      case 13: /* aggregate_init_body ::= aggregate_init_body TOK_COMMA aggregate_init_element TOK_COLON expression */
#line 387 "expparse.y"
{
    yylhsminor.yy235 = yymsp[-4].minor.yy235;

    LISTadd_last(yylhsminor.yy235, (Generic)yymsp[-2].minor.yy509);
    LISTadd_last(yylhsminor.yy235, (Generic)yymsp[0].minor.yy509);

    yymsp[0].minor.yy509->type = Type_Repeat;
}
#line 3171 "expparse.c"
  yymsp[-4].minor.yy235 = yylhsminor.yy235;
        break;
      case 14: /* aggregate_type ::= TOK_AGGREGATE TOK_OF parameter_type */
#line 397 "expparse.y"
{
    yymsp[-2].minor.yy61 = TYPEBODYcreate(aggregate_);
    yymsp[-2].minor.yy61->base = yymsp[0].minor.yy211;

    if (tag_count < 0) {
        Symbol sym;
        sym.line = yylineno;
        sym.filename = current_filename;
        ERRORreport_with_symbol(UNLABELLED_PARAM_TYPE, &sym, CURRENT_SCOPE_NAME);
    }
}
#line 3187 "expparse.c"
        break;
      case 15: /* aggregate_type ::= TOK_AGGREGATE TOK_COLON TOK_IDENTIFIER TOK_OF parameter_type */
#line 410 "expparse.y"
{
    Type t = TYPEcreate_user_defined_tag(yymsp[0].minor.yy211, CURRENT_SCOPE, yymsp[-2].minor.yy0.symbol);

    if (t) {
        SCOPEadd_super(t);
        yymsp[-4].minor.yy61 = TYPEBODYcreate(aggregate_);
        yymsp[-4].minor.yy61->tag = t;
        yymsp[-4].minor.yy61->base = yymsp[0].minor.yy211;
    }
}
#line 3201 "expparse.c"
        break;
      case 16: /* aggregation_type ::= array_type */
      case 17: /* aggregation_type ::= bag_type */ yytestcase(yyruleno==17);
      case 18: /* aggregation_type ::= list_type */ yytestcase(yyruleno==18);
      case 19: /* aggregation_type ::= set_type */ yytestcase(yyruleno==19);
#line 422 "expparse.y"
{
    yylhsminor.yy61 = yymsp[0].minor.yy61;
}
#line 3211 "expparse.c"
  yymsp[0].minor.yy61 = yylhsminor.yy61;
        break;
      case 20: /* alias_statement ::= TOK_ALIAS TOK_IDENTIFIER TOK_FOR general_ref semicolon alias_push_scope statement_rep TOK_END_ALIAS semicolon */
#line 441 "expparse.y"
{
    Expression e = EXPcreate_from_symbol(Type_Attribute, yymsp[-7].minor.yy0.symbol);
    Variable v = VARcreate(e, Type_Unknown);

    v->initializer = yymsp[-5].minor.yy509; 

    DICTdefine(CURRENT_SCOPE->symbol_table, yymsp[-7].minor.yy0.symbol->name, (Generic)v,
        yymsp[-7].minor.yy0.symbol, OBJ_VARIABLE);
    yymsp[-8].minor.yy242 = ALIAScreate(CURRENT_SCOPE, v, yymsp[-2].minor.yy235);

    POP_SCOPE();
}
#line 3228 "expparse.c"
        break;
      case 21: /* alias_push_scope ::= */
#line 455 "expparse.y"
{
    struct Scope_ *s = SCOPEcreate_tiny(OBJ_ALIAS);
    PUSH_SCOPE(s, (Symbol *)0, OBJ_ALIAS);
}
#line 3236 "expparse.c"
        break;
      case 22: /* array_type ::= TOK_ARRAY bound_spec TOK_OF optional_or_unique attribute_type */
#line 462 "expparse.y"
{
    yymsp[-4].minor.yy61 = TYPEBODYcreate(array_);

    yymsp[-4].minor.yy61->flags.optional = yymsp[-1].minor.yy328.optional;
    yymsp[-4].minor.yy61->flags.unique = yymsp[-1].minor.yy328.unique;
    yymsp[-4].minor.yy61->upper = yymsp[-3].minor.yy58.upper_limit;
    yymsp[-4].minor.yy61->lower = yymsp[-3].minor.yy58.lower_limit;
    yymsp[-4].minor.yy61->base = yymsp[0].minor.yy211;
}
#line 3249 "expparse.c"
        break;
      case 23: /* assignable ::= assignable qualifier */
      case 291: /* unary_expression ::= unary_expression qualifier */ yytestcase(yyruleno==291);
#line 474 "expparse.y"
{
    yymsp[0].minor.yy84.first->e.op1 = yymsp[-1].minor.yy509;
    yylhsminor.yy509 = yymsp[0].minor.yy84.expr;
}
#line 3258 "expparse.c"
  yymsp[-1].minor.yy509 = yylhsminor.yy509;
        break;
      case 25: /* assignment_statement ::= assignable TOK_ASSIGNMENT expression semicolon */
#line 485 "expparse.y"
{ 
    yylhsminor.yy242 = ASSIGNcreate(yymsp[-3].minor.yy509, yymsp[-1].minor.yy509);
}
#line 3266 "expparse.c"
  yymsp[-3].minor.yy242 = yylhsminor.yy242;
        break;
      case 26: /* attribute_type ::= aggregation_type */
      case 27: /* attribute_type ::= basic_type */ yytestcase(yyruleno==27);
      case 118: /* parameter_type ::= basic_type */ yytestcase(yyruleno==118);
      case 119: /* parameter_type ::= conformant_aggregation */ yytestcase(yyruleno==119);
#line 490 "expparse.y"
{
    yylhsminor.yy211 = TYPEcreate_from_body_anonymously(yymsp[0].minor.yy61);
    SCOPEadd_super(yylhsminor.yy211);
}
#line 3278 "expparse.c"
  yymsp[0].minor.yy211 = yylhsminor.yy211;
        break;
      case 28: /* attribute_type ::= defined_type */
      case 120: /* parameter_type ::= defined_type */ yytestcase(yyruleno==120);
      case 121: /* parameter_type ::= generic_type */ yytestcase(yyruleno==121);
#line 500 "expparse.y"
{
    yylhsminor.yy211 = yymsp[0].minor.yy211;
}
#line 3288 "expparse.c"
  yymsp[0].minor.yy211 = yylhsminor.yy211;
        break;
      case 29: /* explicit_attr_list ::= */
      case 48: /* case_action_list ::= */ yytestcase(yyruleno==48);
      case 66: /* derive_decl ::= */ yytestcase(yyruleno==66);
      case 260: /* statement_rep ::= */ yytestcase(yyruleno==260);
#line 505 "expparse.y"
{
    yymsp[1].minor.yy235 = LISTcreate();
}
#line 3299 "expparse.c"
        break;
      case 30: /* explicit_attr_list ::= explicit_attr_list explicit_attribute */
#line 509 "expparse.y"
{
    yylhsminor.yy235 = yymsp[-1].minor.yy235;
    LISTadd_last(yylhsminor.yy235, (Generic)yymsp[0].minor.yy235); 
}
#line 3307 "expparse.c"
  yymsp[-1].minor.yy235 = yylhsminor.yy235;
        break;
      case 31: /* bag_type ::= TOK_BAG bound_spec TOK_OF attribute_type */
      case 134: /* conformant_aggregation ::= TOK_BAG bound_spec TOK_OF parameter_type */ yytestcase(yyruleno==134);
#line 515 "expparse.y"
{
    yymsp[-3].minor.yy61 = TYPEBODYcreate(bag_);
    yymsp[-3].minor.yy61->base = yymsp[0].minor.yy211;
    yymsp[-3].minor.yy61->upper = yymsp[-2].minor.yy58.upper_limit;
    yymsp[-3].minor.yy61->lower = yymsp[-2].minor.yy58.lower_limit;
}
#line 3319 "expparse.c"
        break;
      case 32: /* bag_type ::= TOK_BAG TOK_OF attribute_type */
#line 522 "expparse.y"
{
    yymsp[-2].minor.yy61 = TYPEBODYcreate(bag_);
    yymsp[-2].minor.yy61->base = yymsp[0].minor.yy211;
}
#line 3327 "expparse.c"
        break;
      case 33: /* basic_type ::= TOK_BOOLEAN */
#line 528 "expparse.y"
{
    yymsp[0].minor.yy61 = TYPEBODYcreate(boolean_);
}
#line 3334 "expparse.c"
        break;
      case 34: /* basic_type ::= TOK_INTEGER precision_spec */
#line 532 "expparse.y"
{
    yymsp[-1].minor.yy61 = TYPEBODYcreate(integer_);
    yymsp[-1].minor.yy61->precision = yymsp[0].minor.yy509;
}
#line 3342 "expparse.c"
        break;
      case 35: /* basic_type ::= TOK_REAL precision_spec */
#line 537 "expparse.y"
{
    yymsp[-1].minor.yy61 = TYPEBODYcreate(real_);
    yymsp[-1].minor.yy61->precision = yymsp[0].minor.yy509;
}
#line 3350 "expparse.c"
        break;
      case 36: /* basic_type ::= TOK_NUMBER */
#line 542 "expparse.y"
{
    yymsp[0].minor.yy61 = TYPEBODYcreate(number_);
}
#line 3357 "expparse.c"
        break;
      case 37: /* basic_type ::= TOK_LOGICAL */
#line 546 "expparse.y"
{
    yymsp[0].minor.yy61 = TYPEBODYcreate(logical_);
}
#line 3364 "expparse.c"
        break;
      case 38: /* basic_type ::= TOK_BINARY precision_spec optional_fixed */
#line 550 "expparse.y"
{
    yymsp[-2].minor.yy61 = TYPEBODYcreate(binary_);
    yymsp[-2].minor.yy61->precision = yymsp[-1].minor.yy509;
    yymsp[-2].minor.yy61->flags.fixed = yymsp[0].minor.yy328.fixed;
}
#line 3373 "expparse.c"
        break;
      case 39: /* basic_type ::= TOK_STRING precision_spec optional_fixed */
#line 556 "expparse.y"
{
    yymsp[-2].minor.yy61 = TYPEBODYcreate(string_);
    yymsp[-2].minor.yy61->precision = yymsp[-1].minor.yy509;
    yymsp[-2].minor.yy61->flags.fixed = yymsp[0].minor.yy328.fixed;
}
#line 3382 "expparse.c"
        break;
      case 44: /* by_expression ::= */
#line 582 "expparse.y"
{
    yymsp[1].minor.yy509 = LITERAL_ONE;
}
#line 3389 "expparse.c"
        break;
      case 45: /* by_expression ::= TOK_BY expression */
      case 150: /* initializer ::= TOK_ASSIGNMENT expression */ yytestcase(yyruleno==150);
      case 185: /* local_initializer ::= TOK_ASSIGNMENT expression */ yytestcase(yyruleno==185);
      case 299: /* unary_expression ::= TOK_PLUS unary_expression */ yytestcase(yyruleno==299);
      case 313: /* until_control ::= TOK_UNTIL expression */ yytestcase(yyruleno==313);
      case 322: /* while_control ::= TOK_WHILE expression */ yytestcase(yyruleno==322);
#line 586 "expparse.y"
{
    yymsp[-1].minor.yy509 = yymsp[0].minor.yy509;
}
#line 3401 "expparse.c"
        break;
      case 46: /* cardinality_op ::= TOK_LEFT_CURL expression TOK_COLON expression TOK_RIGHT_CURL */
      case 175: /* bound_spec ::= TOK_LEFT_BRACKET expression TOK_COLON expression TOK_RIGHT_BRACKET */ yytestcase(yyruleno==175);
#line 592 "expparse.y"
{
    yymsp[-4].minor.yy58.lower_limit = yymsp[-3].minor.yy509;
    yymsp[-4].minor.yy58.upper_limit = yymsp[-1].minor.yy509;
}
#line 3410 "expparse.c"
        break;
      case 47: /* case_action ::= case_labels TOK_COLON statement */
#line 598 "expparse.y"
{
    yylhsminor.yy75 = CASE_ITcreate(yymsp[-2].minor.yy235, yymsp[0].minor.yy242);
    SYMBOLset(yylhsminor.yy75);
}
#line 3418 "expparse.c"
  yymsp[-2].minor.yy75 = yylhsminor.yy75;
        break;
      case 49: /* case_action_list ::= case_action_list case_action */
#line 608 "expparse.y"
{
    yyerrok;

    yylhsminor.yy235 = yymsp[-1].minor.yy235;

    LISTadd_last(yylhsminor.yy235, (Generic)yymsp[0].minor.yy75);
}
#line 3430 "expparse.c"
  yymsp[-1].minor.yy235 = yylhsminor.yy235;
        break;
      case 50: /* case_block ::= case_action_list case_otherwise */
#line 617 "expparse.y"
{
    yylhsminor.yy235 = yymsp[-1].minor.yy235;

    if (yymsp[0].minor.yy75) {
        LISTadd_last(yylhsminor.yy235,
        (Generic)yymsp[0].minor.yy75);
    }
}
#line 3443 "expparse.c"
  yymsp[-1].minor.yy235 = yylhsminor.yy235;
        break;
      case 51: /* case_labels ::= expression */
#line 627 "expparse.y"
{
    yylhsminor.yy235 = LISTcreate();

    LISTadd_last(yylhsminor.yy235, (Generic)yymsp[0].minor.yy509);
}
#line 3453 "expparse.c"
  yymsp[0].minor.yy235 = yylhsminor.yy235;
        break;
      case 52: /* case_labels ::= case_labels TOK_COMMA expression */
#line 633 "expparse.y"
{
    yyerrok;

    yylhsminor.yy235 = yymsp[-2].minor.yy235;
    LISTadd_last(yylhsminor.yy235, (Generic)yymsp[0].minor.yy509);
}
#line 3464 "expparse.c"
  yymsp[-2].minor.yy235 = yylhsminor.yy235;
        break;
      case 53: /* case_otherwise ::= */
#line 641 "expparse.y"
{
    yymsp[1].minor.yy75 = (Case_Item)0;
}
#line 3472 "expparse.c"
        break;
      case 54: /* case_otherwise ::= TOK_OTHERWISE TOK_COLON statement */
#line 645 "expparse.y"
{
    yymsp[-2].minor.yy75 = CASE_ITcreate(LIST_NULL, yymsp[0].minor.yy242);
    SYMBOLset(yymsp[-2].minor.yy75);
}
#line 3480 "expparse.c"
        break;
      case 55: /* case_statement ::= TOK_CASE expression TOK_OF case_block TOK_END_CASE semicolon */
#line 652 "expparse.y"
{
    yymsp[-5].minor.yy242 = CASEcreate(yymsp[-4].minor.yy509, yymsp[-2].minor.yy235);
}
#line 3487 "expparse.c"
        break;
      case 56: /* compound_statement ::= TOK_BEGIN statement_rep TOK_END semicolon */
#line 657 "expparse.y"
{
    yymsp[-3].minor.yy242 = COMP_STMTcreate(yymsp[-2].minor.yy235);
}
#line 3494 "expparse.c"
        break;
      case 57: /* constant ::= TOK_PI */
#line 662 "expparse.y"
{ 
    yymsp[0].minor.yy509 = LITERAL_PI;
}
#line 3501 "expparse.c"
        break;
      case 58: /* constant ::= TOK_E */
#line 667 "expparse.y"
{ 
    yymsp[0].minor.yy509 = LITERAL_E;
}
#line 3508 "expparse.c"
        break;
      case 59: /* constant_body ::= identifier TOK_COLON attribute_type TOK_ASSIGNMENT expression semicolon */
#line 674 "expparse.y"
{
    Variable v;

    yymsp[-5].minor.yy509->type = yymsp[-3].minor.yy211;
    v = VARcreate(yymsp[-5].minor.yy509, yymsp[-3].minor.yy211);
    v->initializer = yymsp[-1].minor.yy509;
    v->flags.constant = 1;
    DICTdefine(CURRENT_SCOPE->symbol_table, yymsp[-5].minor.yy509->symbol.name, (Generic)v,
    &yymsp[-5].minor.yy509->symbol, OBJ_VARIABLE);
}
#line 3522 "expparse.c"
        break;
      case 61: /* constant_decl ::= TOK_CONSTANT constant_body_list TOK_END_CONSTANT semicolon */
#line 693 "expparse.y"
{
    yylhsminor.yy0 = yymsp[-3].minor.yy0;
}
#line 3529 "expparse.c"
  yymsp[-3].minor.yy0 = yylhsminor.yy0;
        break;
      case 68: /* derived_attribute ::= attribute_decl TOK_COLON attribute_type initializer semicolon */
#line 725 "expparse.y"
{
    yylhsminor.yy319 = VARcreate(yymsp[-4].minor.yy509, yymsp[-2].minor.yy211);
    yylhsminor.yy319->initializer = yymsp[-1].minor.yy509;
    yylhsminor.yy319->flags.attribute = true;
}
#line 3539 "expparse.c"
  yymsp[-4].minor.yy319 = yylhsminor.yy319;
        break;
      case 69: /* derived_attribute_rep ::= derived_attribute */
      case 170: /* inverse_attr_list ::= inverse_attr */ yytestcase(yyruleno==170);
#line 732 "expparse.y"
{
    yylhsminor.yy235 = LISTcreate();
    LISTadd_last(yylhsminor.yy235, (Generic)yymsp[0].minor.yy319);
}
#line 3549 "expparse.c"
  yymsp[0].minor.yy235 = yylhsminor.yy235;
        break;
      case 70: /* derived_attribute_rep ::= derived_attribute_rep derived_attribute */
      case 171: /* inverse_attr_list ::= inverse_attr_list inverse_attr */ yytestcase(yyruleno==171);
#line 737 "expparse.y"
{
    yylhsminor.yy235 = yymsp[-1].minor.yy235;
    LISTadd_last(yylhsminor.yy235, (Generic)yymsp[0].minor.yy319);
}
#line 3559 "expparse.c"
  yymsp[-1].minor.yy235 = yylhsminor.yy235;
        break;
      case 71: /* entity_body ::= explicit_attr_list derive_decl inverse_clause unique_clause where_rule_OPT */
#line 744 "expparse.y"
{
    yylhsminor.yy388.attributes = yymsp[-4].minor.yy235;
    /* this is flattened out in entity_decl - DEL */
    LISTadd_last(yylhsminor.yy388.attributes, (Generic)yymsp[-3].minor.yy235);

    if (yymsp[-2].minor.yy235 != LIST_NULL) {
    LISTadd_last(yylhsminor.yy388.attributes, (Generic)yymsp[-2].minor.yy235);
    }

    yylhsminor.yy388.unique = yymsp[-1].minor.yy235;
    yylhsminor.yy388.where = yymsp[0].minor.yy235;
}
#line 3576 "expparse.c"
  yymsp[-4].minor.yy388 = yylhsminor.yy388;
        break;
      case 72: /* entity_decl ::= entity_header subsuper_decl semicolon entity_body TOK_END_ENTITY semicolon */
#line 759 "expparse.y"
{
    CURRENT_SCOPE->u.entity->subtype_expression = yymsp[-4].minor.yy302.subtypes;
    CURRENT_SCOPE->u.entity->supertype_symbols = yymsp[-4].minor.yy302.supertypes;
    LISTdo( yymsp[-2].minor.yy388.attributes, l, Linked_List ) {
        LISTdo_n( l, a, Variable, b ) {
            ENTITYadd_attribute(CURRENT_SCOPE, a);
        } LISTod;
    } LISTod;
    CURRENT_SCOPE->u.entity->abstract = yymsp[-4].minor.yy302.abstract;
    CURRENT_SCOPE->u.entity->unique = yymsp[-2].minor.yy388.unique;
    CURRENT_SCOPE->where = yymsp[-2].minor.yy388.where;
    POP_SCOPE();
}
#line 3594 "expparse.c"
        break;
      case 73: /* entity_header ::= TOK_ENTITY TOK_IDENTIFIER */
#line 774 "expparse.y"
{
    Entity e = ENTITYcreate(yymsp[0].minor.yy0.symbol);

    if (print_objects_while_running & OBJ_ENTITY_BITS) {
    fprintf( stderr, "parse: %s (entity)\n", yymsp[0].minor.yy0.symbol->name);
    }

    PUSH_SCOPE(e, yymsp[0].minor.yy0.symbol, OBJ_ENTITY);
}
#line 3607 "expparse.c"
        break;
      case 74: /* enumeration_type ::= TOK_ENUMERATION TOK_OF nested_id_list */
#line 785 "expparse.y"
{
    int value = 0;
    Expression x;
    Symbol *tmp;
    TypeBody tb;
    tb = TYPEBODYcreate(enumeration_);
    CURRENT_SCOPE->u.type->head = 0;
    CURRENT_SCOPE->u.type->body = tb;
    tb->list = yymsp[0].minor.yy235;

    if (!CURRENT_SCOPE->symbol_table) {
        CURRENT_SCOPE->symbol_table = DICTcreate(25);
    }
    if (!PREVIOUS_SCOPE->enum_table) {
        PREVIOUS_SCOPE->enum_table = DICTcreate(25);
    }
    LISTdo_links(yymsp[0].minor.yy235, id) {
        tmp = (Symbol *)id->data;
        id->data = (Generic)(x = EXPcreate(CURRENT_SCOPE));
        x->symbol = *(tmp);
        x->u.integer = ++value;

        /* define both in enum scope and scope of */
        /* 1st visibility */
        DICT_define(CURRENT_SCOPE->symbol_table, x->symbol.name,
            (Generic)x, &x->symbol, OBJ_EXPRESSION);
        DICTdefine(PREVIOUS_SCOPE->enum_table, x->symbol.name,
            (Generic)x, &x->symbol, OBJ_EXPRESSION);
        SYMBOL_destroy(tmp);
    } LISTod;
}
#line 3642 "expparse.c"
        break;
      case 75: /* escape_statement ::= TOK_ESCAPE semicolon */
#line 818 "expparse.y"
{
    yymsp[-1].minor.yy242 = STATEMENT_ESCAPE;
}
#line 3649 "expparse.c"
        break;
      case 76: /* attribute_decl ::= TOK_IDENTIFIER */
#line 833 "expparse.y"
{
    yylhsminor.yy509 = EXPcreate(Type_Attribute);
    yylhsminor.yy509->symbol = *yymsp[0].minor.yy0.symbol;
    SYMBOL_destroy(yymsp[0].minor.yy0.symbol);
}
#line 3658 "expparse.c"
  yymsp[0].minor.yy509 = yylhsminor.yy509;
        break;
      case 77: /* attribute_decl ::= TOK_SELF TOK_BACKSLASH TOK_IDENTIFIER TOK_DOT TOK_IDENTIFIER */
#line 840 "expparse.y"
{
    yymsp[-4].minor.yy509 = EXPcreate(Type_Expression);
    yymsp[-4].minor.yy509->e.op1 = EXPcreate(Type_Expression);
    yymsp[-4].minor.yy509->e.op1->e.op_code = OP_GROUP;
    yymsp[-4].minor.yy509->e.op1->e.op1 = EXPcreate(Type_Self);
    yymsp[-4].minor.yy509->e.op1->e.op2 = EXPcreate_from_symbol(Type_Entity, yymsp[-2].minor.yy0.symbol);
    SYMBOL_destroy(yymsp[-2].minor.yy0.symbol);

    yymsp[-4].minor.yy509->e.op_code = OP_DOT;
    yymsp[-4].minor.yy509->e.op2 = EXPcreate_from_symbol(Type_Attribute, yymsp[0].minor.yy0.symbol);
    SYMBOL_destroy(yymsp[0].minor.yy0.symbol);
}
#line 3675 "expparse.c"
        break;
      case 78: /* attribute_decl_list ::= attribute_decl */
#line 854 "expparse.y"
{
    yylhsminor.yy235 = LISTcreate();
    LISTadd_last(yylhsminor.yy235, (Generic)yymsp[0].minor.yy509);

}
#line 3684 "expparse.c"
  yymsp[0].minor.yy235 = yylhsminor.yy235;
        break;
      case 79: /* attribute_decl_list ::= attribute_decl_list TOK_COMMA attribute_decl */
      case 110: /* expression_list ::= expression_list TOK_COMMA expression */ yytestcase(yyruleno==110);
      case 305: /* qualified_attr_list ::= qualified_attr_list TOK_COMMA qualified_attr */ yytestcase(yyruleno==305);
#line 861 "expparse.y"
{
    yylhsminor.yy235 = yymsp[-2].minor.yy235;
    LISTadd_last(yylhsminor.yy235, (Generic)yymsp[0].minor.yy509);
}
#line 3695 "expparse.c"
  yymsp[-2].minor.yy235 = yylhsminor.yy235;
        break;
      case 80: /* optional ::= */
#line 867 "expparse.y"
{
    yymsp[1].minor.yy328.optional = 0;
}
#line 3703 "expparse.c"
        break;
      case 81: /* optional ::= TOK_OPTIONAL */
#line 871 "expparse.y"
{
    yymsp[0].minor.yy328.optional = 1;
}
#line 3710 "expparse.c"
        break;
      case 82: /* explicit_attribute ::= attribute_decl_list TOK_COLON optional attribute_type semicolon */
#line 877 "expparse.y"
{
    Variable v;

    LISTdo_links (yymsp[-4].minor.yy235, attr)
    v = VARcreate((Expression)attr->data, yymsp[-1].minor.yy211);
    v->flags.optional = yymsp[-2].minor.yy328.optional;
    v->flags.attribute = true;
    attr->data = (Generic)v;
    LISTod;

    yylhsminor.yy235 = yymsp[-4].minor.yy235;
}
#line 3726 "expparse.c"
  yymsp[-4].minor.yy235 = yylhsminor.yy235;
        break;
      case 86: /* expression ::= expression TOK_AND expression */
#line 906 "expparse.y"
{
    yyerrok;

    yylhsminor.yy509 = BIN_EXPcreate(OP_AND, yymsp[-2].minor.yy509, yymsp[0].minor.yy509);
}
#line 3736 "expparse.c"
  yymsp[-2].minor.yy509 = yylhsminor.yy509;
        break;
      case 87: /* expression ::= expression TOK_OR expression */
#line 912 "expparse.y"
{
    yyerrok;

    yylhsminor.yy509 = BIN_EXPcreate(OP_OR, yymsp[-2].minor.yy509, yymsp[0].minor.yy509);
}
#line 3746 "expparse.c"
  yymsp[-2].minor.yy509 = yylhsminor.yy509;
        break;
      case 88: /* expression ::= expression TOK_XOR expression */
#line 918 "expparse.y"
{
    yyerrok;

    yylhsminor.yy509 = BIN_EXPcreate(OP_XOR, yymsp[-2].minor.yy509, yymsp[0].minor.yy509);
}
#line 3756 "expparse.c"
  yymsp[-2].minor.yy509 = yylhsminor.yy509;
        break;
      case 89: /* expression ::= expression TOK_LESS_THAN expression */
#line 924 "expparse.y"
{
    yyerrok;

    yylhsminor.yy509 = BIN_EXPcreate(OP_LESS_THAN, yymsp[-2].minor.yy509, yymsp[0].minor.yy509);
}
#line 3766 "expparse.c"
  yymsp[-2].minor.yy509 = yylhsminor.yy509;
        break;
      case 90: /* expression ::= expression TOK_GREATER_THAN expression */
#line 930 "expparse.y"
{
    yyerrok;

    yylhsminor.yy509 = BIN_EXPcreate(OP_GREATER_THAN, yymsp[-2].minor.yy509, yymsp[0].minor.yy509);
}
#line 3776 "expparse.c"
  yymsp[-2].minor.yy509 = yylhsminor.yy509;
        break;
      case 91: /* expression ::= expression TOK_EQUAL expression */
#line 936 "expparse.y"
{
    yyerrok;

    yylhsminor.yy509 = BIN_EXPcreate(OP_EQUAL, yymsp[-2].minor.yy509, yymsp[0].minor.yy509);
}
#line 3786 "expparse.c"
  yymsp[-2].minor.yy509 = yylhsminor.yy509;
        break;
      case 92: /* expression ::= expression TOK_LESS_EQUAL expression */
#line 942 "expparse.y"
{
    yyerrok;

    yylhsminor.yy509 = BIN_EXPcreate(OP_LESS_EQUAL, yymsp[-2].minor.yy509, yymsp[0].minor.yy509);
}
#line 3796 "expparse.c"
  yymsp[-2].minor.yy509 = yylhsminor.yy509;
        break;
      case 93: /* expression ::= expression TOK_GREATER_EQUAL expression */
#line 948 "expparse.y"
{
    yyerrok;

    yylhsminor.yy509 = BIN_EXPcreate(OP_GREATER_EQUAL, yymsp[-2].minor.yy509, yymsp[0].minor.yy509);
}
#line 3806 "expparse.c"
  yymsp[-2].minor.yy509 = yylhsminor.yy509;
        break;
      case 94: /* expression ::= expression TOK_NOT_EQUAL expression */
#line 954 "expparse.y"
{
    yyerrok;

    yylhsminor.yy509 = BIN_EXPcreate(OP_NOT_EQUAL, yymsp[-2].minor.yy509, yymsp[0].minor.yy509);
}
#line 3816 "expparse.c"
  yymsp[-2].minor.yy509 = yylhsminor.yy509;
        break;
      case 95: /* expression ::= expression TOK_INST_EQUAL expression */
#line 960 "expparse.y"
{
    yyerrok;

    yylhsminor.yy509 = BIN_EXPcreate(OP_INST_EQUAL, yymsp[-2].minor.yy509, yymsp[0].minor.yy509);
}
#line 3826 "expparse.c"
  yymsp[-2].minor.yy509 = yylhsminor.yy509;
        break;
      case 96: /* expression ::= expression TOK_INST_NOT_EQUAL expression */
#line 966 "expparse.y"
{
    yyerrok;

    yylhsminor.yy509 = BIN_EXPcreate(OP_INST_NOT_EQUAL, yymsp[-2].minor.yy509, yymsp[0].minor.yy509);
}
#line 3836 "expparse.c"
  yymsp[-2].minor.yy509 = yylhsminor.yy509;
        break;
      case 97: /* expression ::= expression TOK_IN expression */
#line 972 "expparse.y"
{
    yyerrok;

    yylhsminor.yy509 = BIN_EXPcreate(OP_IN, yymsp[-2].minor.yy509, yymsp[0].minor.yy509);
}
#line 3846 "expparse.c"
  yymsp[-2].minor.yy509 = yylhsminor.yy509;
        break;
      case 98: /* expression ::= expression TOK_LIKE expression */
#line 978 "expparse.y"
{
    yyerrok;

    yylhsminor.yy509 = BIN_EXPcreate(OP_LIKE, yymsp[-2].minor.yy509, yymsp[0].minor.yy509);
}
#line 3856 "expparse.c"
  yymsp[-2].minor.yy509 = yylhsminor.yy509;
        break;
      case 99: /* expression ::= simple_expression cardinality_op simple_expression */
      case 232: /* right_curl ::= TOK_RIGHT_CURL */ yytestcase(yyruleno==232);
      case 246: /* semicolon ::= TOK_SEMICOLON */ yytestcase(yyruleno==246);
#line 984 "expparse.y"
{
    yyerrok;
}
#line 3866 "expparse.c"
        break;
      case 101: /* simple_expression ::= simple_expression TOK_CONCAT_OP simple_expression */
#line 994 "expparse.y"
{
    yyerrok;

    yylhsminor.yy509 = BIN_EXPcreate(OP_CONCAT, yymsp[-2].minor.yy509, yymsp[0].minor.yy509);
}
#line 3875 "expparse.c"
  yymsp[-2].minor.yy509 = yylhsminor.yy509;
        break;
      case 102: /* simple_expression ::= simple_expression TOK_EXP simple_expression */
#line 1000 "expparse.y"
{
    yyerrok;

    yylhsminor.yy509 = BIN_EXPcreate(OP_EXP, yymsp[-2].minor.yy509, yymsp[0].minor.yy509);
}
#line 3885 "expparse.c"
  yymsp[-2].minor.yy509 = yylhsminor.yy509;
        break;
      case 103: /* simple_expression ::= simple_expression TOK_TIMES simple_expression */
#line 1006 "expparse.y"
{
    yyerrok;

    yylhsminor.yy509 = BIN_EXPcreate(OP_TIMES, yymsp[-2].minor.yy509, yymsp[0].minor.yy509);
}
#line 3895 "expparse.c"
  yymsp[-2].minor.yy509 = yylhsminor.yy509;
        break;
      case 104: /* simple_expression ::= simple_expression TOK_DIV simple_expression */
#line 1012 "expparse.y"
{
    yyerrok;

    yylhsminor.yy509 = BIN_EXPcreate(OP_DIV, yymsp[-2].minor.yy509, yymsp[0].minor.yy509);
}
#line 3905 "expparse.c"
  yymsp[-2].minor.yy509 = yylhsminor.yy509;
        break;
      case 105: /* simple_expression ::= simple_expression TOK_REAL_DIV simple_expression */
#line 1018 "expparse.y"
{
    yyerrok;

    yylhsminor.yy509 = BIN_EXPcreate(OP_REAL_DIV, yymsp[-2].minor.yy509, yymsp[0].minor.yy509);
}
#line 3915 "expparse.c"
  yymsp[-2].minor.yy509 = yylhsminor.yy509;
        break;
      case 106: /* simple_expression ::= simple_expression TOK_MOD simple_expression */
#line 1024 "expparse.y"
{
    yyerrok;

    yylhsminor.yy509 = BIN_EXPcreate(OP_MOD, yymsp[-2].minor.yy509, yymsp[0].minor.yy509);
}
#line 3925 "expparse.c"
  yymsp[-2].minor.yy509 = yylhsminor.yy509;
        break;
      case 107: /* simple_expression ::= simple_expression TOK_PLUS simple_expression */
#line 1030 "expparse.y"
{
    yyerrok;

    yylhsminor.yy509 = BIN_EXPcreate(OP_PLUS, yymsp[-2].minor.yy509, yymsp[0].minor.yy509);
}
#line 3935 "expparse.c"
  yymsp[-2].minor.yy509 = yylhsminor.yy509;
        break;
      case 108: /* simple_expression ::= simple_expression TOK_MINUS simple_expression */
#line 1036 "expparse.y"
{
    yyerrok;

    yylhsminor.yy509 = BIN_EXPcreate(OP_MINUS, yymsp[-2].minor.yy509, yymsp[0].minor.yy509);
}
#line 3945 "expparse.c"
  yymsp[-2].minor.yy509 = yylhsminor.yy509;
        break;
      case 111: /* var ::= */
#line 1054 "expparse.y"
{
    yymsp[1].minor.yy328.var = 0;
}
#line 3953 "expparse.c"
        break;
      case 112: /* var ::= TOK_VAR */
#line 1058 "expparse.y"
{
    yymsp[0].minor.yy328.var = 1;
}
#line 3960 "expparse.c"
        break;
      case 113: /* formal_parameter ::= var id_list TOK_COLON parameter_type */
#line 1063 "expparse.y"
{
    Symbol *tmp;
    Expression e;
    Variable v;

    yylhsminor.yy235 = yymsp[-2].minor.yy235;
    LISTdo_links(yylhsminor.yy235, param)
    tmp = (Symbol*)param->data;

    e = EXPcreate_from_symbol(Type_Attribute, tmp);
    v = VARcreate(e, yymsp[0].minor.yy211);
    v->flags.var = yymsp[-3].minor.yy328.var; /* NOTE this was flags.optional... ?! */
    v->flags.parameter = true;
    param->data = (Generic)v;

    /* link it in to the current scope's dict */
    DICTdefine(CURRENT_SCOPE->symbol_table,
    tmp->name, (Generic)v, tmp, OBJ_VARIABLE);

    LISTod;
}
#line 3985 "expparse.c"
  yymsp[-3].minor.yy235 = yylhsminor.yy235;
        break;
      case 114: /* formal_parameter_list ::= */
      case 173: /* inverse_clause ::= */ yytestcase(yyruleno==173);
      case 319: /* where_rule_OPT ::= */ yytestcase(yyruleno==319);
#line 1086 "expparse.y"
{
    yymsp[1].minor.yy235 = LIST_NULL;
}
#line 3995 "expparse.c"
        break;
      case 115: /* formal_parameter_list ::= TOK_LEFT_PAREN formal_parameter_rep TOK_RIGHT_PAREN */
#line 1091 "expparse.y"
{
    yymsp[-2].minor.yy235 = yymsp[-1].minor.yy235;

}
#line 4003 "expparse.c"
        break;
      case 116: /* formal_parameter_rep ::= formal_parameter */
#line 1097 "expparse.y"
{
    yylhsminor.yy235 = yymsp[0].minor.yy235;

}
#line 4011 "expparse.c"
  yymsp[0].minor.yy235 = yylhsminor.yy235;
        break;
      case 117: /* formal_parameter_rep ::= formal_parameter_rep semicolon formal_parameter */
#line 1103 "expparse.y"
{
    yylhsminor.yy235 = yymsp[-2].minor.yy235;
    LISTadd_all(yylhsminor.yy235, yymsp[0].minor.yy235);
}
#line 4020 "expparse.c"
  yymsp[-2].minor.yy235 = yylhsminor.yy235;
        break;
      case 122: /* function_call ::= function_id actual_parameters */
#line 1128 "expparse.y"
{
    yylhsminor.yy509 = EXPcreate(Type_Funcall);
    yylhsminor.yy509->symbol = *yymsp[-1].minor.yy301;
    SYMBOL_destroy(yymsp[-1].minor.yy301);
    yylhsminor.yy509->u.funcall.list = yymsp[0].minor.yy235;
}
#line 4031 "expparse.c"
  yymsp[-1].minor.yy509 = yylhsminor.yy509;
        break;
      case 123: /* function_decl ::= function_header action_body TOK_END_FUNCTION semicolon */
#line 1137 "expparse.y"
{
    FUNCput_body(CURRENT_SCOPE, yymsp[-2].minor.yy235);
    ALGput_full_text(CURRENT_SCOPE, yymsp[-3].minor.yy263, SCANtell());
    POP_SCOPE();
}
#line 4041 "expparse.c"
        break;
      case 124: /* function_header ::= fh_lineno fh_push_scope fh_plist TOK_COLON parameter_type semicolon */
#line 1145 "expparse.y"
{ 
    Function f = CURRENT_SCOPE;

    f->u.func->return_type = yymsp[-1].minor.yy211;
    yylhsminor.yy263 = yymsp[-5].minor.yy263;
}
#line 4051 "expparse.c"
  yymsp[-5].minor.yy263 = yylhsminor.yy263;
        break;
      case 125: /* fh_lineno ::= TOK_FUNCTION */
#line 1153 "expparse.y"
{
    yymsp[0].minor.yy263 = SCANtell();
}
#line 4059 "expparse.c"
        break;
      case 126: /* fh_push_scope ::= TOK_IDENTIFIER */
#line 1158 "expparse.y"
{
    Function f = ALGcreate(OBJ_FUNCTION);
    tag_count = 0;
    if (print_objects_while_running & OBJ_FUNCTION_BITS) {
        fprintf( stderr, "parse: %s (function)\n", yymsp[0].minor.yy0.symbol->name);
    }
    PUSH_SCOPE(f, yymsp[0].minor.yy0.symbol, OBJ_FUNCTION);
}
#line 4071 "expparse.c"
        break;
      case 127: /* fh_plist ::= formal_parameter_list */
#line 1168 "expparse.y"
{
    Function f = CURRENT_SCOPE;
    f->u.func->parameters = yymsp[0].minor.yy235;
    f->u.func->pcount = LISTget_length(yymsp[0].minor.yy235);
    f->u.func->tag_count = tag_count;
    tag_count = -1;     /* done with parameters, no new tags can be defined */
}
#line 4082 "expparse.c"
        break;
      case 128: /* function_id ::= TOK_IDENTIFIER */
      case 211: /* procedure_id ::= TOK_IDENTIFIER */ yytestcase(yyruleno==211);
      case 212: /* procedure_id ::= TOK_BUILTIN_PROCEDURE */ yytestcase(yyruleno==212);
#line 1177 "expparse.y"
{
    yylhsminor.yy301 = yymsp[0].minor.yy0.symbol;
}
#line 4091 "expparse.c"
  yymsp[0].minor.yy301 = yylhsminor.yy301;
        break;
      case 129: /* function_id ::= TOK_BUILTIN_FUNCTION */
#line 1181 "expparse.y"
{
    yylhsminor.yy301 = yymsp[0].minor.yy0.symbol;

}
#line 4100 "expparse.c"
  yymsp[0].minor.yy301 = yylhsminor.yy301;
        break;
      case 130: /* conformant_aggregation ::= aggregate_type */
#line 1187 "expparse.y"
{
    yylhsminor.yy61 = yymsp[0].minor.yy61;

}
#line 4109 "expparse.c"
  yymsp[0].minor.yy61 = yylhsminor.yy61;
        break;
      case 131: /* conformant_aggregation ::= TOK_ARRAY TOK_OF optional_or_unique parameter_type */
#line 1193 "expparse.y"
{
    yymsp[-3].minor.yy61 = TYPEBODYcreate(array_);
    yymsp[-3].minor.yy61->flags.optional = yymsp[-1].minor.yy328.optional;
    yymsp[-3].minor.yy61->flags.unique = yymsp[-1].minor.yy328.unique;
    yymsp[-3].minor.yy61->base = yymsp[0].minor.yy211;
}
#line 4120 "expparse.c"
        break;
      case 132: /* conformant_aggregation ::= TOK_ARRAY bound_spec TOK_OF optional_or_unique parameter_type */
#line 1201 "expparse.y"
{
    yymsp[-4].minor.yy61 = TYPEBODYcreate(array_);
    yymsp[-4].minor.yy61->flags.optional = yymsp[-1].minor.yy328.optional;
    yymsp[-4].minor.yy61->flags.unique = yymsp[-1].minor.yy328.unique;
    yymsp[-4].minor.yy61->base = yymsp[0].minor.yy211;
    yymsp[-4].minor.yy61->upper = yymsp[-3].minor.yy58.upper_limit;
    yymsp[-4].minor.yy61->lower = yymsp[-3].minor.yy58.lower_limit;
}
#line 4132 "expparse.c"
        break;
      case 133: /* conformant_aggregation ::= TOK_BAG TOK_OF parameter_type */
#line 1210 "expparse.y"
{
    yymsp[-2].minor.yy61 = TYPEBODYcreate(bag_);
    yymsp[-2].minor.yy61->base = yymsp[0].minor.yy211;

}
#line 4141 "expparse.c"
        break;
      case 135: /* conformant_aggregation ::= TOK_LIST TOK_OF unique parameter_type */
#line 1223 "expparse.y"
{
    yymsp[-3].minor.yy61 = TYPEBODYcreate(list_);
    yymsp[-3].minor.yy61->flags.unique = yymsp[-1].minor.yy328.unique;
    yymsp[-3].minor.yy61->base = yymsp[0].minor.yy211;

}
#line 4151 "expparse.c"
        break;
      case 136: /* conformant_aggregation ::= TOK_LIST bound_spec TOK_OF unique parameter_type */
#line 1231 "expparse.y"
{
    yymsp[-4].minor.yy61 = TYPEBODYcreate(list_);
    yymsp[-4].minor.yy61->base = yymsp[0].minor.yy211;
    yymsp[-4].minor.yy61->flags.unique = yymsp[-1].minor.yy328.unique;
    yymsp[-4].minor.yy61->upper = yymsp[-3].minor.yy58.upper_limit;
    yymsp[-4].minor.yy61->lower = yymsp[-3].minor.yy58.lower_limit;
}
#line 4162 "expparse.c"
        break;
      case 137: /* conformant_aggregation ::= TOK_SET TOK_OF parameter_type */
      case 248: /* set_type ::= TOK_SET TOK_OF attribute_type */ yytestcase(yyruleno==248);
#line 1239 "expparse.y"
{
    yymsp[-2].minor.yy61 = TYPEBODYcreate(set_);
    yymsp[-2].minor.yy61->base = yymsp[0].minor.yy211;
}
#line 4171 "expparse.c"
        break;
      case 138: /* conformant_aggregation ::= TOK_SET bound_spec TOK_OF parameter_type */
#line 1244 "expparse.y"
{
    yymsp[-3].minor.yy61 = TYPEBODYcreate(set_);
    yymsp[-3].minor.yy61->base = yymsp[0].minor.yy211;
    yymsp[-3].minor.yy61->upper = yymsp[-2].minor.yy58.upper_limit;
    yymsp[-3].minor.yy61->lower = yymsp[-2].minor.yy58.lower_limit;
}
#line 4181 "expparse.c"
        break;
      case 139: /* generic_type ::= TOK_GENERIC */
#line 1252 "expparse.y"
{
    yymsp[0].minor.yy211 = Type_Generic;

    if (tag_count < 0) {
        Symbol sym;
        sym.line = yylineno;
        sym.filename = current_filename;
        ERRORreport_with_symbol(UNLABELLED_PARAM_TYPE, &sym,
        CURRENT_SCOPE_NAME);
    }
}
#line 4196 "expparse.c"
        break;
      case 140: /* generic_type ::= TOK_GENERIC TOK_COLON TOK_IDENTIFIER */
#line 1264 "expparse.y"
{
    TypeBody g = TYPEBODYcreate(generic_);
    yymsp[-2].minor.yy211 = TYPEcreate_from_body_anonymously(g);

    SCOPEadd_super(yymsp[-2].minor.yy211);

    g->tag = TYPEcreate_user_defined_tag(yymsp[-2].minor.yy211, CURRENT_SCOPE, yymsp[0].minor.yy0.symbol);
    if (g->tag) {
        SCOPEadd_super(g->tag);
    }
}
#line 4211 "expparse.c"
        break;
      case 141: /* id_list ::= TOK_IDENTIFIER */
#line 1277 "expparse.y"
{
    yylhsminor.yy235 = LISTcreate();
    LISTadd_last(yylhsminor.yy235, (Generic)yymsp[0].minor.yy0.symbol);

}
#line 4220 "expparse.c"
  yymsp[0].minor.yy235 = yylhsminor.yy235;
        break;
      case 142: /* id_list ::= id_list TOK_COMMA TOK_IDENTIFIER */
#line 1283 "expparse.y"
{
    yyerrok;

    yylhsminor.yy235 = yymsp[-2].minor.yy235;
    LISTadd_last(yylhsminor.yy235, (Generic)yymsp[0].minor.yy0.symbol);
}
#line 4231 "expparse.c"
  yymsp[-2].minor.yy235 = yylhsminor.yy235;
        break;
      case 143: /* identifier ::= TOK_SELF */
#line 1291 "expparse.y"
{
    yymsp[0].minor.yy509 = EXPcreate(Type_Self);
}
#line 4239 "expparse.c"
        break;
      case 144: /* identifier ::= TOK_QUESTION_MARK */
#line 1295 "expparse.y"
{
    yymsp[0].minor.yy509 = LITERAL_INFINITY;
}
#line 4246 "expparse.c"
        break;
      case 145: /* identifier ::= TOK_IDENTIFIER */
#line 1299 "expparse.y"
{
    yylhsminor.yy509 = EXPcreate(Type_Identifier);
    yylhsminor.yy509->symbol = *(yymsp[0].minor.yy0.symbol);
    SYMBOL_destroy(yymsp[0].minor.yy0.symbol);
}
#line 4255 "expparse.c"
  yymsp[0].minor.yy509 = yylhsminor.yy509;
        break;
      case 146: /* if_statement ::= TOK_IF expression TOK_THEN statement_rep TOK_END_IF semicolon */
#line 1307 "expparse.y"
{
    yymsp[-5].minor.yy242 = CONDcreate(yymsp[-4].minor.yy509, yymsp[-2].minor.yy235, STATEMENT_LIST_NULL);
}
#line 4263 "expparse.c"
        break;
      case 147: /* if_statement ::= TOK_IF expression TOK_THEN statement_rep TOK_ELSE statement_rep TOK_END_IF semicolon */
#line 1312 "expparse.y"
{
    yymsp[-7].minor.yy242 = CONDcreate(yymsp[-6].minor.yy509, yymsp[-4].minor.yy235, yymsp[-2].minor.yy235);
}
#line 4270 "expparse.c"
        break;
      case 148: /* include_directive ::= TOK_INCLUDE TOK_STRING_LITERAL semicolon */
#line 1317 "expparse.y"
{
    SCANinclude_file(yymsp[-1].minor.yy0.string);
}
#line 4277 "expparse.c"
        break;
      case 149: /* increment_control ::= TOK_IDENTIFIER TOK_ASSIGNMENT expression TOK_TO expression by_expression */
#line 1323 "expparse.y"
{
    Increment i = INCR_CTLcreate(yymsp[-5].minor.yy0.symbol, yymsp[-3].minor.yy509, yymsp[-1].minor.yy509, yymsp[0].minor.yy509);

    /* scope doesn't really have/need a name, I suppose */
    /* naming it by the iterator variable is fine */

    PUSH_SCOPE(i, (Symbol *)0, OBJ_INCREMENT);
}
#line 4289 "expparse.c"
        break;
      case 151: /* rename ::= TOK_IDENTIFIER */
#line 1341 "expparse.y"
{
    (*interface_func)(CURRENT_SCOPE, interface_schema, yymsp[0].minor.yy0.symbol, yymsp[0].minor.yy0.symbol);
}
#line 4296 "expparse.c"
        break;
      case 152: /* rename ::= TOK_IDENTIFIER TOK_AS TOK_IDENTIFIER */
#line 1345 "expparse.y"
{
    (*interface_func)(CURRENT_SCOPE, interface_schema, yymsp[-2].minor.yy0.symbol, yymsp[0].minor.yy0.symbol);
}
#line 4303 "expparse.c"
        break;
      case 154: /* rename_list ::= rename_list TOK_COMMA rename */
      case 156: /* reference_clause ::= reference_head parened_rename_list semicolon */ yytestcase(yyruleno==156);
      case 159: /* use_clause ::= use_head parened_rename_list semicolon */ yytestcase(yyruleno==159);
      case 241: /* schema_body ::= interface_specification_list constant_decl block_list */ yytestcase(yyruleno==241);
      case 286: /* type_decl ::= td_start TOK_END_TYPE semicolon */ yytestcase(yyruleno==286);
#line 1354 "expparse.y"
{
    yylhsminor.yy0 = yymsp[-2].minor.yy0;
}
#line 4314 "expparse.c"
  yymsp[-2].minor.yy0 = yylhsminor.yy0;
        break;
      case 155: /* reference_clause ::= TOK_REFERENCE TOK_FROM TOK_IDENTIFIER semicolon */
#line 1364 "expparse.y"
{
    if (!CURRENT_SCHEMA->ref_schemas) {
        CURRENT_SCHEMA->ref_schemas = LISTcreate();
    }

    LISTadd_last(CURRENT_SCHEMA->ref_schemas, (Generic)yymsp[-1].minor.yy0.symbol);
}
#line 4326 "expparse.c"
        break;
      case 157: /* reference_head ::= TOK_REFERENCE TOK_FROM TOK_IDENTIFIER */
#line 1377 "expparse.y"
{
    interface_schema = yymsp[0].minor.yy0.symbol;
    interface_func = SCHEMAadd_reference;
}
#line 4334 "expparse.c"
        break;
      case 158: /* use_clause ::= TOK_USE TOK_FROM TOK_IDENTIFIER semicolon */
#line 1383 "expparse.y"
{
    if (!CURRENT_SCHEMA->use_schemas) {
        CURRENT_SCHEMA->use_schemas = LISTcreate();
    }

    LISTadd_last(CURRENT_SCHEMA->use_schemas, (Generic)yymsp[-1].minor.yy0.symbol);
}
#line 4345 "expparse.c"
        break;
      case 160: /* use_head ::= TOK_USE TOK_FROM TOK_IDENTIFIER */
#line 1396 "expparse.y"
{
    interface_schema = yymsp[0].minor.yy0.symbol;
    interface_func = SCHEMAadd_use;
}
#line 4353 "expparse.c"
        break;
      case 164: /* interval ::= TOK_LEFT_CURL simple_expression rel_op simple_expression rel_op simple_expression right_curl */
#line 1419 "expparse.y"
{
    Expression    tmp1, tmp2;

    yymsp[-6].minor.yy509 = (Expression)0;
    tmp1 = BIN_EXPcreate(yymsp[-4].minor.yy282, yymsp[-5].minor.yy509, yymsp[-3].minor.yy509);
    tmp2 = BIN_EXPcreate(yymsp[-2].minor.yy282, yymsp[-3].minor.yy509, yymsp[-1].minor.yy509);
    yymsp[-6].minor.yy509 = BIN_EXPcreate(OP_AND, tmp1, tmp2);
}
#line 4365 "expparse.c"
        break;
      case 165: /* set_or_bag_of_entity ::= defined_type */
      case 281: /* type ::= defined_type */ yytestcase(yyruleno==281);
#line 1431 "expparse.y"
{
    yylhsminor.yy236.type = yymsp[0].minor.yy211;
    yylhsminor.yy236.body = 0;
}
#line 4374 "expparse.c"
  yymsp[0].minor.yy236 = yylhsminor.yy236;
        break;
      case 166: /* set_or_bag_of_entity ::= TOK_SET TOK_OF defined_type */
#line 1436 "expparse.y"
{
    yymsp[-2].minor.yy236.type = 0;
    yymsp[-2].minor.yy236.body = TYPEBODYcreate(set_);
    yymsp[-2].minor.yy236.body->base = yymsp[0].minor.yy211;

}
#line 4385 "expparse.c"
        break;
      case 167: /* set_or_bag_of_entity ::= TOK_SET bound_spec TOK_OF defined_type */
#line 1443 "expparse.y"
{
    yymsp[-3].minor.yy236.type = 0; 
    yymsp[-3].minor.yy236.body = TYPEBODYcreate(set_);
    yymsp[-3].minor.yy236.body->base = yymsp[0].minor.yy211;
    yymsp[-3].minor.yy236.body->upper = yymsp[-2].minor.yy58.upper_limit;
    yymsp[-3].minor.yy236.body->lower = yymsp[-2].minor.yy58.lower_limit;
}
#line 4396 "expparse.c"
        break;
      case 168: /* set_or_bag_of_entity ::= TOK_BAG bound_spec TOK_OF defined_type */
#line 1451 "expparse.y"
{
    yymsp[-3].minor.yy236.type = 0;
    yymsp[-3].minor.yy236.body = TYPEBODYcreate(bag_);
    yymsp[-3].minor.yy236.body->base = yymsp[0].minor.yy211;
    yymsp[-3].minor.yy236.body->upper = yymsp[-2].minor.yy58.upper_limit;
    yymsp[-3].minor.yy236.body->lower = yymsp[-2].minor.yy58.lower_limit;
}
#line 4407 "expparse.c"
        break;
      case 169: /* set_or_bag_of_entity ::= TOK_BAG TOK_OF defined_type */
#line 1459 "expparse.y"
{
    yymsp[-2].minor.yy236.type = 0;
    yymsp[-2].minor.yy236.body = TYPEBODYcreate(bag_);
    yymsp[-2].minor.yy236.body->base = yymsp[0].minor.yy211;
}
#line 4416 "expparse.c"
        break;
      case 172: /* inverse_attr ::= attribute_decl TOK_COLON set_or_bag_of_entity TOK_FOR TOK_IDENTIFIER semicolon */
#line 1486 "expparse.y"
{
    if (yymsp[-3].minor.yy236.type) {
        yylhsminor.yy319 = VARcreate(yymsp[-5].minor.yy509, yymsp[-3].minor.yy236.type);
    } else {
        Type t = TYPEcreate_from_body_anonymously(yymsp[-3].minor.yy236.body);
        SCOPEadd_super(t);
        yylhsminor.yy319 = VARcreate(yymsp[-5].minor.yy509, t);
    }

    yylhsminor.yy319->flags.attribute = true;
    yylhsminor.yy319->inverse_symbol = yymsp[-1].minor.yy0.symbol;
}
#line 4432 "expparse.c"
  yymsp[-5].minor.yy319 = yylhsminor.yy319;
        break;
      case 176: /* list_type ::= TOK_LIST bound_spec TOK_OF unique attribute_type */
#line 1520 "expparse.y"
{
    yymsp[-4].minor.yy61 = TYPEBODYcreate(list_);
    yymsp[-4].minor.yy61->base = yymsp[0].minor.yy211;
    yymsp[-4].minor.yy61->flags.unique = yymsp[-1].minor.yy328.unique;
    yymsp[-4].minor.yy61->lower = yymsp[-3].minor.yy58.lower_limit;
    yymsp[-4].minor.yy61->upper = yymsp[-3].minor.yy58.upper_limit;
}
#line 4444 "expparse.c"
        break;
      case 177: /* list_type ::= TOK_LIST TOK_OF unique attribute_type */
#line 1528 "expparse.y"
{
    yymsp[-3].minor.yy61 = TYPEBODYcreate(list_);
    yymsp[-3].minor.yy61->base = yymsp[0].minor.yy211;
    yymsp[-3].minor.yy61->flags.unique = yymsp[-1].minor.yy328.unique;
}
#line 4453 "expparse.c"
        break;
      case 178: /* literal ::= TOK_INTEGER_LITERAL */
#line 1535 "expparse.y"
{
    if (yymsp[0].minor.yy0.iVal == 0) {
        yylhsminor.yy509 = LITERAL_ZERO;
    } else if (yymsp[0].minor.yy0.iVal == 1) {
    yylhsminor.yy509 = LITERAL_ONE;
    } else {
    yylhsminor.yy509 = EXPcreate_simple(Type_Integer);
    yylhsminor.yy509->u.integer = (int)yymsp[0].minor.yy0.iVal;
    resolved_all(yylhsminor.yy509);
    }
}
#line 4468 "expparse.c"
  yymsp[0].minor.yy509 = yylhsminor.yy509;
        break;
      case 179: /* literal ::= TOK_REAL_LITERAL */
#line 1547 "expparse.y"
{
    /* if rVal (a double) is nonzero and has magnitude <= the smallest non-denormal float, print a warning */
    if( ( fabs( yymsp[0].minor.yy0.rVal ) <= FLT_MIN ) && ( fabs( yymsp[0].minor.yy0.rVal ) > 0 ) ) {
        Symbol sym;
        sym.line = yylineno;
        sym.filename = current_filename;
        ERRORreport_with_symbol(WARN_SMALL_REAL, &sym, yymsp[0].minor.yy0.rVal );
    }
    if( fabs( yymsp[0].minor.yy0.rVal ) < DBL_MIN ) {
        yylhsminor.yy509 = LITERAL_ZERO;
    } else {
        yylhsminor.yy509 = EXPcreate_simple(Type_Real);
        yylhsminor.yy509->u.real = yymsp[0].minor.yy0.rVal;
        resolved_all(yylhsminor.yy509);
    }
}
#line 4489 "expparse.c"
  yymsp[0].minor.yy509 = yylhsminor.yy509;
        break;
      case 180: /* literal ::= TOK_STRING_LITERAL */
#line 1564 "expparse.y"
{
    yylhsminor.yy509 = EXPcreate_simple(Type_String);
    yylhsminor.yy509->symbol.name = yymsp[0].minor.yy0.string;
    resolved_all(yylhsminor.yy509);
}
#line 4499 "expparse.c"
  yymsp[0].minor.yy509 = yylhsminor.yy509;
        break;
      case 181: /* literal ::= TOK_STRING_LITERAL_ENCODED */
#line 1570 "expparse.y"
{
    yylhsminor.yy509 = EXPcreate_simple(Type_String_Encoded);
    yylhsminor.yy509->symbol.name = yymsp[0].minor.yy0.string;
    resolved_all(yylhsminor.yy509);
}
#line 4509 "expparse.c"
  yymsp[0].minor.yy509 = yylhsminor.yy509;
        break;
      case 182: /* literal ::= TOK_LOGICAL_LITERAL */
#line 1576 "expparse.y"
{
    yylhsminor.yy509 = EXPcreate_simple(Type_Logical);
    yylhsminor.yy509->u.logical = yymsp[0].minor.yy0.logical;
    resolved_all(yylhsminor.yy509);
}
#line 4519 "expparse.c"
  yymsp[0].minor.yy509 = yylhsminor.yy509;
        break;
      case 183: /* literal ::= TOK_BINARY_LITERAL */
#line 1582 "expparse.y"
{
    yylhsminor.yy509 = EXPcreate_simple(Type_Binary);
    yylhsminor.yy509->symbol.name = yymsp[0].minor.yy0.binary;
    resolved_all(yylhsminor.yy509);
}
#line 4529 "expparse.c"
  yymsp[0].minor.yy509 = yylhsminor.yy509;
        break;
      case 186: /* local_variable ::= id_list TOK_COLON parameter_type semicolon */
#line 1598 "expparse.y"
{
    Expression e;
    Variable v;
    LISTdo(yymsp[-3].minor.yy235, sym, Symbol *)

    /* convert symbol to name-expression */

    e = EXPcreate(Type_Attribute);
    e->symbol = *sym; SYMBOL_destroy(sym);
    v = VARcreate(e, yymsp[-1].minor.yy211);
    v->offset = local_var_count++;
    DICTdefine(CURRENT_SCOPE->symbol_table, e->symbol.name, (Generic)v, &e->symbol, OBJ_VARIABLE);
    LISTod;
    LISTfree(yymsp[-3].minor.yy235);
}
#line 4549 "expparse.c"
        break;
      case 187: /* local_variable ::= id_list TOK_COLON parameter_type local_initializer semicolon */
#line 1615 "expparse.y"
{
    Expression e;
    Variable v;
    LISTdo(yymsp[-4].minor.yy235, sym, Symbol *)
    e = EXPcreate(Type_Attribute);
    e->symbol = *sym; SYMBOL_destroy(sym);
    v = VARcreate(e, yymsp[-2].minor.yy211);
    v->offset = local_var_count++;
    v->initializer = yymsp[-1].minor.yy509;
    DICTdefine(CURRENT_SCOPE->symbol_table, e->symbol.name, (Generic)v,
    &e->symbol, OBJ_VARIABLE);
    LISTod;
    LISTfree(yymsp[-4].minor.yy235);
}
#line 4567 "expparse.c"
        break;
      case 189: /* local_decl_rules_on ::= */
#line 1639 "expparse.y"
{
    tag_count = 0; /* don't signal an error if we find a generic_type */
    local_var_count = 0; /* used to keep local var decl's in the same order */
}
#line 4575 "expparse.c"
        break;
      case 190: /* local_decl_rules_off ::= */
#line 1645 "expparse.y"
{
    tag_count = -1; /* signal an error if we find a generic_type */
}
#line 4582 "expparse.c"
        break;
      case 191: /* defined_type ::= TOK_IDENTIFIER */
#line 1650 "expparse.y"
{
    yylhsminor.yy211 = TYPEcreate_name(yymsp[0].minor.yy0.symbol);
    SCOPEadd_super(yylhsminor.yy211);
    SYMBOL_destroy(yymsp[0].minor.yy0.symbol);
}
#line 4591 "expparse.c"
  yymsp[0].minor.yy211 = yylhsminor.yy211;
        break;
      case 192: /* defined_type_list ::= defined_type */
#line 1657 "expparse.y"
{
    yylhsminor.yy235 = LISTcreate();
    LISTadd_last(yylhsminor.yy235, (Generic)yymsp[0].minor.yy211);

}
#line 4601 "expparse.c"
  yymsp[0].minor.yy235 = yylhsminor.yy235;
        break;
      case 193: /* defined_type_list ::= defined_type_list TOK_COMMA defined_type */
#line 1663 "expparse.y"
{
    yylhsminor.yy235 = yymsp[-2].minor.yy235;
    LISTadd_last(yylhsminor.yy235,
    (Generic)yymsp[0].minor.yy211);
}
#line 4611 "expparse.c"
  yymsp[-2].minor.yy235 = yylhsminor.yy235;
        break;
      case 196: /* optional_or_unique ::= */
#line 1680 "expparse.y"
{
    yymsp[1].minor.yy328.unique = 0;
    yymsp[1].minor.yy328.optional = 0;
}
#line 4620 "expparse.c"
        break;
      case 197: /* optional_or_unique ::= TOK_OPTIONAL */
#line 1685 "expparse.y"
{
    yymsp[0].minor.yy328.unique = 0;
    yymsp[0].minor.yy328.optional = 1;
}
#line 4628 "expparse.c"
        break;
      case 198: /* optional_or_unique ::= TOK_UNIQUE */
#line 1690 "expparse.y"
{
    yymsp[0].minor.yy328.unique = 1;
    yymsp[0].minor.yy328.optional = 0;
}
#line 4636 "expparse.c"
        break;
      case 199: /* optional_or_unique ::= TOK_OPTIONAL TOK_UNIQUE */
      case 200: /* optional_or_unique ::= TOK_UNIQUE TOK_OPTIONAL */ yytestcase(yyruleno==200);
#line 1695 "expparse.y"
{
    yymsp[-1].minor.yy328.unique = 1;
    yymsp[-1].minor.yy328.optional = 1;
}
#line 4645 "expparse.c"
        break;
      case 201: /* optional_fixed ::= */
#line 1706 "expparse.y"
{
    yymsp[1].minor.yy328.fixed = 0;
}
#line 4652 "expparse.c"
        break;
      case 202: /* optional_fixed ::= TOK_FIXED */
#line 1710 "expparse.y"
{
    yymsp[0].minor.yy328.fixed = 1;
}
#line 4659 "expparse.c"
        break;
      case 203: /* precision_spec ::= */
#line 1715 "expparse.y"
{
    yymsp[1].minor.yy509 = (Expression)0;
}
#line 4666 "expparse.c"
        break;
      case 204: /* precision_spec ::= TOK_LEFT_PAREN expression TOK_RIGHT_PAREN */
      case 295: /* unary_expression ::= TOK_LEFT_PAREN expression TOK_RIGHT_PAREN */ yytestcase(yyruleno==295);
#line 1719 "expparse.y"
{
    yymsp[-2].minor.yy509 = yymsp[-1].minor.yy509;
}
#line 4674 "expparse.c"
        break;
      case 205: /* proc_call_statement ::= procedure_id actual_parameters semicolon */
#line 1729 "expparse.y"
{
    yylhsminor.yy242 = PCALLcreate(yymsp[-1].minor.yy235);
    yylhsminor.yy242->symbol = *(yymsp[-2].minor.yy301);
}
#line 4682 "expparse.c"
  yymsp[-2].minor.yy242 = yylhsminor.yy242;
        break;
      case 206: /* proc_call_statement ::= procedure_id semicolon */
#line 1734 "expparse.y"
{
    yylhsminor.yy242 = PCALLcreate((Linked_List)0);
    yylhsminor.yy242->symbol = *(yymsp[-1].minor.yy301);
}
#line 4691 "expparse.c"
  yymsp[-1].minor.yy242 = yylhsminor.yy242;
        break;
      case 207: /* procedure_decl ::= procedure_header action_body TOK_END_PROCEDURE semicolon */
#line 1741 "expparse.y"
{
    PROCput_body(CURRENT_SCOPE, yymsp[-2].minor.yy235);
    ALGput_full_text(CURRENT_SCOPE, yymsp[-3].minor.yy263, SCANtell());
    POP_SCOPE();
}
#line 4701 "expparse.c"
        break;
      case 208: /* procedure_header ::= TOK_PROCEDURE ph_get_line ph_push_scope formal_parameter_list semicolon */
#line 1749 "expparse.y"
{
    Procedure p = CURRENT_SCOPE;
    p->u.proc->parameters = yymsp[-1].minor.yy235;
    p->u.proc->pcount = LISTget_length(yymsp[-1].minor.yy235);
    p->u.proc->tag_count = tag_count;
    tag_count = -1;    /* done with parameters, no new tags can be defined */
    yymsp[-4].minor.yy263 = yymsp[-3].minor.yy263;
}
#line 4713 "expparse.c"
        break;
      case 209: /* ph_push_scope ::= TOK_IDENTIFIER */
#line 1759 "expparse.y"
{
    Procedure p = ALGcreate(OBJ_PROCEDURE);
    tag_count = 0;

    if (print_objects_while_running & OBJ_PROCEDURE_BITS) {
    fprintf( stderr, "parse: %s (procedure)\n", yymsp[0].minor.yy0.symbol->name);
    }

    PUSH_SCOPE(p, yymsp[0].minor.yy0.symbol, OBJ_PROCEDURE);
}
#line 4727 "expparse.c"
        break;
      case 210: /* ph_get_line ::= */
      case 239: /* rh_get_line ::= */ yytestcase(yyruleno==239);
#line 1771 "expparse.y"
{
    yymsp[1].minor.yy263 = SCANtell();
}
#line 4735 "expparse.c"
        break;
      case 213: /* group_ref ::= TOK_BACKSLASH TOK_IDENTIFIER */
#line 1785 "expparse.y"
{
    yymsp[-1].minor.yy509 = BIN_EXPcreate(OP_GROUP, (Expression)0, (Expression)0);
    yymsp[-1].minor.yy509->e.op2 = EXPcreate(Type_Identifier);
    yymsp[-1].minor.yy509->e.op2->symbol = *yymsp[0].minor.yy0.symbol;
    SYMBOL_destroy(yymsp[0].minor.yy0.symbol);
}
#line 4745 "expparse.c"
        break;
      case 214: /* qualifier ::= TOK_DOT TOK_IDENTIFIER */
#line 1793 "expparse.y"
{
    yymsp[-1].minor.yy84.expr = yymsp[-1].minor.yy84.first = BIN_EXPcreate(OP_DOT, (Expression)0, (Expression)0);
    yymsp[-1].minor.yy84.expr->e.op2 = EXPcreate(Type_Identifier);
    yymsp[-1].minor.yy84.expr->e.op2->symbol = *yymsp[0].minor.yy0.symbol;
    SYMBOL_destroy(yymsp[0].minor.yy0.symbol);
}
#line 4755 "expparse.c"
        break;
      case 215: /* qualifier ::= TOK_BACKSLASH TOK_IDENTIFIER */
#line 1800 "expparse.y"
{
    yymsp[-1].minor.yy84.expr = yymsp[-1].minor.yy84.first = BIN_EXPcreate(OP_GROUP, (Expression)0, (Expression)0);
    yymsp[-1].minor.yy84.expr->e.op2 = EXPcreate(Type_Identifier);
    yymsp[-1].minor.yy84.expr->e.op2->symbol = *yymsp[0].minor.yy0.symbol;
    SYMBOL_destroy(yymsp[0].minor.yy0.symbol);
}
#line 4765 "expparse.c"
        break;
      case 216: /* qualifier ::= TOK_LEFT_BRACKET simple_expression TOK_RIGHT_BRACKET */
#line 1809 "expparse.y"
{
    yymsp[-2].minor.yy84.expr = yymsp[-2].minor.yy84.first = BIN_EXPcreate(OP_ARRAY_ELEMENT, (Expression)0,
    (Expression)0);
    yymsp[-2].minor.yy84.expr->e.op2 = yymsp[-1].minor.yy509;
}
#line 4774 "expparse.c"
        break;
      case 217: /* qualifier ::= TOK_LEFT_BRACKET simple_expression TOK_COLON simple_expression TOK_RIGHT_BRACKET */
#line 1818 "expparse.y"
{
    yymsp[-4].minor.yy84.expr = yymsp[-4].minor.yy84.first = TERN_EXPcreate(OP_SUBCOMPONENT, (Expression)0,
    (Expression)0, (Expression)0);
    yymsp[-4].minor.yy84.expr->e.op2 = yymsp[-3].minor.yy509;
    yymsp[-4].minor.yy84.expr->e.op3 = yymsp[-1].minor.yy509;
}
#line 4784 "expparse.c"
        break;
      case 218: /* query_expression ::= query_start expression TOK_RIGHT_PAREN */
#line 1826 "expparse.y"
{
    yylhsminor.yy509 = yymsp[-2].minor.yy509;
    yylhsminor.yy509->u.query->expression = yymsp[-1].minor.yy509;
    POP_SCOPE();
}
#line 4793 "expparse.c"
  yymsp[-2].minor.yy509 = yylhsminor.yy509;
        break;
      case 219: /* query_start ::= TOK_QUERY TOK_LEFT_PAREN TOK_IDENTIFIER TOK_ALL_IN expression TOK_SUCH_THAT */
#line 1834 "expparse.y"
{
    yymsp[-5].minor.yy509 = QUERYcreate(yymsp[-3].minor.yy0.symbol, yymsp[-1].minor.yy509);
    SYMBOL_destroy(yymsp[-3].minor.yy0.symbol);
    PUSH_SCOPE(yymsp[-5].minor.yy509->u.query->scope, (Symbol *)0, OBJ_QUERY);
}
#line 4803 "expparse.c"
        break;
      case 220: /* rel_op ::= TOK_LESS_THAN */
#line 1841 "expparse.y"
{
    yymsp[0].minor.yy282 = OP_LESS_THAN;
}
#line 4810 "expparse.c"
        break;
      case 221: /* rel_op ::= TOK_GREATER_THAN */
#line 1845 "expparse.y"
{
    yymsp[0].minor.yy282 = OP_GREATER_THAN;
}
#line 4817 "expparse.c"
        break;
      case 222: /* rel_op ::= TOK_EQUAL */
#line 1849 "expparse.y"
{
    yymsp[0].minor.yy282 = OP_EQUAL;
}
#line 4824 "expparse.c"
        break;
      case 223: /* rel_op ::= TOK_LESS_EQUAL */
#line 1853 "expparse.y"
{
    yymsp[0].minor.yy282 = OP_LESS_EQUAL;
}
#line 4831 "expparse.c"
        break;
      case 224: /* rel_op ::= TOK_GREATER_EQUAL */
#line 1857 "expparse.y"
{
    yymsp[0].minor.yy282 = OP_GREATER_EQUAL;
}
#line 4838 "expparse.c"
        break;
      case 225: /* rel_op ::= TOK_NOT_EQUAL */
#line 1861 "expparse.y"
{
    yymsp[0].minor.yy282 = OP_NOT_EQUAL;
}
#line 4845 "expparse.c"
        break;
      case 226: /* rel_op ::= TOK_INST_EQUAL */
#line 1865 "expparse.y"
{
    yymsp[0].minor.yy282 = OP_INST_EQUAL;
}
#line 4852 "expparse.c"
        break;
      case 227: /* rel_op ::= TOK_INST_NOT_EQUAL */
#line 1869 "expparse.y"
{
    yymsp[0].minor.yy282 = OP_INST_NOT_EQUAL;
}
#line 4859 "expparse.c"
        break;
      case 228: /* repeat_statement ::= TOK_REPEAT increment_control while_control until_control semicolon statement_rep TOK_END_REPEAT semicolon */
#line 1877 "expparse.y"
{
    yymsp[-7].minor.yy242 = LOOPcreate(CURRENT_SCOPE, yymsp[-5].minor.yy509, yymsp[-4].minor.yy509, yymsp[-2].minor.yy235);

    /* matching PUSH_SCOPE is in increment_control */
    POP_SCOPE();
}
#line 4869 "expparse.c"
        break;
      case 229: /* repeat_statement ::= TOK_REPEAT while_control until_control semicolon statement_rep TOK_END_REPEAT semicolon */
#line 1885 "expparse.y"
{
    yymsp[-6].minor.yy242 = LOOPcreate((struct Scope_ *)0, yymsp[-5].minor.yy509, yymsp[-4].minor.yy509, yymsp[-2].minor.yy235);
}
#line 4876 "expparse.c"
        break;
      case 230: /* return_statement ::= TOK_RETURN semicolon */
#line 1890 "expparse.y"
{
    yymsp[-1].minor.yy242 = RETcreate((Expression)0);
}
#line 4883 "expparse.c"
        break;
      case 231: /* return_statement ::= TOK_RETURN TOK_LEFT_PAREN expression TOK_RIGHT_PAREN semicolon */
#line 1895 "expparse.y"
{
    yymsp[-4].minor.yy242 = RETcreate(yymsp[-2].minor.yy509);
}
#line 4890 "expparse.c"
        break;
      case 233: /* rule_decl ::= rule_header action_body where_rule TOK_END_RULE semicolon */
#line 1906 "expparse.y"
{
    RULEput_body(CURRENT_SCOPE, yymsp[-3].minor.yy235);
    RULEput_where(CURRENT_SCOPE, yymsp[-2].minor.yy235);
    ALGput_full_text(CURRENT_SCOPE, yymsp[-4].minor.yy263, SCANtell());
    POP_SCOPE();
}
#line 4900 "expparse.c"
        break;
      case 234: /* rule_formal_parameter ::= TOK_IDENTIFIER */
#line 1914 "expparse.y"
{
    Expression e;
    Type t;

    /* it's true that we know it will be an entity_ type later */
    TypeBody tb = TYPEBODYcreate(set_);
    tb->base = TYPEcreate_name(yymsp[0].minor.yy0.symbol);
    SCOPEadd_super(tb->base);
    t = TYPEcreate_from_body_anonymously(tb);
    SCOPEadd_super(t);
    e = EXPcreate_from_symbol(t, yymsp[0].minor.yy0.symbol);
    yylhsminor.yy319 = VARcreate(e, t);
    yylhsminor.yy319->flags.attribute = true;
    yylhsminor.yy319->flags.parameter = true;

    /* link it in to the current scope's dict */
    DICTdefine(CURRENT_SCOPE->symbol_table, yymsp[0].minor.yy0.symbol->name, (Generic)yylhsminor.yy319,
    yymsp[0].minor.yy0.symbol, OBJ_VARIABLE);
}
#line 4923 "expparse.c"
  yymsp[0].minor.yy319 = yylhsminor.yy319;
        break;
      case 235: /* rule_formal_parameter_list ::= rule_formal_parameter */
#line 1935 "expparse.y"
{
    yylhsminor.yy235 = LISTcreate();
    LISTadd_last(yylhsminor.yy235, (Generic)yymsp[0].minor.yy319); 
}
#line 4932 "expparse.c"
  yymsp[0].minor.yy235 = yylhsminor.yy235;
        break;
      case 236: /* rule_formal_parameter_list ::= rule_formal_parameter_list TOK_COMMA rule_formal_parameter */
#line 1941 "expparse.y"
{
    yylhsminor.yy235 = yymsp[-2].minor.yy235;
    LISTadd_last(yylhsminor.yy235, (Generic)yymsp[0].minor.yy319);
}
#line 4941 "expparse.c"
  yymsp[-2].minor.yy235 = yylhsminor.yy235;
        break;
      case 237: /* rule_header ::= rh_start rule_formal_parameter_list TOK_RIGHT_PAREN semicolon */
#line 1948 "expparse.y"
{
    CURRENT_SCOPE->u.rule->parameters = yymsp[-2].minor.yy235;

    yylhsminor.yy263 = yymsp[-3].minor.yy263;
}
#line 4951 "expparse.c"
  yymsp[-3].minor.yy263 = yylhsminor.yy263;
        break;
      case 238: /* rh_start ::= TOK_RULE rh_get_line TOK_IDENTIFIER TOK_FOR TOK_LEFT_PAREN */
#line 1956 "expparse.y"
{
    Rule r = ALGcreate(OBJ_RULE);

    if (print_objects_while_running & OBJ_RULE_BITS) {
    fprintf( stderr, "parse: %s (rule)\n", yymsp[-2].minor.yy0.symbol->name);
    }

    PUSH_SCOPE(r, yymsp[-2].minor.yy0.symbol, OBJ_RULE);

    yymsp[-4].minor.yy263 = yymsp[-3].minor.yy263;
}
#line 4967 "expparse.c"
        break;
      case 242: /* schema_decl ::= schema_header schema_body TOK_END_SCHEMA semicolon */
#line 1983 "expparse.y"
{
    POP_SCOPE();
}
#line 4974 "expparse.c"
        break;
      case 244: /* schema_header ::= TOK_SCHEMA TOK_IDENTIFIER semicolon */
#line 1992 "expparse.y"
{
    Schema schema = ( Schema ) DICTlookup(CURRENT_SCOPE->symbol_table, yymsp[-1].minor.yy0.symbol->name);

    if (print_objects_while_running & OBJ_SCHEMA_BITS) {
    fprintf( stderr, "parse: %s (schema)\n", yymsp[-1].minor.yy0.symbol->name);
    }

    if (EXPRESSignore_duplicate_schemas && schema) {
    SCANskip_to_end_schema(parseData.scanner);
    PUSH_SCOPE_DUMMY();
    } else {
    schema = SCHEMAcreate();
    LISTadd_last(PARSEnew_schemas, (Generic)schema);
    PUSH_SCOPE(schema, yymsp[-1].minor.yy0.symbol, OBJ_SCHEMA);
    }
}
#line 4994 "expparse.c"
        break;
      case 245: /* select_type ::= TOK_SELECT TOK_LEFT_PAREN defined_type_list TOK_RIGHT_PAREN */
#line 2011 "expparse.y"
{
    yymsp[-3].minor.yy61 = TYPEBODYcreate(select_);
    yymsp[-3].minor.yy61->list = yymsp[-1].minor.yy235;
}
#line 5002 "expparse.c"
        break;
      case 247: /* set_type ::= TOK_SET bound_spec TOK_OF attribute_type */
#line 2022 "expparse.y"
{
    yymsp[-3].minor.yy61 = TYPEBODYcreate(set_);
    yymsp[-3].minor.yy61->base = yymsp[0].minor.yy211;
    yymsp[-3].minor.yy61->lower = yymsp[-2].minor.yy58.lower_limit;
    yymsp[-3].minor.yy61->upper = yymsp[-2].minor.yy58.upper_limit;
}
#line 5012 "expparse.c"
        break;
      case 249: /* skip_statement ::= TOK_SKIP semicolon */
#line 2035 "expparse.y"
{
    yymsp[-1].minor.yy242 = STATEMENT_SKIP;
}
#line 5019 "expparse.c"
        break;
      case 250: /* statement ::= alias_statement */
      case 251: /* statement ::= assignment_statement */ yytestcase(yyruleno==251);
      case 252: /* statement ::= case_statement */ yytestcase(yyruleno==252);
      case 253: /* statement ::= compound_statement */ yytestcase(yyruleno==253);
      case 254: /* statement ::= escape_statement */ yytestcase(yyruleno==254);
      case 255: /* statement ::= if_statement */ yytestcase(yyruleno==255);
      case 256: /* statement ::= proc_call_statement */ yytestcase(yyruleno==256);
      case 257: /* statement ::= repeat_statement */ yytestcase(yyruleno==257);
      case 258: /* statement ::= return_statement */ yytestcase(yyruleno==258);
      case 259: /* statement ::= skip_statement */ yytestcase(yyruleno==259);
#line 2040 "expparse.y"
{
    yylhsminor.yy242 = yymsp[0].minor.yy242;
}
#line 5035 "expparse.c"
  yymsp[0].minor.yy242 = yylhsminor.yy242;
        break;
      case 262: /* statement_rep ::= statement statement_rep */
#line 2089 "expparse.y"
{
    yylhsminor.yy235 = yymsp[0].minor.yy235;
    LISTadd_first(yylhsminor.yy235, (Generic)yymsp[-1].minor.yy242); 
}
#line 5044 "expparse.c"
  yymsp[-1].minor.yy235 = yylhsminor.yy235;
        break;
      case 263: /* subsuper_decl ::= */
#line 2099 "expparse.y"
{
    yymsp[1].minor.yy302.subtypes = EXPRESSION_NULL;
    yymsp[1].minor.yy302.abstract = false;
    yymsp[1].minor.yy302.supertypes = LIST_NULL;
}
#line 5054 "expparse.c"
        break;
      case 264: /* subsuper_decl ::= supertype_decl */
#line 2105 "expparse.y"
{
    yylhsminor.yy302.subtypes = yymsp[0].minor.yy325.subtypes;
    yylhsminor.yy302.abstract = yymsp[0].minor.yy325.abstract;
    yylhsminor.yy302.supertypes = LIST_NULL;
}
#line 5063 "expparse.c"
  yymsp[0].minor.yy302 = yylhsminor.yy302;
        break;
      case 265: /* subsuper_decl ::= subtype_decl */
#line 2111 "expparse.y"
{
    yylhsminor.yy302.supertypes = yymsp[0].minor.yy235;
    yylhsminor.yy302.abstract = false;
    yylhsminor.yy302.subtypes = EXPRESSION_NULL;
}
#line 5073 "expparse.c"
  yymsp[0].minor.yy302 = yylhsminor.yy302;
        break;
      case 266: /* subsuper_decl ::= supertype_decl subtype_decl */
#line 2117 "expparse.y"
{
    yylhsminor.yy302.subtypes = yymsp[-1].minor.yy325.subtypes;
    yylhsminor.yy302.abstract = yymsp[-1].minor.yy325.abstract;
    yylhsminor.yy302.supertypes = yymsp[0].minor.yy235;
}
#line 5083 "expparse.c"
  yymsp[-1].minor.yy302 = yylhsminor.yy302;
        break;
      case 267: /* subtype_decl ::= TOK_SUBTYPE TOK_OF TOK_LEFT_PAREN defined_type_list TOK_RIGHT_PAREN */
#line 2125 "expparse.y"
{
    yymsp[-4].minor.yy235 = yymsp[-1].minor.yy235;
}
#line 5091 "expparse.c"
        break;
      case 268: /* supertype_decl ::= TOK_ABSTRACT TOK_SUPERTYPE */
#line 2130 "expparse.y"
{
    yymsp[-1].minor.yy325.subtypes = (Expression)0;
    yymsp[-1].minor.yy325.abstract = true;
}
#line 5099 "expparse.c"
        break;
      case 269: /* supertype_decl ::= TOK_SUPERTYPE TOK_OF TOK_LEFT_PAREN supertype_expression TOK_RIGHT_PAREN */
#line 2136 "expparse.y"
{
    yymsp[-4].minor.yy325.subtypes = yymsp[-1].minor.yy509;
    yymsp[-4].minor.yy325.abstract = false;
}
#line 5107 "expparse.c"
        break;
      case 270: /* supertype_decl ::= TOK_ABSTRACT TOK_SUPERTYPE TOK_OF TOK_LEFT_PAREN supertype_expression TOK_RIGHT_PAREN */
#line 2142 "expparse.y"
{
    yymsp[-5].minor.yy325.subtypes = yymsp[-1].minor.yy509;
    yymsp[-5].minor.yy325.abstract = true;
}
#line 5115 "expparse.c"
        break;
      case 271: /* supertype_expression ::= supertype_factor */
#line 2148 "expparse.y"
{
    yylhsminor.yy509 = yymsp[0].minor.yy325.subtypes;
}
#line 5122 "expparse.c"
  yymsp[0].minor.yy509 = yylhsminor.yy509;
        break;
      case 272: /* supertype_expression ::= supertype_expression TOK_AND supertype_factor */
#line 2152 "expparse.y"
{
    yylhsminor.yy509 = BIN_EXPcreate(OP_AND, yymsp[-2].minor.yy509, yymsp[0].minor.yy325.subtypes);
}
#line 5130 "expparse.c"
  yymsp[-2].minor.yy509 = yylhsminor.yy509;
        break;
      case 273: /* supertype_expression ::= supertype_expression TOK_ANDOR supertype_factor */
#line 2157 "expparse.y"
{
    yylhsminor.yy509 = BIN_EXPcreate(OP_ANDOR, yymsp[-2].minor.yy509, yymsp[0].minor.yy325.subtypes);
}
#line 5138 "expparse.c"
  yymsp[-2].minor.yy509 = yylhsminor.yy509;
        break;
      case 275: /* supertype_expression_list ::= supertype_expression_list TOK_COMMA supertype_expression */
#line 2168 "expparse.y"
{
    LISTadd_last(yymsp[-2].minor.yy235, (Generic)yymsp[0].minor.yy509);
    yylhsminor.yy235 = yymsp[-2].minor.yy235;
}
#line 5147 "expparse.c"
  yymsp[-2].minor.yy235 = yylhsminor.yy235;
        break;
      case 276: /* supertype_factor ::= identifier */
#line 2174 "expparse.y"
{
    yylhsminor.yy325.subtypes = yymsp[0].minor.yy509;
}
#line 5155 "expparse.c"
  yymsp[0].minor.yy325 = yylhsminor.yy325;
        break;
      case 277: /* supertype_factor ::= oneof_op TOK_LEFT_PAREN supertype_expression_list TOK_RIGHT_PAREN */
#line 2179 "expparse.y"
{
    yymsp[-3].minor.yy325.subtypes = EXPcreate(Type_Oneof);
    yymsp[-3].minor.yy325.subtypes->u.list = yymsp[-1].minor.yy235;
}
#line 5164 "expparse.c"
        break;
      case 278: /* supertype_factor ::= TOK_LEFT_PAREN supertype_expression TOK_RIGHT_PAREN */
#line 2184 "expparse.y"
{
    yymsp[-2].minor.yy325.subtypes = yymsp[-1].minor.yy509;
}
#line 5171 "expparse.c"
        break;
      case 279: /* type ::= aggregation_type */
      case 280: /* type ::= basic_type */ yytestcase(yyruleno==280);
      case 282: /* type ::= select_type */ yytestcase(yyruleno==282);
#line 2189 "expparse.y"
{
    yylhsminor.yy236.type = 0;
    yylhsminor.yy236.body = yymsp[0].minor.yy61;
}
#line 5181 "expparse.c"
  yymsp[0].minor.yy236 = yylhsminor.yy236;
        break;
      case 284: /* type_item_body ::= type */
#line 2214 "expparse.y"
{
    CURRENT_SCOPE->u.type->head = yymsp[0].minor.yy236.type;
    CURRENT_SCOPE->u.type->body = yymsp[0].minor.yy236.body;
}
#line 5190 "expparse.c"
        break;
      case 285: /* ti_start ::= TOK_IDENTIFIER TOK_EQUAL */
#line 2222 "expparse.y"
{
    Type t = TYPEcreate_name(yymsp[-1].minor.yy0.symbol);
    PUSH_SCOPE(t, yymsp[-1].minor.yy0.symbol, OBJ_TYPE);
}
#line 5198 "expparse.c"
        break;
      case 287: /* td_start ::= TOK_TYPE type_item where_rule_OPT */
#line 2233 "expparse.y"
{
    CURRENT_SCOPE->where = yymsp[0].minor.yy235;
    POP_SCOPE();
    yylhsminor.yy0 = yymsp[-2].minor.yy0;
}
#line 5207 "expparse.c"
  yymsp[-2].minor.yy0 = yylhsminor.yy0;
        break;
      case 288: /* general_ref ::= assignable group_ref */
#line 2240 "expparse.y"
{
    yymsp[0].minor.yy509->e.op1 = yymsp[-1].minor.yy509;
    yylhsminor.yy509 = yymsp[0].minor.yy509;
}
#line 5216 "expparse.c"
  yymsp[-1].minor.yy509 = yylhsminor.yy509;
        break;
      case 298: /* unary_expression ::= TOK_NOT unary_expression */
#line 2283 "expparse.y"
{
    yymsp[-1].minor.yy509 = UN_EXPcreate(OP_NOT, yymsp[0].minor.yy509);
}
#line 5224 "expparse.c"
        break;
      case 300: /* unary_expression ::= TOK_MINUS unary_expression */
#line 2291 "expparse.y"
{
    yymsp[-1].minor.yy509 = UN_EXPcreate(OP_NEGATE, yymsp[0].minor.yy509);
}
#line 5231 "expparse.c"
        break;
      case 301: /* unique ::= */
#line 2296 "expparse.y"
{
    yymsp[1].minor.yy328.unique = 0;
}
#line 5238 "expparse.c"
        break;
      case 302: /* unique ::= TOK_UNIQUE */
#line 2300 "expparse.y"
{
    yymsp[0].minor.yy328.unique = 1;
}
#line 5245 "expparse.c"
        break;
      case 306: /* labelled_attrib_list ::= qualified_attr_list semicolon */
#line 2327 "expparse.y"
{
    LISTadd_first(yymsp[-1].minor.yy235, (Generic)EXPRESSION_NULL);
    yylhsminor.yy235 = yymsp[-1].minor.yy235;
}
#line 5253 "expparse.c"
  yymsp[-1].minor.yy235 = yylhsminor.yy235;
        break;
      case 307: /* labelled_attrib_list ::= TOK_IDENTIFIER TOK_COLON qualified_attr_list semicolon */
#line 2333 "expparse.y"
{
    LISTadd_first(yymsp[-1].minor.yy235, (Generic)yymsp[-3].minor.yy0.symbol); 
    yylhsminor.yy235 = yymsp[-1].minor.yy235;
}
#line 5262 "expparse.c"
  yymsp[-3].minor.yy235 = yylhsminor.yy235;
        break;
      case 308: /* labelled_attrib_list_list ::= labelled_attrib_list */
#line 2340 "expparse.y"
{
    yylhsminor.yy235 = LISTcreate();
    LISTadd_last(yylhsminor.yy235, (Generic)yymsp[0].minor.yy235);
}
#line 5271 "expparse.c"
  yymsp[0].minor.yy235 = yylhsminor.yy235;
        break;
      case 309: /* labelled_attrib_list_list ::= labelled_attrib_list_list labelled_attrib_list */
#line 2346 "expparse.y"
{
    LISTadd_last(yymsp[-1].minor.yy235, (Generic)yymsp[0].minor.yy235);
    yylhsminor.yy235 = yymsp[-1].minor.yy235;
}
#line 5280 "expparse.c"
  yymsp[-1].minor.yy235 = yylhsminor.yy235;
        break;
      case 310: /* unique_clause ::= */
#line 2352 "expparse.y"
{
    yymsp[1].minor.yy235 = 0;
}
#line 5288 "expparse.c"
        break;
      case 312: /* until_control ::= */
      case 321: /* while_control ::= */ yytestcase(yyruleno==321);
#line 2361 "expparse.y"
{
    yymsp[1].minor.yy509 = 0;
}
#line 5296 "expparse.c"
        break;
      case 314: /* where_clause ::= expression semicolon */
#line 2370 "expparse.y"
{
    yylhsminor.yy228 = WHERE_new();
    yylhsminor.yy228->label = SYMBOLcreate("<unnamed>", yylineno, current_filename);
    yylhsminor.yy228->expr = yymsp[-1].minor.yy509;
}
#line 5305 "expparse.c"
  yymsp[-1].minor.yy228 = yylhsminor.yy228;
        break;
      case 315: /* where_clause ::= TOK_IDENTIFIER TOK_COLON expression semicolon */
#line 2376 "expparse.y"
{
    yylhsminor.yy228 = WHERE_new();
    yylhsminor.yy228->label = yymsp[-3].minor.yy0.symbol;
    yylhsminor.yy228->expr = yymsp[-1].minor.yy509;

    if (!CURRENT_SCOPE->symbol_table) {
    CURRENT_SCOPE->symbol_table = DICTcreate(25);
    }

    DICTdefine(CURRENT_SCOPE->symbol_table, yymsp[-3].minor.yy0.symbol->name, (Generic)yylhsminor.yy228,
    yymsp[-3].minor.yy0.symbol, OBJ_WHERE);
}
#line 5322 "expparse.c"
  yymsp[-3].minor.yy228 = yylhsminor.yy228;
        break;
      case 316: /* where_clause_list ::= where_clause */
#line 2390 "expparse.y"
{
    yylhsminor.yy235 = LISTcreate();
    LISTadd_last(yylhsminor.yy235, (Generic)yymsp[0].minor.yy228);
}
#line 5331 "expparse.c"
  yymsp[0].minor.yy235 = yylhsminor.yy235;
        break;
      case 317: /* where_clause_list ::= where_clause_list where_clause */
#line 2395 "expparse.y"
{
    yylhsminor.yy235 = yymsp[-1].minor.yy235;
    LISTadd_last(yylhsminor.yy235, (Generic)yymsp[0].minor.yy228);
}
#line 5340 "expparse.c"
  yymsp[-1].minor.yy235 = yylhsminor.yy235;
        break;
      case 320: /* where_rule_OPT ::= where_rule */
#line 2410 "expparse.y"
{
    yylhsminor.yy235 = yymsp[0].minor.yy235;
}
#line 5348 "expparse.c"
  yymsp[0].minor.yy235 = yylhsminor.yy235;
        break;
      default:
      /* (323) action_body_item_rep ::= */ yytestcase(yyruleno==323);
      /* (324) block_list ::= */ yytestcase(yyruleno==324);
      /* (325) constant_body_list ::= */ yytestcase(yyruleno==325);
      /* (326) express_file ::= schema_decl_list */ yytestcase(yyruleno==326);
      /* (327) parened_rename_list ::= TOK_LEFT_PAREN rename_list TOK_RIGHT_PAREN */ yytestcase(yyruleno==327);
      /* (328) interface_specification_list ::= */ yytestcase(yyruleno==328);
      /* (329) local_body ::= */ yytestcase(yyruleno==329);
      /* (330) local_decl ::= TOK_LOCAL local_decl_rules_on local_body TOK_END_LOCAL semicolon local_decl_rules_off */ yytestcase(yyruleno==330);
      /* (331) type_item ::= ti_start type_item_body semicolon */ yytestcase(yyruleno==331);
        break;
/********** End reduce actions ************************************************/
  };
  assert( yyruleno<sizeof(yyRuleInfoLhs)/sizeof(yyRuleInfoLhs[0]) );
  yygoto = yyRuleInfoLhs[yyruleno];
  yysize = yyRuleInfoNRhs[yyruleno];
  yyact = yy_find_reduce_action(yymsp[yysize].stateno,(YYCODETYPE)yygoto);

  /* There are no SHIFTREDUCE actions on nonterminals because the table
  ** generator has simplified them to pure REDUCE actions. */
  assert( !(yyact>YY_MAX_SHIFT && yyact<=YY_MAX_SHIFTREDUCE) );

  /* It is not possible for a REDUCE to be followed by an error */
  assert( yyact!=YY_ERROR_ACTION );

  yymsp += yysize+1;
  yypParser->yytos = yymsp;
  yymsp->stateno = (YYACTIONTYPE)yyact;
  yymsp->major = (YYCODETYPE)yygoto;
  yyTraceShift(yypParser, yyact, "... then shift");
  return yyact;
}

/*
** The following code executes when the parse fails
*/
#ifndef YYNOERRORRECOVERY
static void yy_parse_failed(
  yyParser *yypParser           /* The parser */
){
  ParseARG_FETCH
  ParseCTX_FETCH
#ifndef NDEBUG
  if( yyTraceFILE ){
    fprintf(yyTraceFILE,"%sFail!\n",yyTracePrompt);
  }
#endif
  while( yypParser->yytos>yypParser->yystack ) yy_pop_parser_stack(yypParser);
  /* Here code is inserted which will be executed whenever the
  ** parser fails */
/************ Begin %parse_failure code ***************************************/
/************ End %parse_failure code *****************************************/
  ParseARG_STORE /* Suppress warning about unused %extra_argument variable */
  ParseCTX_STORE
}
#endif /* YYNOERRORRECOVERY */

/*
** The following code executes when a syntax error first occurs.
*/
static void yy_syntax_error(
  yyParser *yypParser,           /* The parser */
  int yymajor,                   /* The major type of the error token */
  ParseTOKENTYPE yyminor         /* The minor type of the error token */
){
  ParseARG_FETCH
  ParseCTX_FETCH
#define TOKEN yyminor
/************ Begin %syntax_error code ****************************************/
#line 2423 "expparse.y"

    Symbol sym;

    (void) yymajor; /* quell unused param warning */
    (void) yyminor;
    yyerrstatus++;

    sym.line = yylineno;
    sym.filename = current_filename;

    ERRORreport_with_symbol(SYNTAX, &sym, "Syntax error",
    CURRENT_SCOPE_TYPE_PRINTABLE, CURRENT_SCOPE_NAME);
#line 5433 "expparse.c"
/************ End %syntax_error code ******************************************/
  ParseARG_STORE /* Suppress warning about unused %extra_argument variable */
  ParseCTX_STORE
}

/*
** The following is executed when the parser accepts
*/
static void yy_accept(
  yyParser *yypParser           /* The parser */
){
  ParseARG_FETCH
  ParseCTX_FETCH
#ifndef NDEBUG
  if( yyTraceFILE ){
    fprintf(yyTraceFILE,"%sAccept!\n",yyTracePrompt);
  }
#endif
#ifndef YYNOERRORRECOVERY
  yypParser->yyerrcnt = -1;
#endif
  assert( yypParser->yytos==yypParser->yystack );
  /* Here code is inserted which will be executed whenever the
  ** parser accepts */
/*********** Begin %parse_accept code *****************************************/
/*********** End %parse_accept code *******************************************/
  ParseARG_STORE /* Suppress warning about unused %extra_argument variable */
  ParseCTX_STORE
}

/* The main parser program.
** The first argument is a pointer to a structure obtained from
** "ParseAlloc" which describes the current state of the parser.
** The second argument is the major token number.  The third is
** the minor token.  The fourth optional argument is whatever the
** user wants (and specified in the grammar) and is available for
** use by the action routines.
**
** Inputs:
** <ul>
** <li> A pointer to the parser (an opaque structure.)
** <li> The major token number.
** <li> The minor token number.
** <li> An option argument of a grammar-specified type.
** </ul>
**
** Outputs:
** None.
*/
void Parse(
  void *yyp,                   /* The parser */
  int yymajor,                 /* The major token code number */
  ParseTOKENTYPE yyminor       /* The value for the token */
  ParseARG_PDECL               /* Optional %extra_argument parameter */
){
  YYMINORTYPE yyminorunion;
  YYACTIONTYPE yyact;   /* The parser action. */
#if !defined(YYERRORSYMBOL) && !defined(YYNOERRORRECOVERY)
  int yyendofinput;     /* True if we are at the end of input */
#endif
#ifdef YYERRORSYMBOL
  int yyerrorhit = 0;   /* True if yymajor has invoked an error */
#endif
  yyParser *yypParser = (yyParser*)yyp;  /* The parser */
  ParseCTX_FETCH
  ParseARG_STORE

  assert( yypParser->yytos!=0 );
#if !defined(YYERRORSYMBOL) && !defined(YYNOERRORRECOVERY)
  yyendofinput = (yymajor==0);
#endif

  yyact = yypParser->yytos->stateno;
#ifndef NDEBUG
  if( yyTraceFILE ){
    if( yyact < YY_MIN_REDUCE ){
      fprintf(yyTraceFILE,"%sInput '%s' in state %d\n",
              yyTracePrompt,yyTokenName[yymajor],yyact);
    }else{
      fprintf(yyTraceFILE,"%sInput '%s' with pending reduce %d\n",
              yyTracePrompt,yyTokenName[yymajor],yyact-YY_MIN_REDUCE);
    }
  }
#endif

  while(1){ /* Exit by "break" */
    assert( yypParser->yytos>=yypParser->yystack );
    assert( yyact==yypParser->yytos->stateno );
    yyact = yy_find_shift_action((YYCODETYPE)yymajor,yyact);
    if( yyact >= YY_MIN_REDUCE ){
      unsigned int yyruleno = yyact - YY_MIN_REDUCE; /* Reduce by this rule */
#ifndef NDEBUG
      assert( yyruleno<(int)(sizeof(yyRuleName)/sizeof(yyRuleName[0])) );
      if( yyTraceFILE ){
        int yysize = yyRuleInfoNRhs[yyruleno];
        if( yysize ){
          fprintf(yyTraceFILE, "%sReduce %d [%s]%s, pop back to state %d.\n",
            yyTracePrompt,
            yyruleno, yyRuleName[yyruleno],
            yyruleno<YYNRULE_WITH_ACTION ? "" : " without external action",
            yypParser->yytos[yysize].stateno);
        }else{
          fprintf(yyTraceFILE, "%sReduce %d [%s]%s.\n",
            yyTracePrompt, yyruleno, yyRuleName[yyruleno],
            yyruleno<YYNRULE_WITH_ACTION ? "" : " without external action");
        }
      }
#endif /* NDEBUG */

      /* Check that the stack is large enough to grow by a single entry
      ** if the RHS of the rule is empty.  This ensures that there is room
      ** enough on the stack to push the LHS value */
      if( yyRuleInfoNRhs[yyruleno]==0 ){
#ifdef YYTRACKMAXSTACKDEPTH
        if( (int)(yypParser->yytos - yypParser->yystack)>yypParser->yyhwm ){
          yypParser->yyhwm++;
          assert( yypParser->yyhwm ==
                  (int)(yypParser->yytos - yypParser->yystack));
        }
#endif
        if( yypParser->yytos>=yypParser->yystackEnd ){
          if( yyGrowStack(yypParser) ){
            yyStackOverflow(yypParser);
            break;
          }
        }
      }
      yyact = yy_reduce(yypParser,yyruleno,yymajor,yyminor ParseCTX_PARAM);
    }else if( yyact <= YY_MAX_SHIFTREDUCE ){
      yy_shift(yypParser,yyact,(YYCODETYPE)yymajor,yyminor);
#ifndef YYNOERRORRECOVERY
      yypParser->yyerrcnt--;
#endif
      break;
    }else if( yyact==YY_ACCEPT_ACTION ){
      yypParser->yytos--;
      yy_accept(yypParser);
      return;
    }else{
      assert( yyact == YY_ERROR_ACTION );
      yyminorunion.yy0 = yyminor;
#ifdef YYERRORSYMBOL
      int yymx;
#endif
#ifndef NDEBUG
      if( yyTraceFILE ){
        fprintf(yyTraceFILE,"%sSyntax Error!\n",yyTracePrompt);
      }
#endif
#ifdef YYERRORSYMBOL
      /* A syntax error has occurred.
      ** The response to an error depends upon whether or not the
      ** grammar defines an error token "ERROR".  
      **
      ** This is what we do if the grammar does define ERROR:
      **
      **  * Call the %syntax_error function.
      **
      **  * Begin popping the stack until we enter a state where
      **    it is legal to shift the error symbol, then shift
      **    the error symbol.
      **
      **  * Set the error count to three.
      **
      **  * Begin accepting and shifting new tokens.  No new error
      **    processing will occur until three tokens have been
      **    shifted successfully.
      **
      */
      if( yypParser->yyerrcnt<0 ){
        yy_syntax_error(yypParser,yymajor,yyminor);
      }
      yymx = yypParser->yytos->major;
      if( yymx==YYERRORSYMBOL || yyerrorhit ){
#ifndef NDEBUG
        if( yyTraceFILE ){
          fprintf(yyTraceFILE,"%sDiscard input token %s\n",
             yyTracePrompt,yyTokenName[yymajor]);
        }
#endif
        yy_destructor(yypParser, (YYCODETYPE)yymajor, &yyminorunion);
        yymajor = YYNOCODE;
      }else{
        while( yypParser->yytos > yypParser->yystack ){
          yyact = yy_find_reduce_action(yypParser->yytos->stateno,
                                        YYERRORSYMBOL);
          if( yyact<=YY_MAX_SHIFTREDUCE ) break;
          yy_pop_parser_stack(yypParser);
        }
        if( yypParser->yytos <= yypParser->yystack || yymajor==0 ){
          yy_destructor(yypParser,(YYCODETYPE)yymajor,&yyminorunion);
          yy_parse_failed(yypParser);
#ifndef YYNOERRORRECOVERY
          yypParser->yyerrcnt = -1;
#endif
          yymajor = YYNOCODE;
        }else if( yymx!=YYERRORSYMBOL ){
          yy_shift(yypParser,yyact,YYERRORSYMBOL,yyminor);
        }
      }
      yypParser->yyerrcnt = 3;
      yyerrorhit = 1;
      if( yymajor==YYNOCODE ) break;
      yyact = yypParser->yytos->stateno;
#elif defined(YYNOERRORRECOVERY)
      /* If the YYNOERRORRECOVERY macro is defined, then do not attempt to
      ** do any kind of error recovery.  Instead, simply invoke the syntax
      ** error routine and continue going as if nothing had happened.
      **
      ** Applications can set this macro (for example inside %include) if
      ** they intend to abandon the parse upon the first syntax error seen.
      */
      yy_syntax_error(yypParser,yymajor, yyminor);
      yy_destructor(yypParser,(YYCODETYPE)yymajor,&yyminorunion);
      break;
#else  /* YYERRORSYMBOL is not defined */
      /* This is what we do if the grammar does not define ERROR:
      **
      **  * Report an error message, and throw away the input token.
      **
      **  * If the input token is $, then fail the parse.
      **
      ** As before, subsequent error messages are suppressed until
      ** three input tokens have been successfully shifted.
      */
      if( yypParser->yyerrcnt<=0 ){
        yy_syntax_error(yypParser,yymajor, yyminor);
      }
      yypParser->yyerrcnt = 3;
      yy_destructor(yypParser,(YYCODETYPE)yymajor,&yyminorunion);
      if( yyendofinput ){
        yy_parse_failed(yypParser);
#ifndef YYNOERRORRECOVERY
        yypParser->yyerrcnt = -1;
#endif
      }
      break;
#endif
    }
  }
#ifndef NDEBUG
  if( yyTraceFILE ){
    yyStackEntry *i;
    char cDiv = '[';
    fprintf(yyTraceFILE,"%sReturn. Stack=",yyTracePrompt);
    for(i=&yypParser->yystack[1]; i<=yypParser->yytos; i++){
      fprintf(yyTraceFILE,"%c%s", cDiv, yyTokenName[i->major]);
      cDiv = ' ';
    }
    fprintf(yyTraceFILE,"]\n");
  }
#endif
  return;
}

/*
** Return the fallback token corresponding to canonical token iToken, or
** 0 if iToken has no fallback.
*/
int ParseFallback(int iToken){
#ifdef YYFALLBACK
  assert( iToken<(int)(sizeof(yyFallback)/sizeof(yyFallback[0])) );
  return yyFallback[iToken];
#else
  (void)iToken;
  return 0;
#endif
}
