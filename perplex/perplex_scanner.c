/* Generated by re2c 3.1 on Tue Dec  9 18:41:16 2025 */
#line 1 "scanner.re"
/*                        S C A N N E R . R E
 * BRL-CAD
 *
 * Copyright (c) 1990-2021 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * Copyright (c) 1990 The Regents of the University of California.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following
 * disclaimer in the documentation and/or other materials provided
 * with the distribution.
 *
 * 3. The name of the author may not be used to endorse or promote
 * products derived from this software without specific prior written
 * permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*  Parts of this file are based on sources from the flex project.
 *
 *  This code is derived from software contributed to Berkeley by
 *  Vern Paxson.
 *
 *  The United States Government has rights in this work pursuant
 *  to contract no. DE-AC03-76SF00098 between the United States
 *  Department of Energy and the University of California.
 */
/** @file scanner.re
 *
 * The perplex input scanner. Converts flex-style input to re2c input.
 * Usage:
 *     int tokenID;
 *     perplex_t scanner;
 *      ...
 *     scanner = perplexFileScanner(inFile);
 *     while ((tokenID = yylex(scanner)) != YYEOF) {
 *      ...
 *     }
 *     perplexFree(scanner);
 *     fclose(inFile);
 */
#include <assert.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "perplex.h"
#include "token_type.h"

/* --- from flex's flexdef.h --- */
void buf_init(struct Buf * buf, size_t elem_size);
void buf_destroy(struct Buf * buf);
struct Buf *buf_append(struct Buf * buf, const void *ptr, size_t n_elem);
struct Buf *buf_concat(struct Buf* dest, const struct Buf* src);
struct Buf *buf_strappend(struct Buf *, const char *str);
struct Buf *buf_strnappend(struct Buf *, const char *str, size_t nchars);
struct Buf *buf_strdefine(struct Buf * buf, const char *str, const char *def);
struct Buf *buf_prints(struct Buf *buf, const char *fmt, const char* s);
struct Buf *buf_m4_define(struct Buf *buf, const char* def, const char* val);
struct Buf *buf_m4_undefine(struct Buf *buf, const char* def);
struct Buf *buf_print_strings(struct Buf * buf, FILE* out);
struct Buf *buf_linedir(struct Buf *buf, const char* filename, size_t lineno);

/* --- from flex's misc.c --- */
static void*
allocate_array(size_t size, size_t element_size)
{
    return malloc(element_size * size);
}

static void*
reallocate_array(void *array, size_t size, size_t element_size)
{
    return realloc(array, element_size * size);
}

/* --- from flex's buf.c --- */
/* Take note: The buffer object is sometimes used as a String buffer (one
 * continuous string), and sometimes used as a list of strings, usually line by
 * line.
 *
 * The type is specified in buf_init by the elt_size. If the elt_size is
 * sizeof(char), then the buffer should be treated as string buffer. If the
 * elt_size is sizeof(char*), then the buffer should be treated as a list of
 * strings.
 *
 * Certain functions are only appropriate for one type or the other.
 */

struct Buf*
buf_print_strings(struct Buf * buf, FILE* out)
{
    size_t i;

    if(!buf || !out) {
        return buf;
    }

    for (i = 0; i < buf->nelts; i++) {
        const char *s = ((char**)buf->elts)[i];
        if(s) {
            fprintf(out, "%s", s);
	}
    }
    return buf;
}

/* Append a "%s" formatted string to a string buffer */
struct Buf*
buf_prints(struct Buf *buf, const char *fmt, const char *s)
{
    char *t;

    t = (char*)malloc(strlen(fmt) + strlen(s) + 1);
    sprintf(t, fmt, s);
    buf = buf_strappend(buf, t);
    free(t);
    return buf;
}

/** Append a line directive to the string buffer.
 * @param buf A string buffer.
 * @param filename file name
 * @param lineno line number
 * @return buf
 */
struct Buf*
buf_linedir(struct Buf *buf, const char* filename, size_t lineno)
{
    char *t;
    const char fmt[] = "#line %zu \"%s\"\n";

    t = (char*)malloc(strlen(fmt) + strlen(filename) + (int)(1 + log10(lineno >= 0? lineno : -lineno)) + 1);
    sprintf(t, fmt, lineno, filename);
    buf = buf_strappend(buf, t);
    free(t);
    return buf;
}


/** Append the contents of @a src to @a dest.
 * @param @a dest the destination buffer
 * @param @a dest the source buffer
 * @return @a dest
 */
struct Buf*
buf_concat(struct Buf* dest, const struct Buf* src)
{
    buf_append(dest, src->elts, src->nelts);
    return dest;
}


/* Appends n characters in str to buf. */
struct Buf*
buf_strnappend(struct Buf *buf, const char *str, size_t n)
{
    buf_append(buf, str, n + 1);

    /* "undo" the '\0' character that buf_append() already copied. */
    buf->nelts--;

    return buf;
}

/* Appends characters in str to buf. */
struct Buf*
buf_strappend(struct Buf *buf, const char *str)
{
    return buf_strnappend(buf, str, strlen(str));
}

/* appends "#define str def\n" */
struct Buf*
buf_strdefine(struct Buf *buf, const char *str, const char *def)
{
    buf_strappend(buf, "#define ");
    buf_strappend(buf, " ");
    buf_strappend(buf, str);
    buf_strappend(buf, " ");
    buf_strappend(buf, def);
    buf_strappend(buf, "\n");
    return buf;
}

/** Pushes "m4_define( [[def]], [[val]])m4_dnl" to end of buffer.
 * @param buf A buffer as a list of strings.
 * @param def The m4 symbol to define.
 * @param val The definition; may be NULL.
 * @return buf
 */
struct Buf*
buf_m4_define(struct Buf *buf, const char* def, const char* val)
{
    const char *fmt = "m4_define( [[%s]], [[%s]])m4_dnl\n";
    char *str;

    val = val ? val : "";
    str = (char*)malloc(strlen(fmt) + strlen(def) + strlen(val) + 2);

    sprintf(str, fmt, def, val);
    buf_append(buf, &str, 1);
    return buf;
}

/** Pushes "m4_undefine([[def]])m4_dnl" to end of buffer.
 * @param buf A buffer as a list of strings.
 * @param def The m4 symbol to undefine.
 * @return buf
 */
struct Buf*
buf_m4_undefine(struct Buf *buf, const char* def)
{
    const char *fmt = "m4_undefine( [[%s]])m4_dnl\n";
    char *str;

    str = (char*)malloc(strlen(fmt) + strlen(def) + 2);

    sprintf(str, fmt, def);
    buf_append(buf, &str, 1);
    return buf;
}

/* create buf with 0 elements, each of size elem_size. */
void
buf_init(struct Buf *buf, size_t elem_size)
{
    buf->elts = (void*)0;
    buf->nelts = 0;
    buf->elt_size = elem_size;
    buf->nmax = 0;
}

/* frees memory */
void
buf_destroy(struct Buf *buf)
{
    if (buf && buf->elts) {
	free(buf->elts);
    }
    buf->elts = (void*)0;
}

/* appends ptr[] to buf, grow if necessary.
 * n_elem is number of elements in ptr[], NOT bytes.
 * returns buf.
 * We grow by mod(512) boundaries.
 */
struct Buf*
buf_append(struct Buf *buf, const void *ptr, size_t n_elem)
{
    size_t n_alloc = 0;

    if (!ptr || n_elem == 0) {
	return buf;
    }

    /* May need to alloc more. */
    if (n_elem + buf->nelts > buf->nmax) {
	/* exact amount needed... */
	n_alloc = (n_elem + buf->nelts) * buf->elt_size;

	/* ...plus some extra */
	if (((n_alloc * buf->elt_size) % 512) != 0 && buf->elt_size < 512) {
	    n_alloc += (512 - ((n_alloc * buf->elt_size) % 512)) / buf->elt_size;
	}
	if (!buf->elts) {
	    buf->elts = allocate_array(n_alloc, buf->elt_size);
	} else {
	    buf->elts = reallocate_array(buf->elts, n_alloc, buf->elt_size);
	}
	buf->nmax = n_alloc;
    }
    memcpy((char*)buf->elts + buf->nelts * buf->elt_size, ptr,
	n_elem * buf->elt_size);

    buf->nelts += n_elem;

    return buf;
}

/* --- */
/* input buffering support */

/* get pointer to the start of the first element */
static void*
buf_first_elt(struct Buf *buf)
{
    return buf->elts;
}

/* get pointer to the start of the last element */
static void*
buf_last_elt(struct Buf *buf)
{
    size_t first = (size_t)buf_first_elt(buf);

    if (buf->nelts < 1) {
	return NULL;
    }

    return (void*)(first + buf->elt_size * (buf->nelts - 1));
}

static void
buf_append_char(struct Buf *buf, char c)
{
    char *cp = &c;
    buf_append(buf, cp, sizeof(char) / buf->elt_size);
}

/* Copy up to n input characters to the end of scanner buffer. If EOF is
 * encountered before n characters are copied, scanner->atEOI flag is set.
 */
static void
bufferAppend(perplex_t scanner, size_t n)
{
    struct Buf *buf;
    FILE *in;
    size_t i;
    int c;
    char *bufStart;
    size_t markerOffset, tokenStartOffset, cursorOffset;

    buf = scanner->buffer;
    in = scanner->inFile;

    /* save marker offsets */
    bufStart = (char*)buf->elts;
    cursorOffset = (size_t)(scanner->cursor - bufStart);
    markerOffset = (size_t)(scanner->marker - bufStart);
    tokenStartOffset = (size_t)(scanner->tokenStart - bufStart);

    /* remove last (null) element */
    buf->nelts--;

    for (i = 0; i < n; i++) {
	if ((c = fgetc(in)) == EOF) {
	    scanner->atEOI = 1;
	    break;
	}
	buf_append_char(buf, c);
    }

    /* (scanner->null - eltSize) should be the last input element,
     * we put a literal null after this element for debugging
     */
    buf_append_char(buf, '\0');
    scanner->null = (char*)buf_last_elt(buf);

    /* update markers in case append caused buffer to be reallocated */
    bufStart = (char*)buf->elts;
    scanner->cursor = bufStart + cursorOffset;
    scanner->marker = bufStart + markerOffset;
    scanner->tokenStart = bufStart + tokenStartOffset;
}

/* Appends up to n characters of input to scanner buffer. */
static void
bufferFill(perplex_t scanner, size_t n)
{
    struct Buf *buf;
    size_t totalElts, usedElts, freeElts;

    if (scanner->atEOI) {
	/* nothing to add to buffer */
	return;
    }

    buf = scanner->buffer;

    totalElts = (size_t)buf->nmax;
    usedElts = (size_t)buf->nelts;
    freeElts = totalElts - usedElts;

    /* not enough room for append, shift buffer contents to avoid realloc */
    if (n > freeElts) {
	void *bufFirst, *scannerFirst, *tokenStart, *marker, *null;
	size_t bytesInUse, shiftSize;

	tokenStart = (void*)scanner->tokenStart;
	marker = (void*)scanner->marker;
	null = (void*)scanner->null;

	bufFirst = buf_first_elt(buf);

	/* Find first buffer element still in use by scanner. Will be
	 * tokenStart unless backtracking marker is in use.
	 */
	scannerFirst = tokenStart;
	if (marker >= bufFirst && marker < tokenStart) {
	    scannerFirst = marker;
	}

	/* bytes of input being used by scanner */
	bytesInUse = (size_t)null - (size_t)scannerFirst + 1;

	/* copy in-use elements to start of buffer */
	memmove(bufFirst, scannerFirst, bytesInUse);

	/* update number of elements */
        buf->nelts = bytesInUse / buf->elt_size;

	/* update markers */
	shiftSize = (size_t)scannerFirst - (size_t)bufFirst;
	scanner->marker     -= shiftSize;
	scanner->cursor     -= shiftSize;
	scanner->null       -= shiftSize;
	scanner->tokenStart -= shiftSize;
    }
    bufferAppend(scanner, n);
}

char*
getTokenText(perplex_t scanner)
{
    int tokenChars = scanner->cursor - scanner->tokenStart;

    if (scanner->tokenText != NULL) {
	free(scanner->tokenText);
    }

    scanner->tokenText = (char*)malloc(sizeof(char) * (tokenChars + 1));

    memcpy(scanner->tokenText, scanner->tokenStart, tokenChars);
    scanner->tokenText[tokenChars] = '\0';

    return scanner->tokenText;
}

/* scanner helpers */
#define UPDATE_START  scanner->tokenStart = scanner->cursor;
#define IGNORE_TOKEN  UPDATE_START; continue;
#define yytext        getTokenText(scanner)

static void*
copyString(const char *str)
{
    void *copy;
    size_t numChars = strlen(str) + 1;

    copy = malloc(numChars * sizeof(char));
    strncpy(copy, str, numChars);

    return copy;
}

static void
copyTokenText(perplex_t scanner) {
    scanner->appData->tokenData.string = (char*)copyString(yytext);
}

static perplex_t
newScanner(void)
{
    perplex_t scanner;
    scanner = (perplex_t)calloc(1, sizeof(struct perplex));

    return scanner;
}

/* public functions */

perplex_t
perplexFileScanner(FILE *input)
{
    char *bufFirst;
    perplex_t scanner = newScanner();

    scanner->inFile = input;

    scanner->buffer = (struct Buf*)malloc(sizeof(struct Buf));
    buf_init(scanner->buffer, sizeof(char));
    buf_append_char(scanner->buffer, '\0');

    bufFirst = (char*)scanner->buffer->elts;
    scanner->null = scanner->marker = scanner->cursor = bufFirst;

    return scanner;
}

void
perplexFree(perplex_t scanner)
{
    if (scanner->buffer != NULL) {
	buf_destroy(scanner->buffer);
	free(scanner->buffer);
    }

    free(scanner);
}

/* start-condition support */
static void
setCondition(perplex_t scanner, condition_t cond)
{
    scanner->condition = cond;
}

static condition_t
getCondition(perplex_t scanner)
{
    return scanner->condition;
}

/* required re2c macros */
#define YYGETCONDITION     getCondition(scanner)
#define YYSETCONDITION(c)  setCondition(scanner, c)
#define YYFILL(n)          bufferFill(scanner, n)

/* scanner */
static int perplexScan(perplex_t scanner);

int yylex(perplex_t scanner) {
    int ret;

    scanner->tokenText = NULL;

    ret = perplexScan(scanner);

    if (scanner->tokenText != NULL) {
	free(scanner->tokenText);
	scanner->tokenText = NULL;
    }

    return ret;
}

static int
perplexScan(perplex_t scanner) {
    char yych;

    UPDATE_START;

    while (1) {
	if (scanner->atEOI && scanner->cursor >= scanner->null) {
	    return YYEOF;
	}

#line 561 "perplex_scanner.c"
{
	unsigned int yyaccept = 0;
	switch (YYGETCONDITION) {
		case 0: goto yyc_0;
		case rules: goto yyc_rules;
		case definitions: goto yyc_definitions;
		case code: goto yyc_code;
		case bracket_string: goto yyc_bracket_string;
		case dquote_string: goto yyc_dquote_string;
		case squote_string: goto yyc_squote_string;
		case comment: goto yyc_comment;
		case line_comment: goto yyc_line_comment;
		case condition_list: goto yyc_condition_list;
	}
/* *********************************** */
yyc_0:
	YYSETCONDITION(definitions);
	continue;
/* *********************************** */
yyc_rules:
	if ((scanner->null - scanner->cursor) < 4) YYFILL(4);
	yych = *scanner->cursor;
	switch (yych) {
		case '\t':
		case ' ': goto yy4;
		case '\n': goto yy6;
		case '"': goto yy7;
		case '%': goto yy8;
		case '\'': goto yy9;
		case '/': goto yy10;
		case ':': goto yy11;
		case ';': goto yy12;
		case '<': goto yy14;
		case '=': goto yy16;
		case '[': goto yy18;
		case '{': goto yy19;
		case '}': goto yy21;
		default: goto yy2;
	}
yy2:
	yyaccept = 0;
	yych = *(scanner->marker = ++scanner->cursor);
	switch (yych) {
		case '%': goto yy23;
		case '<': goto yy25;
		default: goto yy3;
	}
yy3:
#line 731 "scanner.re"
	{
    continue;
}
#line 614 "perplex_scanner.c"
yy4:
	yyaccept = 1;
	yych = *(scanner->marker = ++scanner->cursor);
	switch (yych) {
		case '%': goto yy23;
		case '<': goto yy25;
		default: goto yy5;
	}
yy5:
#line 662 "scanner.re"
	{
    /* matched single whitespace */
    if (strlen(yytext) == 1) {
	IGNORE_TOKEN;
    }

    /* matched end of word */
    copyTokenText(scanner);

    if (!scanner->inAction) {
	switch (scanner->appData->tokenData.string[0]) {
	    case '"':
	    case '\'':
	    case '[':
	    case '(':
	    case '.':
		return TOKEN_PATTERN;
	}
	return TOKEN_NAME;
    }

    return TOKEN_WORD;
}
#line 648 "perplex_scanner.c"
yy6:
	++scanner->cursor;
	goto yy5;
yy7:
	++scanner->cursor;
	YYSETCONDITION(dquote_string);
	continue;
yy8:
	yyaccept = 0;
	yych = *(scanner->marker = ++scanner->cursor);
	switch (yych) {
		case '%': goto yy26;
		case '<': goto yy25;
		default: goto yy3;
	}
yy9:
	++scanner->cursor;
	YYSETCONDITION(squote_string);
	continue;
yy10:
	yyaccept = 0;
	yych = *(scanner->marker = ++scanner->cursor);
	switch (yych) {
		case '%': goto yy23;
		case '*': goto yy27;
		case '/': goto yy28;
		case '<': goto yy25;
		default: goto yy3;
	}
yy11:
	yyaccept = 0;
	yych = *(scanner->marker = ++scanner->cursor);
	switch (yych) {
		case '%': goto yy23;
		case '<': goto yy25;
		case '=': goto yy29;
		default: goto yy3;
	}
yy12:
	yyaccept = 2;
	yych = *(scanner->marker = ++scanner->cursor);
	switch (yych) {
		case '%': goto yy23;
		case '<': goto yy25;
		default: goto yy13;
	}
yy13:
#line 619 "scanner.re"
	{
    if (scanner->inDefinition) {
	scanner->inDefinition = 0;
	copyTokenText(scanner);
	return TOKEN_DEFINITION;
    }
    continue;
}
#line 705 "perplex_scanner.c"
yy14:
	yyaccept = 3;
	yych = *(scanner->marker = ++scanner->cursor);
	switch (yych) {
		case '%': goto yy23;
		case '<': goto yy25;
		default: goto yy15;
	}
yy15:
#line 599 "scanner.re"
	{
    /* matched '<' at start of line or section */
    if (strlen(yytext) == 1 || yytext[0] == '\n') {
	YYSETCONDITION(condition_list);
    }
    continue;
}
#line 723 "perplex_scanner.c"
yy16:
	yyaccept = 4;
	yych = *(scanner->marker = ++scanner->cursor);
	switch (yych) {
		case '%': goto yy23;
		case '<': goto yy25;
		case '>': goto yy30;
		default: goto yy17;
	}
yy17:
#line 610 "scanner.re"
	{
    if (scanner->inAction) {
	continue;
    } else {
	scanner->inDefinition = 1;
	copyTokenText(scanner);
	return TOKEN_SPECIAL_OP;
    }
}
#line 744 "perplex_scanner.c"
yy18:
	++scanner->cursor;
	YYSETCONDITION(bracket_string);
	continue;
yy19:
	yyaccept = 5;
	yych = *(scanner->marker = ++scanner->cursor);
	switch (yych) {
		case '%': goto yy23;
		case '<': goto yy25;
		default: goto yy20;
	}
yy20:
#line 627 "scanner.re"
	{
    /* brace appears inside condition scope */
    if (scanner->conditionScope) {
	scanner->scopeBraceCount++;
    }

    scanner->braceCount++;
    if (scanner->braceCount == 1) {
	scanner->inAction = 1;
	return TOKEN_CODE_START;
    }
    continue;
}
#line 772 "perplex_scanner.c"
yy21:
	yyaccept = 6;
	yych = *(scanner->marker = ++scanner->cursor);
	switch (yych) {
		case '%': goto yy23;
		case '<': goto yy25;
		default: goto yy22;
	}
yy22:
#line 640 "scanner.re"
	{
    /* brace appears inside condition scope */
    if (scanner->conditionScope) {

	scanner->scopeBraceCount--;

	/* brace closes scope */
	if (scanner->scopeBraceCount == 0) {
	    scanner->conditionScope = 0;
	    return TOKEN_END_SCOPE;
	}
    }

    scanner->braceCount--;

    /* brace closes rule code */
    if (scanner->braceCount == 0) {
	scanner->inAction = 0;
	return TOKEN_CODE_END;
    }
    continue;
}
#line 805 "perplex_scanner.c"
yy23:
	yych = *++scanner->cursor;
	switch (yych) {
		case '%': goto yy32;
		default: goto yy24;
	}
yy24:
	scanner->cursor = scanner->marker;
	switch (yyaccept) {
		case 0: goto yy3;
		case 1: goto yy5;
		case 2: goto yy13;
		case 3: goto yy15;
		case 4: goto yy17;
		case 5: goto yy20;
		default: goto yy22;
	}
yy25:
	++scanner->cursor;
#line 595 "scanner.re"
	{
    copyTokenText(scanner);
    return TOKEN_WORD;
}
#line 830 "perplex_scanner.c"
yy26:
	yych = *++scanner->cursor;
	switch (yych) {
		case '\n': goto yy33;
		case '%': goto yy32;
		default: goto yy24;
	}
yy27:
	++scanner->cursor;
	YYSETCONDITION(comment);
	continue;
yy28:
	++scanner->cursor;
	YYSETCONDITION(line_comment);
	continue;
yy29:
	yych = *++scanner->cursor;
	switch (yych) {
		case '>': goto yy30;
		default: goto yy24;
	}
yy30:
	++scanner->cursor;
	if (scanner->null <= scanner->cursor) YYFILL(1);
	yych = *scanner->cursor;
	switch (yych) {
		case '\t':
		case '\n':
		case ' ': goto yy30;
		default: goto yy31;
	}
yy31:
#line 606 "scanner.re"
	{
    copyTokenText(scanner);
    return TOKEN_SPECIAL_OP;
}
#line 868 "perplex_scanner.c"
yy32:
	yych = *++scanner->cursor;
	switch (yych) {
		case '\n': goto yy34;
		default: goto yy24;
	}
yy33:
	++scanner->cursor;
#line 582 "scanner.re"
	{
    /* Matched "%%\n" appearing at start of file or start of line.
     * We don't match the optional preceding '\n' so that '\n' can still
     * end a word (e.g. "foo\n%%\n" is a word followed by a separator).
     */
    if (YYGETCONDITION == definitions) {
	YYSETCONDITION(rules);
    } else {
	YYSETCONDITION(code);
    }
    return TOKEN_SEPARATOR;
}
#line 890 "perplex_scanner.c"
yy34:
	++scanner->cursor;
#line 578 "scanner.re"
	{
    copyTokenText(scanner);
    return TOKEN_WORD;
}
#line 898 "perplex_scanner.c"
/* *********************************** */
yyc_definitions:
	if ((scanner->null - scanner->cursor) < 4) YYFILL(4);
	yych = *scanner->cursor;
	switch (yych) {
		case '\t':
		case ' ': goto yy38;
		case '\n': goto yy40;
		case '"':
		case '\'':
		case '[': goto yy41;
		case '%': goto yy42;
		default: goto yy36;
	}
yy36:
	yyaccept = 0;
	yych = *(scanner->marker = ++scanner->cursor);
	switch (yych) {
		case '%': goto yy43;
		default: goto yy37;
	}
yy37:
#line 731 "scanner.re"
	{
    continue;
}
#line 925 "perplex_scanner.c"
yy38:
	yyaccept = 1;
	yych = *(scanner->marker = ++scanner->cursor);
	switch (yych) {
		case '%': goto yy43;
		default: goto yy39;
	}
yy39:
#line 685 "scanner.re"
	{
    /* matched single whitespace */
    if (strlen(yytext) == 1) {
	IGNORE_TOKEN;
    }

    /* matched end of word */
    copyTokenText(scanner);
    return TOKEN_WORD;
}
#line 945 "perplex_scanner.c"
yy40:
	++scanner->cursor;
	goto yy39;
yy41:
	++scanner->cursor;
	goto yy37;
yy42:
	yyaccept = 0;
	yych = *(scanner->marker = ++scanner->cursor);
	switch (yych) {
		case '%': goto yy45;
		default: goto yy37;
	}
yy43:
	yych = *++scanner->cursor;
	switch (yych) {
		case '%': goto yy46;
		default: goto yy44;
	}
yy44:
	scanner->cursor = scanner->marker;
	if (yyaccept == 0) {
		goto yy37;
	} else {
		goto yy39;
	}
yy45:
	yych = *++scanner->cursor;
	switch (yych) {
		case '\n': goto yy47;
		case '%': goto yy46;
		default: goto yy44;
	}
yy46:
	yych = *++scanner->cursor;
	switch (yych) {
		case '\n': goto yy48;
		default: goto yy44;
	}
yy47:
	++scanner->cursor;
#line 582 "scanner.re"
	{
    /* Matched "%%\n" appearing at start of file or start of line.
     * We don't match the optional preceding '\n' so that '\n' can still
     * end a word (e.g. "foo\n%%\n" is a word followed by a separator).
     */
    if (YYGETCONDITION == definitions) {
	YYSETCONDITION(rules);
    } else {
	YYSETCONDITION(code);
    }
    return TOKEN_SEPARATOR;
}
#line 1000 "perplex_scanner.c"
yy48:
	++scanner->cursor;
#line 578 "scanner.re"
	{
    copyTokenText(scanner);
    return TOKEN_WORD;
}
#line 1008 "perplex_scanner.c"
/* *********************************** */
yyc_code:
	if (scanner->null <= scanner->cursor) YYFILL(1);
	yych = *scanner->cursor;
	switch (yych) {
		case '\t':
		case '\n':
		case ' ': goto yy51;
		default: goto yy50;
	}
yy50:
	++scanner->cursor;
#line 731 "scanner.re"
	{
    continue;
}
#line 1025 "perplex_scanner.c"
yy51:
	++scanner->cursor;
#line 685 "scanner.re"
	{
    /* matched single whitespace */
    if (strlen(yytext) == 1) {
	IGNORE_TOKEN;
    }

    /* matched end of word */
    copyTokenText(scanner);
    return TOKEN_WORD;
}
#line 1039 "perplex_scanner.c"
/* *********************************** */
yyc_bracket_string:
	if ((scanner->null - scanner->cursor) < 2) YYFILL(2);
	yych = *scanner->cursor;
	switch (yych) {
		case '\\': goto yy54;
		case ']': goto yy55;
		default: goto yy53;
	}
yy53:
	++scanner->cursor;
#line 731 "scanner.re"
	{
    continue;
}
#line 1055 "perplex_scanner.c"
yy54:
	++scanner->cursor;
	goto yy56;
yy55:
	++scanner->cursor;
	YYSETCONDITION(rules);
	continue;
yy56:
	++scanner->cursor;
#line 696 "scanner.re"
	{
    /* escape sequence */
    continue;
}
#line 1070 "perplex_scanner.c"
/* *********************************** */
yyc_dquote_string:
	if ((scanner->null - scanner->cursor) < 2) YYFILL(2);
	yych = *scanner->cursor;
	switch (yych) {
		case '"': goto yy59;
		case '\\': goto yy60;
		default: goto yy58;
	}
yy58:
	++scanner->cursor;
#line 731 "scanner.re"
	{
    continue;
}
#line 1086 "perplex_scanner.c"
yy59:
	++scanner->cursor;
	YYSETCONDITION(rules);
	continue;
yy60:
	++scanner->cursor;
	++scanner->cursor;
#line 696 "scanner.re"
	{
    /* escape sequence */
    continue;
}
#line 1099 "perplex_scanner.c"
/* *********************************** */
yyc_squote_string:
	if ((scanner->null - scanner->cursor) < 2) YYFILL(2);
	yych = *scanner->cursor;
	switch (yych) {
		case '\'': goto yy63;
		case '\\': goto yy64;
		default: goto yy62;
	}
yy62:
	++scanner->cursor;
#line 731 "scanner.re"
	{
    continue;
}
#line 1115 "perplex_scanner.c"
yy63:
	++scanner->cursor;
	YYSETCONDITION(rules);
	continue;
yy64:
	++scanner->cursor;
	++scanner->cursor;
#line 696 "scanner.re"
	{
    /* escape sequence */
    continue;
}
#line 1128 "perplex_scanner.c"
/* *********************************** */
yyc_comment:
	if ((scanner->null - scanner->cursor) < 2) YYFILL(2);
	yych = *scanner->cursor;
	switch (yych) {
		case '*': goto yy68;
		default: goto yy66;
	}
yy66:
	++scanner->cursor;
yy67:
#line 731 "scanner.re"
	{
    continue;
}
#line 1144 "perplex_scanner.c"
yy68:
	yych = *++scanner->cursor;
	switch (yych) {
		case '/': goto yy69;
		default: goto yy67;
	}
yy69:
	++scanner->cursor;
	YYSETCONDITION(rules);
#line 703 "scanner.re"
	{
    IGNORE_TOKEN;
}
#line 1158 "perplex_scanner.c"
/* *********************************** */
yyc_line_comment:
	if (scanner->null <= scanner->cursor) YYFILL(1);
	yych = *scanner->cursor;
	switch (yych) {
		case '\n': goto yy72;
		default: goto yy71;
	}
yy71:
	++scanner->cursor;
#line 731 "scanner.re"
	{
    continue;
}
#line 1173 "perplex_scanner.c"
yy72:
	++scanner->cursor;
	YYSETCONDITION(rules);
#line 706 "scanner.re"
	{
    IGNORE_TOKEN;
}
#line 1181 "perplex_scanner.c"
/* *********************************** */
yyc_condition_list:
	if ((scanner->null - scanner->cursor) < 2) YYFILL(2);
	yych = *scanner->cursor;
	switch (yych) {
		case '>': goto yy75;
		default: goto yy74;
	}
yy74:
	++scanner->cursor;
#line 731 "scanner.re"
	{
    continue;
}
#line 1196 "perplex_scanner.c"
yy75:
	yych = *(scanner->marker = ++scanner->cursor);
	switch (yych) {
		case '\t':
		case '\n':
		case ' ': goto yy77;
		case '{': goto yy79;
		default: goto yy76;
	}
yy76:
	YYSETCONDITION(rules);
#line 721 "scanner.re"
	{
    if (strlen(yytext) == 2) {
	/* matched "<>" */
	return TOKEN_EMPTY_COND;
    }

    copyTokenText(scanner);
    return TOKEN_CONDITION;
}
#line 1218 "perplex_scanner.c"
yy77:
	++scanner->cursor;
	if (scanner->null <= scanner->cursor) YYFILL(1);
	yych = *scanner->cursor;
	switch (yych) {
		case '\t':
		case '\n':
		case ' ': goto yy77;
		case '{': goto yy79;
		default: goto yy78;
	}
yy78:
	scanner->cursor = scanner->marker;
	goto yy76;
yy79:
	++scanner->cursor;
	YYSETCONDITION(rules);
#line 710 "scanner.re"
	{
    copyTokenText(scanner);

    /* trim everything after '>' */
    strchr(scanner->appData->tokenData.string, '>')[1] = '\0';

    scanner->conditionScope = 1;
    scanner->scopeBraceCount = 1;

    return TOKEN_START_SCOPE;
}
#line 1248 "perplex_scanner.c"
}
#line 735 "scanner.re"

    }
}

/*
 * Local Variables:
 * tab-width: 8
 * mode: C
 * indent-tabs-mode: t
 * c-file-style: "stroustrup"
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
